<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从0-1分布到二项目分布到泊松分布]]></title>
    <url>%2F2018%2F07%2F11%2F%E4%BB%8E0-1%E5%88%86%E5%B8%83%E5%88%B0%E4%BA%8C%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B8%83%E5%88%B0%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[从0-1分布到二项目分布到泊松分布前言爱因斯坦有一句名言：“如果你不能给六岁的小孩讲明白，其实你也没有真正明白”。这也是我检查写博客原因，就是为了定期的检验我学到的知识点。我们目标不是去讲复杂的知识，而是希望与把知识线一样的串联在一起，之后以简单的形式让人理解。 0-1分布0-1分布可以视为最简单的概率分布。一个随机事件只有两种可能A个非A,于是我们两个离散的点0，1表示。其中比如A发生的概率是p那么非A发生的概率就是(1-p)。他的分布律如下 P(X=k) = p^k .(1-p)^{1-k} ;其中k=0,1在数学上使用$ X ~ B(x,p) $来表示。 这个很好理解就拿我们抛一次硬币举例，要么证明正面朝上，要么反面朝上。 二项分布好了现在我们要通过0-1分布过度到二项分布中来。现在依旧以抛硬币这个事件来说。我现在不是抛一次了。我现在要实验n次（也就是人们说的n次独立伯努利试验），现在我要研究什么呢？不在是出现正面的概率了（次数抛了多次讨论哪个也没有什么意义），而我现在想知道这n次实验之后出现正面次数k的概率。 为了方便研究我们先计算一个简单的情况，我们规定实验3次，而我们研究出现一次的概率。我们发现这里抛了三次但是出现了一次正面，那么在那次出现的正面呢？这出现的可能情况的个数显然是个组合数。$C_{3}^{1}$ 这里表示在3个里面选择一个。 然后这一次发生的概率是$ p^{1} $ 而不发生的情况有两种就是$ (1-p)^{3-1} $他们相乘才是一种只出现一次的可能，现在我们要算总共出现1证明的概率，于是还要累加组合数个，于是得出概率是$ C_{3}^{1} p^{1} (1-p)^{3-1} $ ; 现在可以推广一下把上面的实验次从3数变成n，把出现的次数从1变成k我们就得到了二项分布的概率分布： P(X=k)=C^{k}_{n}p^k(1-p)^{n-k};现在我们用python的代码来仿真一下看看是什么样的。 组合式计算公式：$ C_m^n = \frac{n!}{m!(n-m)!} $ 123456789101112from pylab import *def plot_binomial(n,p): '''绘制二项分布的概率质量函数''' sample = np.random.binomial(n,p,size=10000) # 产生10000个符合二项分布的随机数 bins = np.arange(n+2) plt.hist(sample, bins=bins, align='left', rwidth=0.1) # 绘制直方图 #设置标题和坐标 plt.title('Binomial PMF with n=&#123;&#125;, p=&#123;&#125;'.format(n,p)) plt.xlabel('number of successes') plt.ylabel('probability')plot_binomial(10, 0.5) 当然这里主要归功于np.random.binomial这个函数，生成了二项分布的数据。当然这段代码也不是我写的。如果要看源文章请以后看最后的传送门啦。 泊松分布我们抛啊抛啊，抛了好久，但是却无法知道我们抛了一分钟的情况下出现正面的情况大约是多少。现在泊松分布就要来解决这个问题了。我们要计算在单位时间内出现某个事件的概率来了。比如我们要计算出10分钟内某个医院中新生儿的个数。可是我们怎么计算呢？我们不能让每个母亲都去做实验看看她是生还是不生。我们有的数据仅仅是昨天一天来本医院的新生儿个数怎么办呢？ 我们看看我们的数据是一种什么数据，是一种频率数据，就是在固定时间内的一种数学期望成过。如果我们假设一分钟前出生的个数对下一分钟没有什么必然的影响，他们在时间上相互独立的，也就是说我们得到的这个频率在统计上应该是稳定的。那么我们可否使用这个值进行估计呢？答案是可以的。怎么做呢？这里要用到极限的思想了。 首先我们承认在一段时间内发生的频率相对稳定我们叫它$\lambda $ 。注意这个一个合理的基本的假设。 好了现在我们把一段时间分成n等份。然后在每份时间里有做一次实验。思考一下原来一段时间内发生的个数是$\lambda$现在分成了n份，也就是说在每一份中发生的概率为$p=\frac{\lambda}{n}$ 于是不发生的概率为$1-p=1-\frac{\lambda}{n}$ 。好了现在我们就有了n次n次独立伯努利试验了。他的概率分布直接上一个单元中的公式就可以了。 C^{k}_{n}p^k(1-p)^{n-k};可是注意观察这里的n不是什么正经玩应！我们要的是和$\lambda$的关系啊。而且有些是就像生孩子一样我们可以近似为每时每刻都在实验中。相当于在一段时间内做了无数次的实验。好吧我们对n取极限吧！ \lim_{n \to \infty,p \to 0} C^{k}_{n}p^k(1-p)^{n-k}; \lim \frac{n(n-1)...(n-k+1)}{k!}p^k(1-p)^{n-k}在分母提取一个$n^k$。于是： \lim \frac{n^k[ 1(1-\frac{1}{n})...(1-\frac{k+1}{n})]}{k!}p^k(1-p)^{n-k}因为$n \to \infty$ 所以中括号里面的部分都变成了1。于是乎原式为： \lim \frac{n^kp^k}{k!}(1-p)^{n-k}现在看左边，由于我们知道$np = \lambda$;这里就可以变为$\frac{\lambda^k}{k!}$;好了我们现在单单看看右侧的部分，先抄写一遍。 \lim (1-p)^{n-k}先展开。后面那项的极限为1.不信你看。 \lim(1-p)^n \lim (1-p)^k先我们知道了$n=\frac{\lambda}{p}$代入到上面得到了。 lim(1-p)^{\frac{\lambda}{p}} PS :还记得吗？e的公式$ e = \lim_{n \to \infty } (1+\frac{1}{n})^n $ 于是乎得到的是$[ \lim(1+(-p)^{\frac{1}{-p}} ]^{-\lambda} = e^{-\lambda}$ 。现在我们的就得到了单位时间内发生次数的概率分布。 P(X=k) = \frac{\lambda^k}{k!} e^{-\lambda}发现了没有只和单位时间发生的频率有关。 好了现在我们看一下python仿真： 123456789from pylab import *lamb = 6sample = np.random.poisson(lamb, size=10000) # 生成10000个符合泊松分布的随机数bins = np.arange(20)plt.hist(sample, bins=bins, align='left', rwidth=0.1) # 绘制直方图# 设置标题和坐标轴plt.title('Poisson PMF (lambda=6)')plt.xlabel('number of arrivals')plt.ylabel('probability')plt.show() 后记好了现在送上传送门。这里是没有模仿实验的过程，而是直接生产符合概率分布的数据。所以要仿真的话，似乎可以不去关心生产的过程。 我将一直的迷惑和无知，我是黄油香蕉句，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>泊松分布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java小记-如何获取类定义中泛型的clazz-运行时泛型的真正类型]]></title>
    <url>%2F2018%2F06%2F28%2FJava%E5%B0%8F%E8%AE%B0-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%AD%E6%B3%9B%E5%9E%8B%E7%9A%84clazz-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%9C%9F%E6%AD%A3%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java小记-如何获取类定义中泛型的clazz-运行时泛型的真正类型知识点很偏。型如： 123456public abstract class TestA&lt;T&gt;&#123; public void test()&#123; //这里要获取到泛型T的具体类型 &#125;&#125; 这个时候怎么办呢？ 方法很简单代码如下： 12345678910public abstract class TestA&lt;T&gt;&#123; public void test()&#123; //这里要获取到泛型T的具体类型 &#125; public Class&lt;T&gt; getClazz()&#123; return (Class &lt;T&gt;)((ParameterizedType)getClass().getGenericSuperclass()).getActualTypeArguments()[0]; &#125;&#125; 注意这里的方法是获取到当前类的泛型的参数列表，然后获取其中第一个参数。因为我们这里只定义了一个泛型嘛，如果要使用两个，或者更多只需要更改数组索引和返回类型就可以了。 相信你可以写出更加骚气的代码。 我将一直的无知与迷惑，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记《告别百年激进》（温铁军演讲录）]]></title>
    <url>%2F2018%2F06%2F24%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8A%E5%91%8A%E5%88%AB%E7%99%BE%E5%B9%B4%E6%BF%80%E8%BF%9B%E3%80%8B%EF%BC%88%E6%B8%A9%E9%93%81%E5%86%9B%E6%BC%94%E8%AE%B2%E5%BD%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读书笔记《告别百年激进》（温铁军演讲录）前言：书中扉页一开始这样写道： We can’t solve problems by using the same kind of thinking we used when we created them. ——Albert Einstein 阿尔伯特·爱因斯坦的这句名言可直译为:“我们不能用导致问题的同一思维去解决问题。”对应中国的老话,当为孔子所言君子“不贰过”。 ——作者注 每当我因为自己渺小无知而揣测人类的渺小无知而失望透顶时，看到这些总会出现一丝希望。 这本书写了什么？这本书的是温铁军教授（应该尊称为先生）在2004到2014的演讲实录。温铁军是谁呢？中国三农问题专家，是前中央的政策研究人员。是国内少数批判中国激进现代化的人之一。但我不晓得有没有第二个。他总是带着微笑说“接受批评”。他有独特的问题意识，这在我看来是特别宝贵的。因为他不相信所谓意识形态话语的那一套。他的工作性质和他的性格阅历保证了他不会被过度政治化的话语体系所束缚。这样才有了有意义的理论创新和中国经验的展示。他是一个用“脚”做学问的学者。苏联解体时，他自费到苏联和苏东国家，去看看到底发生了什么事。也去了印度的“毛”派游击地区，去了解当地的实际情况，等等。这才让我感受到了，读万卷书不如行万里路。 读完这本书我才有可能真正的了解历史上发生的一些事件其背后的深层次原因。才可以有一点独立思考的可能性，如果不是视而不见的话。当然要明白这本书写了什么做好的方法是拿原文来读。下面我会写一些我的阅读笔记和其他一些我自己的思考结果。所以觉得算不上是原始的知识。特此指出。 我的知识更新这里有的也是书中思想，注意其中很多内容已经和我本人思想混杂，特此声明。 一条逻辑链：成本转嫁论书中作者也说他的思想总结成一句话就是成本转嫁论。什么意思？完成现代化是需要成本的，这个成本谁来付出呢？如果由城市的工业部门付出，对不起！那就干脆说你不要搞现代化。西方经济学试用条件是，资本相对稀缺的情况下，而不讨论资本觉得稀缺的情况。所以任何一个要搞现代化新兴国家，一定是亲资本的。 于是乎我们从历史上看新兴国家怎么亲资本呢？。由于国家长期的或民族独立战争或从宗主国获得独立后，国内资本绝对短缺的情况下必然的结果是亲外资。于是我们看到无论是所谓计划经济时期，因为朝鲜战争所引进的苏联工业体系，还是后来改革开放后东南沿海大规模外资引进。无论这两个资本什么色，注意他本质是新兴国家在进行现代化建设初期，因资本短缺而进行亲外资而在政策层面的必然结果。 我们说经济基础绝对上层建筑。于是乎就有了全盘苏话和后来的各种学者媒体乃至部分上层建筑中的普世价值和发展主义。去意识形态的看这个问题，你会发现。毛和小平同志做的并没有什么不同。也不论谁对谁错。 这么说我们的原始积累阶段是靠外资吗？当然不是。刚才上方所论述的仅关于政府亲外资的内在逻辑和历史事实。而成本转嫁论中关于中国原始积累阶段中城市现代化的成本必然不是外资出的。因为在历史上中国由于苏联交恶和某事件而导致国际社会的封锁。导致了外资进不来。那么中央怎么处理这个问题呢？ 城乡二元结构。通过剪刀差来向农村获取剩余。结论是什么。中国由于有城乡二元结构导致了我们可以把成本转嫁到农村。这是可以转嫁的成本，那么不可以转嫁的成本怎么办呢？转嫁给了资源环境。 现在回想一下，是不是和你生活中很多经验可以对照上了呢！ 什么是科学的？关于成本转嫁论，在原文中有更加精彩的描述。这里我不花时间赘述。这里有一个关于怎么不被忽悠的方法。就是怎么判断一个理论一个说法是不是科学的。这个专门针对经济学。首先他理论的逻辑出发点要和产生这以理论的历史一致，这样的理论才可能是科学的。 举个例子。比如所谓的自由主义，或者大肆宣传市场万能论的人。比如什么：崩溃疗法。这种东西。DM不能信的。比如欧洲在大肆的提所谓的人权问题时，别忘了，他们在原本积累阶段使用的方式是殖民和掠夺。这部分现代化的成本是非洲黑奴（非洲原住民）和《雾都孤儿》里平民付的。所以他们无论将自己的制度描述的多么好，也掩盖不了他们所说的没有毛病的自由经济发展历史在这个世界上不存在的事实。如果你自己分析这些西方的自由主义经济学的描述，就会发现，实证的证明示例少的可怜，或者就是被意识形态化后的洗白版本。也就是说我们研究问题时，特别是经济问题时往往都没有切身的去看真实情况。“眼中有数，心里没人”。这个恐怖的。 被异化！异化这个词是我在读完全书后的一个特别的体验。很有意思。当一个事物逐渐脱离了太产生时的各种本质，那么我们可以说他被异化了。这点我不知道应该怎么描述。举个例子。比如我们说律师这个职业是利用法律来赚钱的职业，他本来是一个谋生的行业。但是他背后所带来的社会认同和社会地位怎么来的呢？为什么在金政委和小鲜肉对决的视频中（我记得在凤凰卫视的一个节目）为什么留美律师要不断的说什么法的精神呢？以我言之，是利益集团的高度自觉化。我的逻辑是这样的，比如我程序员，那么我一定觉得科技是最重要的，也会这样宣传，因为这样我的团体才可以获取更大的利益，（当然今天的程序员并不是这样，至少我没有疯）。在关于是否要用程序去解决这问题上我觉得应该弹性的看。也就是说不要什么话语权正确来左右决策。 而被异化的概念不行。 先到这里吧。我饿了。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>看书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重写大学毕设中文分词器]]></title>
    <url>%2F2018%2F06%2F21%2F%E9%87%8D%E5%86%99%E5%A4%A7%E5%AD%A6%E6%AF%95%E8%AE%BE%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[重写大学毕设中文分词器前言大家好，香蕉君好久没有更新blog了。大家有没有好好学习T_T!最近我在搞elasticsearch做搜索，话说这个es真是一个不错的东西。搞的我脑壳都大咯。哈哈。虽然如此但是还是学到一些骚气的新姿势。就好像闭关修炼了一段时间一般，此时身上的内力无处发泄，怎么办？重写一个项目吧！于是我准备使用java重写一遍我大学的毕设。没有错！我大学毕设是实现一个通过“生语料库”学习进行分词的分词器。 生语料库是指收集之后未加工的语料库 相对而言，熟语料库就是经过加工的语料库。比如：我爱北京天安门。就是一段生的语料。而：我\爱\北京\天安门。就是熟的。 原来我是使用c/c++实现的。如果你感兴趣我可以给传送门。还有不要指望它可以跑起来,因为这个我大约二分之一时间时提交的代码，和我后来交作品的时候完全不一样。哈哈，之所以拿出来，只不过让大家看看我以前的黑历史，还有什么都敢往git上传的精神。好吧，久等了我们进入正文吧！HERE WE GO！ 使用技术和特性 使用java中泛型,还有多态的一些玩法。 使用枚举实现的状态机 使用buffer，主要是java内生实现的快速的io读写。 嗯就这么多了。感觉没有什么了不起对不对？当然如果你要百度可以找到很多有关的信息。可是在以上这些知识都是我新学的。可能你觉得夸张我来给你讲一下效果。我之前的C的代码写的和屎一样。但是我当年的我却以为自己算是我们年级编程能力比较强的那几个了。那时我读并且完成学习任务十万字的生语料库（我映像中10几个M吧），第一个版本花了我一天一宿结果还没有读完，我写的第二个版本30分钟多。于是演示的时候只能给老师们看学习后结果。而现在学习加分析只需10秒内。注意是10秒内。我的天啊，不好奇吗？来看看我用了什么黑魔法吧。 别急！看看我们要做什么！说了这么多还是吹逼的话，你可能会说还是云里雾里的。这个分词器怎么实现呢？放心我再也不会给出什么高大上的数学公式了。也不涉及什么高深的算法。其实就两个工作。 读文本记录下来不重复的出现了什么字。然后给每个字一个唯一的编号。 看看字出现的顺序。然后填写一个记录字间信息的矩阵就好了。 这个矩阵怎么表示呢？其实也很简单。比如 我是黄油香蕉句这句话。我的编号是1，是的编号是11。那么第一行第十一列就在原来的数值上加个1。（初始的时候这个矩阵都是0） 获取你要问为什么要用这个矩阵呢？答案很简单。我们仅仅看一行的值。比如我后面可能出现的子是什么呢？是和们等。但是一些乱七八糟的字就很少出现。于是我们更加倾向于认为我们和我是这样出现概率高的是一个词，而出现很少的就不认为是一个词了。 想想！可能遇到的困难？ 读写速度 识别中文和标点和英文 表示我们刚才说的那个矩阵 来我们一个一个解决。(实际上我也是这么做的，先列出可能的困难在一个个攻破) 读写文件问题Java是自己带着文件输入输出流的。但是用书上写的readLine慢的可以。我保证如果你用这种方法读写文件你可以瞬间恨上这种语言。 思考一下一般读写文件最快的方法是一次性的读到内存中再进行操作，所以说一般都有个什么临时缓存的东西。于是我们在百度中就找到了。ByteBuffer这个类。这个类可以将缓存到内存中进行快速的读写。（当然也是使用MappedByteBuffer 来实现内存映射） 如果你有兴趣可看看下面这测试代码。速度快到你不敢相信。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.zzh.com.test;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.MappedByteBuffer;import java.nio.channels.FileChannel;/** * Created by zhouzihao on 2018/6/11. */public class TestBuffer &#123; //下面放上你的测试文件的地址 private static final String file = "/Users/zhouzihao/mytmp/statetest/testfile.txt"; public static void readByChannel(int allocate) throws IOException &#123; long start = System.currentTimeMillis(); RandomAccessFile fis = new RandomAccessFile(new File(file), "rw"); FileChannel channel = fis.getChannel(); long size = channel.size(); // 构建一个只读的MappedByteBuffer MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, size); // 如果文件不大,可以选择一次性读取到数组 // byte[] all = new byte[(int)size]; // mappedByteBuffer.get(all, 0, (int)size); // 打印文件内容 // System.out.println(new String(all)); // 如果文件内容很大,可以循环读取,计算应该读取多少次 byte[] bytes = new byte[allocate]; long cycle = size / allocate; int mode = (int)(size % allocate); //byte[] eachBytes = new byte[allocate]; for (int i = 0; i &lt; cycle; i++) &#123; // 每次读取allocate个字节 mappedByteBuffer.get(bytes); // 打印文件内容,关闭打印速度会很快 // System.out.print(new String(eachBytes)); System.out.print(new String(bytes)); &#125; if(mode &gt; 0) &#123; bytes = new byte[mode]; mappedByteBuffer.get(bytes); System.out.print(new String(bytes)); // 打印文件内容,关闭打印速度会很快 // System.out.print(new String(eachBytes)); &#125; // 关闭通道和文件流 channel.close(); fis.close(); long end = System.currentTimeMillis(); System.out.println(String.format("\n===&gt;文件大小：%s 字节", size)); System.out.println(String.format("===&gt;读取并打印文件耗时：%s毫秒", end - start)); &#125;&#125; 识别中文和标点和英文首先我们不能假设文件中没有英文和标点符号，于是乎我们要有个方法来很好的区分中英文。其中有一种方法是吧中文英文转成ASCII码之后在用数值进行判断。我记得我之前的C语言版本就是如此但是并不好。在java中有许多的已设置的常量，如果可以用起来也是很优雅的。于是我们有了下面的代码。（我放在了Until.class中做静态方法） 123456789101112131415161718192021package com.zzh.com.test;/** * Created by zhouzihao on 2018/6/11. */public class Until &#123; public static boolean isChinese(char c) &#123; Character.UnicodeBlock ub = Character.UnicodeBlock.of(c); if (ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS || ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B || ub == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION || ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS || ub == Character.UnicodeBlock.GENERAL_PUNCTUATION) &#123; return true; &#125; return false; &#125;&#125; 好的，我们知道了怎么判断中英文，但是还是不够的。我想写个什么for或者while循环然后在里面写上一堆令人头疼的if-else了。因为那种代码的可读性和性能都是一个噩梦。但是不写这些要怎么做呢？我们回顾一下程序操作的流程。读然后判断如果中文就进行中文的处理，如果标点就进行标点的处理，如果是英文就进行英文的处理。而且还要记录出上一个处理的状态。怎么样？想到了什么？使用状态机不可以吗？ Java正好可以用枚举类型实现一个状态机。读者不妨先看看传送门。怎么样是不是很神奇，更神奇的是使用这种方法的速度和效率也不低。于是我们要定义一个给状态机状态枚举使用的接口。然后还有我们要保证的重要状态的上下文。如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zzh.com.test;import java.nio.ByteBuffer;import java.util.List;import java.util.Map;/** * 上下文 * Created by zhouzihao on 2018/6/8. */public interface Context &#123; /** * get the buffer of file * @return */ ByteBuffer buffer(); /** * get current State * @return */ State state(); /** * set current State * @return */ void state(State state); /** * get the Index of Character * @return */ Map&lt;Character,Long&gt; index(); State preState(); void preState(State state); List&lt;Character&gt; indexList(); void addIndex(Character character); Matrix matrix();&#125; 其中Matrix 先定义在这里我们一会再说。 123456789package com.zzh.com.test;/** * Created by zhouzihao on 2018/6/8. */public interface State &#123; boolean process(Context context);&#125; 关于这个上下问的实现。正好用到了我们刚才说的ByteBuffer。可以先看一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.zzh.com.test;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Objects;import java.util.concurrent.ConcurrentHashMap;/** * Created by zhouzihao on 2018/6/8. */public class ContextImpl implements Context &#123; private State state; private State preState; private ByteBuffer buffer; private Map&lt;Character,Long&gt; indexMap = new ConcurrentHashMap&lt;&gt;(); private List&lt;Character&gt; list = new ArrayList&lt;&gt;(); private Matrix matrix = new ElasticMatrix(); public ContextImpl(List&lt;Character&gt; list, Matrix matrix) &#123; if (Objects.nonNull(list)) this.list = list; if (!Objects.nonNull(matrix)) this.matrix = matrix; &#125; @Override public Map&lt;Character, Long&gt; index() &#123; return this.indexMap; &#125; public void buffer(String file) throws IOException&#123; RandomAccessFile fis = new RandomAccessFile(new File(file), "rw"); FileChannel channel = fis.getChannel(); long size = channel.size(); buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, size); &#125; @Override public ByteBuffer buffer() &#123; return buffer; &#125; @Override public State state() &#123; return state; &#125; @Override public void state(State state) &#123; this.state = state; &#125; @Override public State preState() &#123; return preState; &#125; @Override public void preState(State state) &#123; preState = state; &#125; @Override public List&lt;Character&gt; indexList() &#123; return list; &#125; @Override public void addIndex(Character character) &#123; list.add(character); &#125; @Override public Matrix matrix() &#123; return matrix; &#125;&#125; 依旧是看不懂的部分可以先忽略。而关于状态机真正的实现最后在讲。现在我们知道了。我用要做的是搭好了使用状态机转换的架子。之后的状态包括流转规则一切都由我们自己说的算。但是关于这个枚举的实现我将最后给出。下面先看一个简单的。 二维的稀松矩阵的表示我们先要搞清楚我们的矩阵要什么方法。当然一个任何一个位置的值可以取到，可以修改，为了方便可以加一。于是乎接口就定义好了。如下： 12345678910111213141516171819202122232425262728293031323334package com.zzh.com.test;import java.io.Serializable;/** * 管理矩阵的类 2元组 * Created by zhouzihao on 2018/6/12. */public interface Matrix extends Serializable&#123; /** * 给固定位置添加一 * @param x * @param y */ void inc(Integer x,Integer y); /** * 获取固定位置的值 * @param x * @param y * @return */ Long getValue(Integer x,Integer y); /** * 设置固定位置的值 * @param x * @param y */ void setValue(Integer x,Integer y,Long value);&#125; 你会说这太简单了什么也没有实现。但是我相信你使用的接口虽然不能真正的运行但是可以假装已经实现先写代码了。这就是java使用接口去定义好处。这种语言自发性的让你去拆解了任务。现在你只要全身心的考虑怎么实现这样一个矩阵就可以了。用什么呢？作者愚钝，使用两层map吧。下面是代码真的简单不解释了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.zzh.com.test;import java.util.HashMap;import java.util.Map;import java.util.Objects;/** * 可伸缩二维 的 稀松矩阵 * Created by zhouzihao on 2018/6/13. */public class ElasticMatrix implements Matrix&#123; private Map&lt;Integer,Map&lt;Integer,Long&gt;&gt; data = new HashMap&lt;&gt;(); @Override public void inc(Integer x, Integer y) &#123; if(Objects.isNull(getValue(x,y)))&#123; setValue(x,y,1L); return; &#125;else &#123; setValue(x,y,getValue(x,y) + 1L); &#125; &#125; @Override public Long getValue(Integer x, Integer y) &#123; Map&lt;Integer,Long&gt; yy = data.get(x); if (Objects.isNull(yy))&#123; return null; &#125; if (Objects.isNull(yy.get(y)))&#123; return null; &#125; return yy.get(y); &#125; @Override public void setValue(Integer x, Integer y, Long value) &#123; Map&lt;Integer,Long&gt; yy = data.get(x); if (Objects.isNull(yy))&#123; yy = new HashMap&lt;Integer,Long&gt;(); yy.put(y,value); data.put(x,yy); return; &#125; data.get(x).put(y,value); &#125;&#125; 当然如果你愿意的话可以将上面的改成使用泛型。不过我这是一个特定问题，还没有抽象到这样一个层次的必要。 实现状态机那么怎么实现这个状态机核心部分呢？ 这里不愿意讲的太细。因为真的简单只有4个状态开始，中文字符，英文包括英文标点，结束而已。有了上面的准备工作我们现在仅仅要在一个状态中判断字符形态在移到下一个状态即可了。少废话看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.zzh.com.test;import static java.lang.Character.UnicodeBlock.*;/** * Created by zhouzihao on 2018/6/8. */public enum States implements State &#123; START&#123; @Override public boolean process(Context context) &#123; /** * 判断中文英文还是结束 */ if (context.buffer().position() == context.buffer().capacity())&#123; context.state(END); return true; &#125; context.buffer().mark();//标记 if(context.buffer().capacity()-context.buffer().position()&gt;=3)&#123; byte[] test = new byte[3]; context.buffer().get(test); char[] list = new String(test).toCharArray(); if(Until.isChinese(list[0])) &#123; context.state(CN); &#125;else &#123; context.state(EN); &#125; &#125;else &#123; context.state(EN); &#125; return true; &#125; &#125;, CN&#123; @Override public boolean process(Context context) &#123; context.buffer().reset();//恢复 byte[] test = new byte[3];//中文要读3个字符 context.buffer().get(test); char[] list = new String(test).toCharArray(); indexOf(context,list[0]); // 计算字间互信息矩阵 if (context.preState() == CN)&#123; matrix(context,preChar,list[0]); &#125; context.state(START); context.preState(CN); preChar = list[0]; return true; &#125; &#125;, EN&#123; @Override public boolean process(Context context) &#123; context.buffer().reset();//恢复 //处理英文 byte[] test = new byte[1];//英文只要读1个字符 context.buffer().get(test); char[] list = new String(test).toCharArray(); //FIXME 这里不处理英文单词 context.state(START); context.preState(EN); return true; &#125; &#125;, END&#123; @Override public boolean process(Context context) &#123; System.out.println("end"); return false; &#125; &#125;; public void indexOf(Context context,char i)&#123; //这里不能存中文的标点符号 Character.UnicodeBlock ub = Character.UnicodeBlock.of(i); if (ub == CJK_SYMBOLS_AND_PUNCTUATION || ub == CJK_COMPATIBILITY_IDEOGRAPHS || ub == CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A || ub == HALFWIDTH_AND_FULLWIDTH_FORMS || ub == CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B)&#123; return; &#125; Long hit = context.index().get(i); if (hit ==null)&#123; context.index().put(i,0L); if (context.indexList().indexOf(i)&lt;0) context.addIndex(i); &#125;else &#123; context.index().put(i,hit+1); &#125; &#125; public static char preChar; //todo 记录一个词后出现另外一个词 // 这里使用的汉字个数是 3500到4000那么使用 public void matrix(Context context,char pre,char next)&#123; //index list Integer x = context.indexList().indexOf(pre); Integer y = context.indexList().indexOf(next); //这里跳过没有收录的字段 if(x&lt;0 || y&lt;0)&#123; return; &#125; //决定了使用链表吧！反正是稀松矩阵嘞 context.matrix().inc(x,y); &#125;&#125; 怎么样有点懵？关于全部的代码可以看这里传送门. 后记现在只实现了学习到文件的过程还是没有实现分析的过程。为什么不写了呢？因为再写也没有比我以前更优秀的内容了。就是没有写的必要了。这两年来，在语言的使用上有了进步会使用写一些骚操作，可以更快更加高效的完成代码。可是对于分词的方法上的认知上没有一点点的进步！在写完这篇文章之时，笔者感到了深深的焦虑。 我将一直迷惑和无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全]]></title>
    <url>%2F2018%2F05%2F09%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[线程安全性“共享” 意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化 Java的主要同步机制是关键字synchronized，它提供了一种独占的加锁方式，但同步这个术语还包括volatile类型的变量、显示锁以及原子变量 如果当多个线程访问同一个可变的状态变量时没有采用适合的同步，那么程序可能出现错误，有如下三种方式可以修复此问题 不在线程之间共享变量。 将状态变量修改为不可变。 在访问状态变量时使用同步 什么是线程安全性什么是线程安全性 可以在多个线程中调用，并且在线程之间不会出现错误的交互 可以同时被多个线程调用，而调用者无需执行额外的操作 线程安全性的定义中，最核心的概念就是正确性，正确性的含义是：某个类的行为与其规范完全一致，在良好的规范中通常定义各种不变性条件来约束对象的状态，以及定义各种后验条件来描述对象操作的结果 当多个对象访问某个类时，不管运行环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何同步或协同，这个类都能表现出正确的行为，那么这个类就是线程安全的 线程安全的类中封装了必要的同步机制，因此客户端无需采用进一步的同步措施 ==无状态对象是指==： 一个对象不即不包括任何域，也不包括任何对其他类中域的引用，无状态类一定是线程安全的 原子性当我们在无状态对象中增加一个状态或发布可变对象时，如果状态未使用额外的同步机制，那么这个对象将是线程不安全的 竟态条件==概念==： 当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竟态条件，最常见的竟态条件是：先检查后执行的操作，即通过一个可能执行的观察结果来取决于下一步的动作先检查后执行的一种常见情况就是：延迟初始化 ==数据竞争==： 如果在访问共享的非final类型的域时没有采用同步来进行协同，那么就会出现数据竞争 复合操作要避免竟态条件问题，就必须在某个线程修改变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中 假设有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B执行完毕，要么完全不执行B，那么A和B对彼此来说是原子的，原子操作是指，对于访问同一个状态的所有操作（包括操作本身）来说，这个操作是一个原子方式执行的操作 示例： 1234567891011121314151617181920212223/** * @author dreamyao * @title * @date 2018/3/7 下午5:53 * @since 1.0.0 */ @ThreadSafepublic class CountingFactorizer implements Servlet &#123; private final AtomicLong count = new AtomicLong(0); public long getCount()&#123; return count.get(); &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse)&#123; BigInteger i= extracFromRequest(servletRequest); BigInteger[] factors=factor(i); count.incrementAndGet(); encodeIntoResponse(resp,factors); &#125;&#125; 在实际情况中，应尽可能地使用现有的线程安全对象（例如：AtomicLong）来管理类的状态，与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性 加锁机制示例： 1234567891011121314151617181920212223242526272829/** * @author dreamyao * @title * @date 2018/3/7 下午5:53 * @since 1.0.0 */ @NotThreadSafepublic class UnsafeCachingFactorizer implements Servlet &#123; private final AtomicReference&lt;BigInteger&gt; lastNumber = new AtomicReference&lt;&gt;(); private final AtomicReference&lt;BigInteger[]&gt; lastfactors = new AtomicReference&lt;&gt;(); @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse)&#123; BigInteger i= extracFromRequest(servletRequest); if(i.equals(lastNumber.get())) &#123; encodeIntoResponse(resp,lastFactors.get()); &#125; else &#123; BigInteger[] factors=factor(i); lastNumber.set(); lastFactors.set(factor); encodeIntoResponse(resp,factors); &#125; &#125;&#125; 该Servlet在没有足够的原子性保证的情况下对其最近计算结果进行缓存（不要这么做） 线程安全的定义要求 多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变性条件不被破坏 只有确保了这个不变条件不被破坏，上面的Servlet才正确的 当在不变条件中涉及到多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束，因此当更新某个变量时，需要在同一个原子操作中对其他变量同时进行更新 在使用原子引用的情况下，尽管对set方法的每次调用都是原子的，但仍然无法同时更新lastNumber和lastFactors，如果只修改了其中一个变量，那么在这两次修改操作之间，其他线程将发现不变形条件被破坏了 ==要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量== 内置锁Java提供了一种内置的锁机制来支持原子性（synchronize），同步代码块将介绍加锁机制以及其他同步机制的另一个重要方面：可见性，同步代码块包括以下两部分： 一个作为锁的对象引用 一个作为由这个锁保护的对象 重入当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞，然而由于内置锁时可重入的，因此如果某个线程试图获得一个由他自己持有的锁，那么这个请求就会成功 “重入”意味着获取锁的操作粒度是“线程”而不是调用，重入避免了死锁的情况 用锁来保护状态==注意==：访问共享状态的复合操作，例如命中计数器的递增操作（读取-修改-写入）或者延迟初始化（先检查后执行）都必须是原子操作以避免产生静态条件，仅仅将复合操作封装到一个同步代码块中是不够的 当类的不变性条件设计多个状态变量时，那么还有另外一个需求，在不变性条件中的每个变量都必须由同一个锁保护，因此可以在单个原子操作中访问或更新这些变量，从而确保不变条件不被破坏 多个原子操作复合为一个复合操作后复合操作就不一定是原子操作 当执行时间较长的计算或者可能无法快速完成的操作（例如：网络I/O或者控制台I/O）一定不要持有锁 加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步 对于可能被多个线程同时访问的可变状态了变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护 活跃性与性能通过缩小同步代码块的作用范围，我们很容易做到既保护并发性，同时又维护线程安全性，要确保同步代码块不要过小，并且不要将本应是原子的操作拆分到多个同步代码块中去，应该尽量不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中其他线程可以访问共享状态 对在单个变量上实现原子操作来说，原子变量是很有用的（推荐使用原子变量，例如AtomicLong等），但由于我们已经使用了同步代码块来构造原子操作，而使用两种不同的同步机制不仅会带来混乱，也不会在性能或安全上带来任何好处，因此在单个变量上实现原子操作和原子变量这两种同步机制任选其中一个就可以了 在获得锁与释放锁等操作都需要一定的性能开销，因此如果将同步代码块分解的过细，那么通常并不好，尽管这样做不会破坏原子性 通常，在简单性与性能之间存在着互相制约因素，当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性） 对象的共享Volatile变量 Volatile变量的常用使用场景 12345volatile boolean asleep;... while (!asleep)&#123; countSomeSheep(); &#125; volatile 变量通常用做某个操作完成、发生中断或者状态的标志 volatile 的语义不足以确保递增操作（count++）的原子性，除非你能确定只有一个线程对变量执行写操作（原子变量提供了：读-改-写的原子操作）并且常常用做一种更好的volatile变量 加锁机制即可以确保可见性又可以确保原子性，而volatile变量只能确保可见性 当且仅当满足一下所有条件时，才应该使用volatile变量 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。 该变量不会与其他状态变量一起纳入不变性条件中。 在访问变量时不需要加锁 发布与逸出发布==概念==：发布一个对象是指使对象能够在当前作用域之外的代码中使用例如： 将一个指向该对象的引用保存到其他代码可以访问的地方 在某个非私有的方法中返回改引用 将引用传递到其他类的方法中在许多情况中，我们要确保对象及其内部状态不被发布，但如果在发布时要确保线程安全性，则可能需要同步发布内部状态可能会破坏封装性（内部状态是指对象的域或者域中其他对象的域）并使得程序难以维持不变性条件，如果在对象构造完成之前就发布，就会破坏线程安全性 逸出当某个不应该被发布的对象被发布时，就被称为逸出 示例：发布对象最简单的方法就是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见 12345public static Set&lt;Secret&gt; knownSecrets;public void initialize() &#123; knownSecrets=new HashSet&lt;Secret&gt;();&#125; 对象逸出的几种情况： 第一种： 当发布某个对象时，可能会间接的发布其他对象，如：将Secret对象放入Set集合中时，那么同样就发布了这个对象，因为其他任何代码都可以遍历这个集合并获得Secret对象的引用 如果从非私有方法中返回一个引用，那么同样会发布返回的对象，例如： ==示例==： 12345678class UnsafeSates &#123; private String[] states = new String[] &#123; "AK","AL"&#125;; public String[] getStates() &#123; return states; &#125;&#125; 以上示例使内部的可变状态逸出（不要这么做） 第二种： 当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布，一般来说如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布 最后一种发布对象或其内部状态的机制就是发布一个内部类的实列，如： ==示例==： 1234567891011public class ThisEscape &#123; public ThisEscape(EventSource source) &#123; source.registerListener( new EventListener() &#123; public void onEvent(Event e) &#123; doSomething(e); &#125; &#125; ) &#125;&#125; 安全的对象构造过程在ThisEcape中给出了逸出的一个特殊例子，即this引用在构造函数中逸出，不要在构造函数中使用this引用逸出 如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程，如： ==示例==： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @author dreamyao * @title * @date 2018/3/7 上午9:49 * @since 1.0.0 */public class SafeListener &#123; private final EventListener listener; private SafeListener()&#123; listener=new EventListener() &#123; @Override public int hashCode() &#123; return super.hashCode(); &#125; @Override public boolean equals(Object obj) &#123; return super.equals(obj); &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; @Override public String toString() &#123; return super.toString(); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); &#125; &#125;; &#125; public static SafeListener newSafeListener(EventSource source) &#123; SafeListener safe = new SafeListener(); source.registerListener(safe.listener); return safe; &#125;&#125; 具体来说，只有当构造函数返回时，this引用才应该从线程中逸出，构造函数可以将this引用保存到某个地方，只要其他线程不会在构造函数完成之前使用它，SafeLinstener对象中就使用了这种技术 线程封闭当某个对象封闭到一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的 ==例如==：线程封闭技术最常见的应用是JDBC的Connection对象 Ad-hoc线程封闭在volatile变量上存在一种特殊的线程封闭，只有能确保只有单个线程对共享的volatile变量执行写操作，那么就可以安全的在共享的volatile变量上实现读取-修改-写入操作 由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量少用他，在可能的情况下尽量使用更强的线程封闭技术（例如：栈封闭或者ThreadLoad类） 栈封闭对于基本类型的局部变量，无论如何都不会破坏线程封闭性，由于任何方法都无法获得对基本类型的引用，因此Java语言的这种语义就确保了基本类型的局部变量始终封闭在线程内 在维持对象引用的栈封闭时，一定要多做些工作确保被引用的对象不会逸出，然而如果发布了对象的引用，那么封闭性将被破坏，并导致对象逸出 ThreadLocal类维持线程封闭性的一种更规范的方法是使用ThreadLocal，这个类能使线程的某个值与保存值的对象关联起来 ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享，ThreadLocal变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时一定要格外小心 不变性满足同步需求的另一种方法是使用不可变对象，不可变对象一定是线程安全的 不可变对象很简单，它们只有一种状态，并且该状态有构造函数来控制，如果将一个可变对象传递给不可信的代码，或者将该对象发布到不可性代码可以访问它的地方，那么就很危险—不可信代码会改变它们的状态 即使对象的所有域都是final类型，这个对象也任然是可变的，因为final类型的域中可以保存对可变对象的引用 当满足以下条件时对象才是不可变的 对象创建以后其状态就不能修改 对象的所有域都是final类型 对象是正确创建（在对象的创建期间，this引用没有逸出） 安全发布的常用模式可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时都必须使用同步 要安全的发布一个对象，对象的引用以及对象的状态都必须同时对其他线程可见，一个正确构造的对象可以通过以下方式来安全的发布 在静态初始化函数中初始化一个对象引用 将对象的引用保存到volatile类型的域或者AtomicReference对象中 将对象的引用保存到某个正确构造对象的final类型域中 将对象的引用保存到一个由锁保护的域中 事实不可变对象如果对象从技术上看是可变的，但其状态在发布后不会再改变，那么把这种对象称为事实不可变对象，在没有任何额外同步的情况下，任何线程都可以安全的使用被安全发布的事实不可以对象 ==例如==： Spring初始化单例Bean时初始化的值如果在后续没有被修改那么也是事实不可变的 非final私有域在定义时被赋值，后续为对值进行修改时也是事实不可变的 可变对象对象的发布需求取决于他的可变性 不可变对象可以通过任意机制来发布 事实不可变对象必须通过安全的方式来发布 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来 在并发程序中使用共享对象时可以使用一些使用的策略，包括 ==线程封闭== 线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改 ==只读共享== 在没有额外同步情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它，共享的只读对象包括不可变对象和事实不可变对象 ==线程安全共享== 线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口进行访问而不需要进一步的同步 ==保护对象== 被保护的对象只能通过持有特定的锁来访问，保护的对象包括封装在其他线程安全的对象中的对象，以及已发布的并且有某个由某个特定锁保护的对象 对象的组合设计线程安全的类在设计线程安全类的过程中，需要包括以下三个基本条件 找出构成对象状态的所有变量 找出约束状态变量的不可变条件 建立对象状态的并发访问管理策略 要分析对象状态首先从域开始 如果对象中所有域都是基本类型的变量，那么这些域就构成了对象的全部状态，对于包含n个基本类型域的对象，其状态就是这些域构成的n元组 如果对象的域中引用了其他对象，那么该对象的状态就将包含被引用对象的所有域 同步策略同步策略规定了如何将不可变性，线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护 收集同步需求final类型的域使用的越多，就越能简化对象可能状态的分析过程（在极端的情况中，不可变对象只有唯一的状态） 当下一个对象需要依赖当前状态时，这个操作就一定是一个复合操作（例如：递增、递减操作、集合的有就删除，没有就添加等操作） 由于不可变条件以及后验条件在状态及状态转换上施加了各种约束，因此就需要额外的同步与封装，如果在某个操作中存在无效的状态转换，那么该操作必须是原子的 不能首先更新一个变量，然后释放锁并再次获得锁，然后在更新其他的变量，因为释放锁后，可能会使对象处于无效状态，如果在一个不可变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁 依赖状态的操作想要实现某个等待先验条件为真才执行的操作，一种更简单的方法是通过现有库中的类（例如：阻塞队列或者信号量）来实现依赖状态的行为 状态的所有权所有权与封装性总是互相关联的： 对象封装它拥有的状态，反之也成立，对它封装的状态拥有所有权 如果发布某个可变对象的引用，那么就不在拥有独占控制权，最多是“共享控制权” 对应从构造函数或者从方法中传递进来的对象，类通常并不拥有这些对象，除非这些方法是专门设计为转移传递进来的对象的所有权（例如：同步容器封装器的工厂方法） 容器类通常表现出一种“所有权分离”的形式，其中容器类拥有其自身的状态，而客户端代码则拥有容器中各个对象的状态（也就是拥有容器中各个对象的域的所有权） 为了防止多个线程在并发访问同一个对象时产生的互相干扰，这些对象应该要么是线程安全的，要么是事实不可变的对象，或者由锁来保护的对象 实列封闭如果某个对象不是线程安全的，那么可以通过多种技术使其在多个线程中安全地使用，你可以确保对象只由单个线程访问（线程封闭）或者通过一个锁来保护该对象的所有访问 通过将封闭机制与适合的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。 将数据封装在对象内部，可以将数据访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁 被封闭的对象一定不能超出他们既定的作用域 对象可以封闭在类的一个实列（例如：作为类的一个私有成员）中 封闭在某个作用域内（作为一个局部变量（又称为栈封闭）） 封闭在线程内（例如：在某个线程中将对象从一个方法传递到另一个方法，而不是在对该线程之间共享该对象） 实列封闭是构建线程安全类的一个最简单的方式，它还使得在锁的策略的选择上拥有了更多的灵活性 封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无需检查整个程序 Java监视器模式Java监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态 线程委托机制大多数对象都是组合对象，当从头开始构建一个类，或者将多个非线程安全的类组合为一个类时，Java监视器模式用于实现线程安全的类是非常有用的 在某些情况下，通过多个线程安全类组合而成的类是线程安全的，而在某些情况下并不是线程安全的（即如果出现复合操作多个线程安全类或者多个原子操作时，复合操作必须是原子的，即通过加锁来确保线程安全） ==例子==： 12345678910111213141516/** * @author dreamyao * @version 1.0.0 * @description * @date 2017/11/29 下午11:01 */@Immutablepublic class Point &#123; public final int x, y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536/** * @author dreamyao * @title * @date 2018/3/2 下午2:15 * @since 1.0.0 */@ThreadSafepublic class DelegatingVehicleTracker &#123; private final ConcurrentHashMap&lt;String,Point&gt; locations; private final Map&lt;String,Point&gt; unmodifiableMap; public DelegatingVehicleTracker(Map&lt;String, Point&gt; points) &#123; locations = new ConcurrentHashMap&lt;&gt;(points); unmodifiableMap = Collections.unmodifiableMap(points); &#125; public Map&lt;String,Point&gt; getLocations()&#123; return unmodifiableMap; &#125; /** * 此处发布了Point对象，但是Point对象为不可变对象，所以此处发布时线程安全的 * @param id * @return */ public Point getLocation(String id) &#123; return locations.get(id); &#125; public void setLocation(String id, int x, int y) &#123; if (locations.replace(id, new Point(x, y)) == null) &#123; throw new IllegalArgumentException("invalid vehicle name: " + id); &#125; &#125;&#125; 独立的状态变量我们可以将线程安全性委托给多个对象状态变量，只要这些变量是彼此独立的，即不在同一个方法中不是原子的操作多个状态变量 ==例子==： 123456789101112131415161718192021222324252627/** * @author dreamyao * @title * @date 2018/3/4 下午8:56 * @since 1.0.0 */public class VisualComponent &#123; private final List&lt;KeyListener&gt; keyListeners = new CopyOnWriteArrayList&lt;&gt;(); private final List&lt;MouseListener&gt; mouseListeners = new CopyOnWriteArrayList&lt;&gt;(); public void addKeyListener(KeyListener listener) &#123; keyListeners.add(listener); &#125; public void addMouseListener(MouseListener listener) &#123; mouseListeners.add(listener); &#125; public void removeKeyListener(KeyListener listener) &#123; keyListeners.remove(listener); &#125; public void removeMouseListener(MouseListener listener) &#123; mouseListeners.remove(listener); &#125;&#125; 每个链表都是线程安全的，此外由于各个状态操作之间不存在耦合关系（分开独立在操作）因此VisualComponent可以将它的线程安全性委托给keyListeners、mouseListeners两个对象，故VisualComponent是线程安全的 当委托失效时==例子==： 1234567891011121314151617181920212223242526272829303132333435363738/** * @author dreamyao * @title * @date 2018/3/4 下午9:03 * @since 1.0.0 */public class NumberRange &#123; /** * 不变性条件：lower &lt;= upper */ private final AtomicInteger lower = new AtomicInteger(0); private final AtomicInteger upper = new AtomicInteger(0); /** * 虽然lower和upper都是原子操作，但是在serLower中为复合操作，但setLower不是原子操作（没进行加锁）所有setLower不是线程安全的 * @param i */ public void setLower(int i) &#123; // 注意--不安全的“先检查后执行” if (i &gt; upper.get()) &#123; throw new IllegalArgumentException("can't set lower to " + i + " &gt; upper"); &#125; lower.set(i); &#125; /** * 虽然lower和upper都是原子操作，但是在setUpper中为复合操作，但setUpper不是原子操作（没进行加锁）所有setUpper不是线程安全的 * @param i */ public void setUpper(int i) &#123; // 注意--不安全的“先检查后执行” if (i &lt; lower.get()) &#123; throw new IllegalArgumentException("can't set upper to " + i + " &gt; lower"); &#125; upper.set(i); &#125;&#125; NumberRange可以通过加锁机制来维护不变性条件以确保线程安全，例如：使用一个锁来保护lower和upper，此外还必须避免发布lower和upper，从而防止客户端代码破坏其不变形条件 如果某个对象含有复合操作，例如：NumberRange ，那么仅靠委托不足以实现线程安全性，在这种情况下，这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。 如果一个类由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量 ==构造线程安全类时采用的一些技术，例如：将线程安全性委托给现有的线程安全类，委托是创建线程安全类的一个最有效的策略，只需让现有的线程安全类管理所有的状态即可== 发布底层的状态变量发布可变的变量将对下一步的开发和派生子类带来限制，但不会破坏类的线程安全性 如果一个状态变量是线程安全的，并且没有任何不变形条件约束他的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量 ==示例== 12345678910111213141516171819202122232425262728293031323334/** * @author dreamyao * @title * @date 2018/3/6 下午9:28 * @since 1.0.0 */@ThreadSafepublic class SafePoint &#123; @GuardedBy("this") private int x, y; private SafePoint(int[] a) &#123; this(a[0], a[1]); &#125; public SafePoint(SafePoint p) &#123; this(p.get()); &#125; public SafePoint(int x, int y) &#123; this.x = x; this.y = y; &#125; public synchronized int[] get()&#123; return new int[]&#123;x, y&#125;; &#125; public synchronized void set(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435/** * @author dreamyao * @title * @date 2018/3/6 下午9:32 * @since 1.0.0 */public class PublishingVehiceTracher &#123; private final Map&lt;String,SafePoint&gt; locations; private final Map&lt;String,SafePoint&gt; unmodifiableMap; public PublishingVehiceTracher(Map&lt;String, SafePoint&gt; locations) &#123; this.locations = new ConcurrentHashMap&lt;&gt;(locations); this.unmodifiableMap = Collections.unmodifiableMap(this.locations); &#125; public Map&lt;String,SafePoint&gt; getLocations()&#123; return unmodifiableMap; &#125; /** * 此处发布了Point对象，但是Point对象为不可变对象，所以此处发布时线程安全的 * @param id * @return */ public SafePoint getLocation(String id) &#123; return locations.get(id); &#125; public void setLocation(String id, int x, int y) &#123; if (locations.replace(id, new SafePoint(x, y)) == null) &#123; throw new IllegalArgumentException("invalid vehicle name: " + id); &#125; &#125;&#125; SafePoint虽然为可变对象，但是是线程安全的对象，故getLocations()或getLocation()在发布SafePoint对象时是线程安全的 getLocation() 方法返回底层Map对象的一个不可变副本，调用者不能增加或删除车辆，但却可以通过修改返回Map中的SafePoint值来改变车辆的位置如果需要对车辆位置的变化进行判断或者当位置变化时执行一些操作，那么PublishingVehiceTracher中采用的方法并不合适 在现有的线程安全类中添加功能Java类库包含了很多有用的基础模块类，我们应该优先选择重用这些现有的类而不是创建新的类，有时候，某个现有的线程安全类能支持我们需要的所有操作，但是更多的时候，现有的类只能支持大部分操作，此时就需要在不破坏线程安全的情况下添加一个新的操作 若没有则添加的概念很简单，但是由于这个类必须是线程安全的，因此就隐含地增加了另一个需求，即若没有则添加，这个操作必须是原子操作 ==示例== 1234567891011121314151617/** * @author dreamyao * @title * @date 2018/3/6 下午10:01 * @since 1.0.0 */@ThreadSafepublic class BetterVector&lt;E&gt; extends Vector&lt;E&gt; &#123; public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !contains(x); if (absent) &#123; add(x); &#125; return absent; &#125;&#125; 在现有的线程安全类中添加功能有如下策略： 第一种策略： 要添加一个新的原子操作，最安全的方法是修改原始的类，但这通常无法做到因为可能无法访问或修改类的源代码 第二种策略： 另一种方法是扩展这个类，扩展方法比直接将代码添加到类中更加脆弱，因为现在的同步策略实现被分布到多个单独维护的源码文件中，如果底层的类改变了同步策略并选择了不同的锁来保护它的状态变量，那么子类会被破坏，因为在同步策略改变后它无法再使用正确的锁来控制对基类状态的并发访问（在Vector的规范中定义了它的同步策略，因此BetterVector不存在这个问题） 客户端加锁机制第三种策略： 第三种策略是扩展类的功能，但并不是扩展类本身，而是将扩展代码放入一个“辅助类”中如下示例实现了：若没有则添加操作的辅助类 非线程安全的 12345678910111213141516171819/** * @author dreamyao * @title * @date 2018/3/6 下午10:14 * @since 1.0.0 */@NotThreadSafepublic class ListHelper&lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !list.contains(x); if (absent) &#123; list.add(x); &#125; return absent; &#125;&#125; 以上示例问题在于：无论List使用哪个锁来保护它的状态，可以确定的是，这个锁并不是ListHelper上的锁，ListHelper只是带来了同步的假象，尽管所有的链表被声明为synchronized，但却使用了不同的锁，这意味着putIfAbsent相当于List的其他操作来说并不是原子的，因此就无法确定当putIfAbsent执行时另一个线程不会修改链表 线程安全的 123456789101112131415161718192021/** * @author dreamyao * @title * @date 2018/3/6 下午10:14 * @since 1.0.0 */@ThreadSafepublic class ListHelper&lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); public synchronized boolean putIfAbsent(E x) &#123; synchronized (list) &#123; boolean absent = !list.contains(x); if (absent) &#123; list.add(x); &#125; return absent; &#125; &#125;&#125; 以上示例：List在实现客户端加锁或外部加锁时使用同一个锁，客户端加锁是指，对于使用某个对象X的客户端代码，使用X本身用于保护其状态的锁来保护这段客户端代码，要使用客户端加锁，就必须知道对象X使用的是一个锁 客户端加锁机制与扩展机制有许多共同点，二者都是派生类的行为与基类的实列耦合在一起，正如扩展会破坏实现的封装性，客户端加锁同样会破坏同步策略的封装性 组合第四种策略： 当为现有的类添加原子操作时有更好的方式：组合 ==示例==： 12345678910111213141516171819202122232425262728/** * @author dreamyao * @title * @date 2018/3/6 下午10:32 * @since 1.0.0 */public class ImprovedList&lt;T&gt; implements List&lt;T&gt; &#123; private final List&lt;T&gt; list; public ImprovedList(List&lt;T&gt; list) &#123; this.list = list; &#125; public synchronized boolean punIfAbsent(T x) &#123; boolean contains = list.contains(x); if (contains) &#123; list.add(x); &#125; return !contains; &#125; public synchronized void clear()&#123; list.clear(); &#125; // 按照类似的方式委托List的其他方法&#125; ImprovedList通过自身的内置锁增加了一层额外的加锁，它并不关心底层的List是否为线程安全的，即使List不是线程安全的或者修改了他的加锁实现，ImprovedList也会提供一致的加锁机制来实现线程安全，虽然额外的同步层可能导致轻微的性能损失，但是性能损失是很小的因为底层List上的同步不存在竞争，所有速度会很快。 将同步策略文档化在设计同步策略时需要考虑多个方面 将那些变量声明为volatile类型 将那些变量用锁来保护 将那些锁用来保护那些变量 那些变量必须是不可变的或者被封闭在线程中 那些操作必须是原子的 构建基础模块同步容器类同步容器类包括：Vector、Hashtable等等,这些同步的封装器类时由Collections.synchronizedXxx等工厂方法创建的，这些类实现线程安全的方式是：将他们的状态封装起来，并对没一个公有的方法都进行同步，使得没一次只有一个线程能访问容器的状态 同步容器类的问题同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作，容器上的复合操作包括： 迭代（反复访问元素，直到遍历完容器中的所有元素） 跳转（根据指定顺序找到当前元素的下一个元素） 条件运算（“若没有则添加”检查在Map中是否存在键值K，如果没有，就加入二元组K，V） 同步容器类中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但当其他线程并发的修改容器时，他们可能会表现出意料之外的行为 示例： 123456789public static Object getLast(Vector list) &#123; int lastIndex=list.size() - 1; retrun list.get(lastIndex);&#125;public static void deleteLast(Vector list) &#123; int lastIndex=list.size() - 1; return list.remove(lastIndex);&#125; 以上示例Vector上可能导致混乱结果的复合操作，当多好线程交替调用getLast(),deleteLast()方法时，getLast将抛出异常，因为在调用size与调用getLast()这两个操作之间，Vector变小了，因此在调用size时得到的索引值将不在有效 由于同步容器类要遵守同步策略，即支持客户端加锁，因此可能会创建一些新的操作，只要我们知道应该使用哪一个锁，那么这些新操作就与容器的其他操作一样都是原子操作 12345678910111213public static Object getLast(Vector list) &#123; synchronize(list) &#123; int lastIndex=list.size() - 1; retrun list.get(lastIndex); &#125;&#125;public static void deleteLast(Vector list) &#123; synchronize(list) &#123; int lastIndex=list.size() - 1; return list.remove(lastIndex); &#125;&#125; 使用客户端加锁的Vector上的复合操作 迭代器与ConcurrentModificationException现代的同步容器类也并没有消除复合操作中的问题即使不存在死锁或饥饿等风险，长时间地对容器加锁也会降低程序的可伸缩性，那么将极大的降低吞吐量和CPU的利用率 如果不希望在迭代期间对容器加锁，那么有一种替代方法就是克隆容器，并在副本上进行迭代操作，由于副本被封闭在线程内，因此其他线程不会在迭代期间对其进行修改，这样就避免了抛出ConcurrentModificationException（在克隆过程中任然需要对容器加锁）在克隆容器时存在显著的性能开销，这种方式的好坏取决于多个因素，包括容器的大小，在每个元素上执行的工作，迭代操作相对于容器其他操作的调用频率，以及在响应时间和吞吐量等方面的需求 隐藏迭代器虽然加锁可以防止迭代器抛出ConcurrentModificationException，但你必须记住在所有对共享容器进行迭代的地方都需要加锁，实际情况要更加复杂，因为某些情况下，迭代器会隐藏起来 示例： 12345678910111213141516171819202122232425262728/** * @author dreamyao * @title * @date 2018/3/7 下午8:44 * @since 1.0.0 */public class HiddenIterator &#123; @GuardedBy("this") private final Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); public synchronized void add(Integer i) &#123; set.add(i); &#125; public synchronized void remove(Integer i) &#123; set.remove(i); &#125; public void addTenThings()&#123; Random random = new Random(47); for (int i = 0; i &lt; 10; i++) &#123; add(random.nextInt()); &#125; // 隐藏在字符串连接中的迭代操作 System.out.println("DEBUG: added ten elements to " + set); &#125;&#125; 隐藏在字符串连接中的迭代操作（不用这么）addThenThings方法会抛出ConcurrentModificationException，因为在生成调试信息的过程中，toSting方法对容器进行了迭代操作，当然，真正的问题在于HiddenIterator不是线程安全的，在使用println中的set之前必须首先要获得HiddenIterator的锁，但在调试代码和日志代码中通常或忽视这个问题。 如果HiddenIterator用synchronizeSet来包装HashSet，并且对同步代码进行封装，那么就不会发生这种错误。 正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略 容器的hashCode和equals等方法也会间接的执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况，同样containsAll、removeAll、retainAll等方法，以及把容器作为参数的构造函数，都会对容器进行迭代，所有这些间接的迭代操作都可能抛出ConcurrentModificationException 并发容器Java5.0提供了多种并发容器来改进同步容器的性能，同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性，这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重减低 并发容器是针对多个线程并发访问设计的，在Java5.0中增加了ConcurrentHashMap,用来代替同步且基于散列的Map，以及CopyOnWriteArrayList，用于在遍历操作为主要操作情况下代替同步的List，在新的ConcurrentMap接口中增加了对一些常用复合操作的支持，例如：“若没有则添加”、替换以及有条件删除等 ==通过并发容器来代替同步容器，可以极大地提高伸缩性并降低分析== Java5.0增加了两种新的容器，Queue和BlockingQueue,Queue用来临时保存一组等待处理的元素 Java6.0也引入了ConcurrentSkipListMap和ConcurrentSkipListSet,分别作为同步的SortedMap和SortedSet的并发替代品（例如:用synchronizeMap包装的TreeMap或TreeSet） ConcurrentHasMapConcurrentHasMap与HashMap一样也是基于散列的Map，但它使用了一种完全不一样的加锁方式，ConcurrentHasMap使用了一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁 ConcurrentHasMap与其他并发容器一起增强了同步容器类，它们提供的迭代器不会抛出ConcurrentModificationException，因此不需要在迭代过程中对容器加锁 ConcurrentHasMap返回的迭代器具有若一致性，而非及时失败，弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会变量已有的元素，并可以（但不保证）在迭代器被构造后将修改操作反应给容器 只有当应用程序需要加锁 Map以进行独占访问或需要需要依赖同步Map带来的一些作用时，才应该放弃使用ConcurrentHasMap。 额外的原子Map操作由于ConcurrentHasMap不能被加锁来执行独占访问，因此我们无法使用客户端加锁来创建新的原子操作 CopyOnWriteArrayListCopyOnWriteArrayList用于替代同步List，在某些情况下他提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制（类似地CopyOnWriteArraySet的作用是替代同步的Set） 写入时复制（Copy-On-Write）容器的线程安全在于，只要正确地发布一个事实不可变的对象，那么在访问该对象时就不需要进一步的同步 写入是复制容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素与迭代器创建时的元素完全一致，而不必考虑之后修改操作所带来的影响 虽然，==每当修改容器时都会复制底层数组，这需要一定的开销，特别是当容器的规模比较大时，仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器== 阻塞队列和生产者-消费者模式阻塞队列提供了可阻塞的put（存入元素）和take（消费元素），以及支持定时的offer和poll方法，队列可以是有界的和无界的，无界队列永远都不会充满，因此无界队列上的put方法永远不会阻塞 阻塞队列支持生产者-消费者设计模式，该模式将“找出需要完成的工作”与“执行工作”这两个过程分离开来，并把工作放入一个待完成列表中以便在随后处理，而不是找出后马上处理 在基于阻塞队列构建的生产者-消费者设计中，生产者不需要知道消费者的标识与数量，或者他们是不是唯一的生产者，而只需要把数据放入即可，同样消费者也不需要知道生产者是谁，或者工作来自何处，BlockingQueue简化了生产者-消费者设计的实现过程，它支持任意数量的生产者和消费者 一种最常见的生产者-消费者设计模式就是线程池与工作队列的组合，在Executor任务执行框架中就体现了这种模式 生产者和消费者的角色是相对的，某种环境中消费者在另一种不通的环境中可能会成为生产者 在构建搞可靠的应用程序时，有界队列是一种强大的资源管理器，它们能抑制并防止生产者过多的工作项，使应用程序在负荷过载的情况下变得更加健壮 示例：桌面搜索有一种类型的程序适合被分解为生产者和消费者，例如：代理程序 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author dreamyao * @title * @date 2018/3/8 下午2:28 * @since 1.0.0 */public class FileCrawler implements Runnable &#123; private final BlockingDeque&lt;File&gt; fileQueue; private final FileFilter fileFilter; private final File root; public FileCrawler()&#123; fileQueue = new LinkedBlockingDeque&lt;&gt;(10); fileFilter = new AgeFileFilter(10); root = new File(""); &#125; private void crawl(File root) throws InterruptedException &#123; File[] entries = root.listFiles(fileFilter); if (entries != null) &#123; for (File file : entries) &#123; if (file.isDirectory()) &#123; crawl(file); &#125; else if (!alredyIndxed(file)) &#123; fileQueue.put(file); &#125; &#125; &#125; &#125; @Override public void run() &#123; try &#123; crawl(root); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; &#125;&#125; 123456789101112131415161718192021222324/** * @author dreamyao * @title * @date 2018/3/8 下午3:36 * @since 1.0.0 */public class Indexer implements Runnable &#123; private final BlockingDeque&lt;File&gt; queue; public Indexer(BlockingDeque&lt;File&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; while (true) &#123; try &#123; indexFile(queue.take()); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; &#125; &#125;&#125; 以上示例为桌面搜索应用程序中的生产者和消费者任务 生产者-消费者设计模式，分离了生产者和消费者，比将所有代码放到一起可读性和重用写更高，并且带来了许多性能优势，生产者-消费者模式可以并发执行，如果一个是I/O密集型，另一个是CPU密集型，那么并发执行的吞吐率要高于串行执行的吞吐率 串行线程封闭 对于可变对象，生产者-消费者这种设计与阻塞队列一起，促进了串行线程的封闭，从而将对象所有权从生产者交付给消费者。线程封闭对象只能由单个线程拥有，但可以通过安全地发布该对象来转移所有权。在转移所有权后，也只有另一个线程能够获得这个对象的访问权限，并且发布对象不会在访问它。这种安全的发布确保了对象状态对应新的所有者来说是可见的，并且由于最初的所有者不会在访问它，因此对象将被封闭在新的线程中。新的所有者可以对该对象做任意的修改，因为它具有独占的访问权 对象利用了串行线程封闭，将对象“借给”一个请求线程，只要对象池包含足够的内部同步来安全的发布池中的对象，并且只要客户端代码本身不会发布池中的对象，或者在将对象返回给对象池后就不在使用它，那么久可以安全的在线程之间传递所有权 我们也可以使用其他发布机制来传递可变对象的所有权，但必须确保只有一个线程能接受被转移的对象，阻塞队列简化了这项工作，除此之外，还可以通过ConcurrentMap的原子方法remove或者AtomicReference的原子方法compareAndSet来完成这项工作 双端队列与工作窃取Deque和BlockingDeque分别对Queue和BlockingQueue进行了扩展，Deque是一个双端队列，实现了在队列头和尾的高效插入和移除 双端队列适用于工作窃取设计模式，即如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者的双端队列末尾窃取工作，窃取工作的模式比传统的生产者-消费者模式具有更高的可伸缩性 工作窃取非常适合用于即是消费者也是生产者问题 阻塞方法与中断方法线程可能会阻塞或暂停执行，原因有多种 等待I/O操作结束 等待获得一个锁 等待从Thread.sleep方法中醒来 等待另一个线程的计算结果当线程阻塞时，它通常会被挂起并处于阻塞状态（BLOCKED、WAITING、TIMED_WAITING） BlockingQueue的put和take等方法会抛出受检异常InterrutedException，这与类库中的其他方法的做法相同，列如Thread.sleep，当某个方法抛出InterrutedException时表示该方法是一个阻塞方法，如果这个方法被中断，那么他将努力提前结束阻塞状态 Thread提供了interrupt方法用于中断线程或者查询线程是否已经被中断 中断是一种协作机制，一个线程不能强制其他线程停止正在执行的操作而去执行其他操作 ==传递InterrutedException== 避开这个异常通常是最明智的策略，只需要把InterrutedException传递给方法调用者，传递InterrutedException的方法是，根本不捕获这个异常或者捕获了在执行简单的清理工作后再次抛出 ==恢复中断== 有时候不能抛出InterrutedException，例如当代码在Runnable的一部分时，在这些情况下，必须捕获InterrutedException，并通过调用当前线程的interrupt方法恢复中断状态，这样调用栈中更高层的代码将看到引发了一个中断 示例 123456789101112public class TaskRunnable implements Runnable &#123; BlockingQueue&lt;Task&gt; queue; .... public void run() &#123; try &#123; processTask(queue,take()); &#125; catch(InterrutedException e) &#123; // 恢复被中断的状态 Thread.currentThread().interrup(); &#125; &#125;&#125; 同步工具类在容器类中，阻塞队列是一直独特的类，他们不仅仅能作为保存对象的容器，还是协同调生产者-消费者等待线程之间的控制流 同步工具类可以是任何一个对象，只有他根据其自身的状态协调线程的控制流 阻塞队列可以作为同步工具类，其他类型的同步工具类还包括信号量（Semaphore）、栅栏（Barrier）以及闭锁（Latch） 所有的同步工具类都包含一些特殊的结构化属性，他们封装了一些状态，这状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效地等待同步工具类进入预期状态 闭锁闭锁是一种同步工具类，可以延迟线程的进度直到到达终止状态 闭锁可以用来确保某些活动直到其他活动都完成后才继续执行 确保某个计算在其需要的所有资源都被初始化之后才继续执行 确保某个服务在其他依赖的所有服务已经启动之后才执行 等待直到某个操作的所有参与者都就绪在继续执行（例如：性能测试中的集合点） CountDownLatch是一种灵活的闭锁实现，可以在上述各种情况中使用，闭锁状态包括一个计数器，该计数器初始化一个正数，表示需要等待的事件数量，countDown方法递减计数器，表示一个事件已经就绪了，如果计数器的值为非零那么await会一直阻塞计数器直到计数器为零为止，或者等待中的线程中断或者等待超时 123456789101112131415161718192021222324252627282930313233/** * @author dreamyao * @title * @date 2018/3/9 下午1:30 * @since 1.0.0 */public class TestHarness &#123; public long timeTasks(int nxThreads, final Runnable task) throws InterruptedException &#123; final CountDownLatch startGate = new CountDownLatch(nxThreads); final CountDownLatch endGate = new CountDownLatch(nxThreads); for (int i = 0; i &lt; nxThreads; i++) &#123; Thread t = new Thread(() -&gt; &#123; try &#123; startGate.await(); try &#123; task.run(); &#125; finally &#123; endGate.countDown(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); t.start(); &#125; long start = System.nanoTime(); startGate.countDown(); endGate.await(); long end = System.nanoTime(); return end - start; &#125;&#125; 在计时测试中使用CountDownLatch来启动和停止线程 FutureTaskFutureTask也可以实现闭锁（FutureTask实现了Future语义）表示一种抽象的可生成结果的计算，Future表示的计算是通过Callable来实现的，相当于一种可生成结果的Runnable，并且可以处于以下3种状态：等待运行、正在运行、运行完成 FutureTask在Excutor框架中表示异步任务，此外还可以表示一些时间比较长的计算，这些计算可以在使用计算结果之前启动 ==示例== 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @author dreamyao * @title * @date 2018/3/9 下午1:48 * @since 1.0.0 */public class Preloader &#123; private final FutureTask&lt;ProductInfo&gt; future = new FutureTask&lt;&gt; (new Callable&lt;ProductInfo&gt; &#123; public ProductInfo call() throws DataLoadException &#123; return loadProductInfo(); &#125; &#125;); private final Thread thread =new Thread(future); public void start() &#123; thread.start(); &#125; public ProductInfo get() throws DataLoadException, InterruptedException &#123; try &#123; return future.get(); &#125; catch (ExcutionException e) &#123; Throwable cause = e.getCause(); if (cause instanceof DataLoadException) &#123; throw (DataLoadException) cause; &#125;else &#123; throw launderThrowable(cause); &#125; &#125; public static RuntimeException launderThrowable(Throwable t) &#123; if (t instanceof RuntimeException) &#123; return (RuntimeException) t; &#125;else if (t instanceof Error) &#123; throw (Error) t; &#125;else &#123; throw new IllegalStateException("Not unchecked", t); &#125; &#125; &#125;&#125; 信号量计数信号量用例控制同步访问某个特定资源的操作数量，或者执行某个指定操作的数量，计数器信号量还可以用来实现某种资源池，或者对容器施加边界 Semaphore中管理着一组虚拟的许可，许可的初始数量可通过构造函数来指定，在实现操作时可以首先获得许可（只要还有剩余许可）并在使用后释放许可，如果没有许可，那么acquire方法将阻塞直到有许可为止（或者直到被中断或等待超时），release方法将返回一个许可（即释放占用的许可）给信号量 ==在这种实现中不包含真正的许可对象，并且Semaphore也不会将许可与线程关联起来，因此在一个线程中获得的许可可以在另外一个线程释放，可以将acquire方法视为是消费一个许可，而release方法是创建一个许可，Semaphore并不受限于它在创建时的初始许可数量== ==示例== 123456789101112131415161718192021222324252627282930313233343536373839/** * @author dreamyao * @title * @date 2018/3/9 下午2:18 * @since 1.0.0 */@Immutablepublic class BoundedHashSet&lt;T&gt; &#123; private final Set&lt;T&gt; set; private final Semaphore semaphore; public BoundedHashSet(int bound) &#123; this.set = Collections.synchronizedSet(new HashSet&lt;&gt;()); this.semaphore = new Semaphore(bound); &#125; public boolean add(T o) throws InterruptedException &#123; // 获取许可 semaphore.acquire(); boolean wasAdded = false; try &#123; wasAdded = set.add(o); return wasAdded; &#125;finally &#123; if (!wasAdded) &#123; semaphore.release(); &#125; &#125; &#125; public boolean remove(T o) &#123; boolean wasRemoved = set.remove(o); if (wasRemoved) &#123; semaphore.release(); &#125; return wasRemoved; &#125;&#125; 栅栏栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生，栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行，闭锁用于等待事件，而栅栏用与等待其他线程 CyclicBarrier可以使一定数量的参与方式反复地在栅栏位置汇聚，它在并行迭代算法中非常有用，这种算法通常将一个问题拆分成一系列相互独立的子问题，当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程都要到达栅栏位置，如果所有的线程达到了栅栏位置，那么栅栏将打开，如果对await的调用超时或者await阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await调用都将终止并抛出BrokenBarrierException。 另外一种形式的栅栏式Exchanger，它是一种两方栅栏，各方在栅栏位置上交换数据，当两方的执行不对称的操作时，Exchanger非常有用，例如：当一个线程向缓冲区中写数据时，而另外一个线程从缓冲区读数据 ==当两个线程通过Exchanger交换对象时，这种交换就把这两个对象安全的发布给另一方== 构建高效且可伸缩的结果缓存简单的缓存可能会将性能瓶颈转变成可伸缩性瓶颈，即使缓存是用于单线程的性能 示例 123456789/** * @author dreamyao * @title * @date 2018/3/9 下午4:14 * @since 1.0.0 */public interface Computable&lt;A,V&gt; &#123; V compute(A arg) throws InterruptedException;&#125; 12345678910111213/** * @author dreamyao * @title * @date 2018/3/9 下午4:15 * @since 1.0.0 */public class ExpensiveFuntion implements Computable&lt;String,BigInteger&gt; &#123; @Override public BigInteger compute(String arg) throws InterruptedException &#123; // 经过很长的计算 return new BigInteger(arg); &#125;&#125; 123456789101112131415161718192021222324252627/** * @author dreamyao * @title * @date 2018/3/9 下午4:17 * @since 1.0.0 */@ThreadSafepublic class Memoizer1&lt;A,V&gt; implements Computable&lt;A,V&gt; &#123; @GuardedBy("this") private final Map&lt;A, V&gt; cache = new HashMap&lt;&gt;(); private final Computable&lt;A, V&gt; computable; public Memoizer1(Computable&lt;A, V&gt; computable) &#123; this.computable = computable; &#125; @Override public synchronized V compute(A arg) throws InterruptedException &#123; V result = cache.get(arg); if (result == null) &#123; result = computable.compute(arg); cache.put(arg, result); &#125; return result; &#125;&#125; HashMap不是线程安全的，因此确保不会被同时访问HashMap，Memoizer1采用了一种保守的方法，即对整个compute方法加锁，这边方法确保了线程安全性，但会带来可伸缩性问题，每次只能一个线程执行compute方法 1234567891011121314151617181920212223242526/** * @author dreamyao * @title * @date 2018/3/9 下午4:20 * @since 1.0.0 */@ThreadSafepublic class Memoizer2&lt;A,V&gt; implements Computable&lt;A,V&gt; &#123; private final Map&lt;A, V&gt; cache = new ConcurrentHashMap&lt;&gt;(); private final Computable&lt;A, V&gt; computable; public Memoizer2(Computable&lt;A, V&gt; computable) &#123; this.computable = computable; &#125; @Override public V compute(A arg) throws InterruptedException &#123; V result = cache.get(arg); if (result == null) &#123; result = computable.compute(arg); cache.put(arg, result); &#125; return result; &#125;&#125; Memoizer2的问题在于，如果某个线程启动了一个开销很大的计算，而其他线程不知道这个计算正在进行，那么很可能会出现重复计算的情况 12345678910111213141516171819202122232425262728293031323334/** * @author dreamyao * @title * @date 2018/3/9 下午4:21 * @since 1.0.0 */@ThreadSafepublic class Memoizer3&lt;A,V&gt; implements Computable&lt;A,V&gt; &#123; private final Map&lt;A, Future&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private final Computable&lt;A, V&gt; computable; public Memoizer3(Computable&lt;A, V&gt; computable) &#123; this.computable = computable; &#125; @Override public V compute(final A arg) throws InterruptedException &#123; Future&lt;V&gt; future = cache.get(arg); if (future == null) &#123; Callable&lt;V&gt; eval= () -&gt; computable.compute(arg); FutureTask&lt;V&gt; futureTask = new FutureTask&lt;&gt;(eval); future = futureTask; cache.put(arg, futureTask); futureTask.run(); &#125; try &#123; return future.get(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; Memoizer3的实现几乎是完美的，他表现了出了非常高的并发性，但是它有一个缺陷，即任然存在两个线程计算出相同的结果值的漏洞，但这个漏洞发生的概率要远小于Memoizer2，由于在compute方法中的if 代码块是非原子的 “先检查后执行” 操作，因此两个线程任然有可能同时调用compute方法来计算出相同的结果，即二者都没在缓存中找到期望值 Memoizer3中存在的这个问题的原因是：复合操作（若没有则添加）是在底层的Map对象上执行的，而这个对象无法通过加锁来确保原子性 12345678910111213141516171819202122232425262728293031323334353637/** * @author dreamyao * @title * @date 2018/3/9 下午4:28 * @since 1.0.0 */@ThreadSafepublic class Memoizer&lt;A,V&gt; implements Computable&lt;A,V&gt; &#123; private final ConcurrentMap&lt;A, Future&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private final Computable&lt;A, V&gt; computable; public Memoizer(Computable&lt;A, V&gt; computable) &#123; this.computable = computable; &#125; @Override public V compute(A arg) throws InterruptedException &#123; while (true) &#123; Future&lt;V&gt; future = cache.get(arg); if (future == null) &#123; Callable&lt;V&gt; eval = () -&gt; computable.compute(arg); FutureTask&lt;V&gt; futureTask = new FutureTask&lt;&gt;(eval); cache.putIfAbsent(arg, futureTask); future = futureTask; futureTask.run(); &#125; try &#123; return future.get(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; cache.remove(arg, future); &#125; &#125; &#125;&#125; Memoizer使用了ConcurrentMap中的原子方法putIfAbsent，避免了Memoizer3的漏洞 当缓存的是Future而不是值时，将导致缓存污染问题：如果某个计算被取消或失败，那么在计算这个结果时将指明计算过程被取消或失败，为了避免这种情况，如果Memoizer发现计算被取消或失败，那么将把Future从缓存中移除 第一部分小结以下为并发技巧清单 可变状态是至关重要的，所有的并发问题都可以归结为如何协调对并发状态的访问，可变状态越少就越容易确保线程安全性 尽量将域声明为final类型，除非需要他们是可变的 不可变对象一定是线程安全的，不可变对象能极大降低并发编程的复杂性，他们更为简单而且线程安全，可以任意共享而无需使用加锁或保护性复制等机制 封装有助于管理复制性，在编写安全的程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这样做呢？将数据封装在对象中，更易于维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略 用锁来保护每个可变变量 当保护同一个不变性条件中的所有变量时，需要使用同一个锁 在执行复合操作期间，要持有锁 如果从多个线程中访问同一个可变变量时没有同步机制，那么线程会出现问题 不要故作聪明地推断出不需要使用同步 在设计过程中考虑线程安全，或者在文档中明确地指出它是不是线程安全的 将同步策略文档化 任务执行在线程中执行任务在理想状态情况下，各个任务之间是相互独立的：任务并不依赖于其他任务的状态、结果或边界效应，独立性有助于实现并发，因为如果存在足够多的处理器资源，那么这些独立的任务都可以并行执行 大多数服务应用程序提供了一种自然的任务边界选择：以独立的客户请求为边界 串行地执行任务在应用程序中可以有多种策略在调度任务，而其中一些策略能够更好地利用潜在的并发性，最简单的策略就是在单线程中串行的执行各项任务 在服务器应用程序中串行处理机制通常无法提供高吞吐率和快速响应性 显式地为任务创建线程 任务处理过程从主线程分离出来，使得主循环能够更快地重新等待下一个到来的连接，这使得程序在完成前面的请求之前可以接受新的请求，从而提高响应性 任务可以并行处理，从而能同时服务多个请求，如果有多个处理器，或者任务由某种原因被阻塞，例如：I/O完成、获取锁或者资源可用性等，程序的吞吐量将得到提高 任务处理代码必须是线程安全的，因为当有多个任务时会并发地调用这段代码 无限制创建线程的不足 线程生命周期的开销非常高 资源消耗大 稳定性差 Executor框架任务是一组逻辑工作单元，而线程则是任务异步执行的机制，串行执行的问题在于其糟糕的响应性和吞吐量，而为每个任务分配一个线程的问题在于资源管理的复杂性。 Executor基于生产者-消费者模式，提交任务的操作相当于生产者（生成待完成的工作单元），执行任务的线程相当于消费者（执行完这些工作单元），如果想要在程序中实现一个生产者-消费者的设计，那么最简单的方式通常就是使用Executor ==示例== : 基于线程池的Web服务 123456789101112131415161718192021222324/** * @author dreamyao * @title 基于线程池的Web服务 * @date 2018/3/12 下午12:57 * @since 1.0.0 */public class TaskExecutionWebServer &#123; private static final int NTHREADS = 100; private static final Executor exec = Executors.newFixedThreadPool(NTHREADS); public static void main(String[] args) throws IOException &#123; ServerSocket socket = new ServerSocket(80); for (;;) &#123; final Socket connect = socket.accept(); Runnable runnable = () -&gt; handleRequest(connect); exec.execute(runnable); &#125; &#125; private static void handleRequest(Socket connect) &#123; &#125;&#125; 改变Executor实现或配置所带来的影响远远小于改变任务提交方式带来的影响，通常Eexcutor的配置是一次性的，因此在部署阶段可以完成，而提交任务的代码却会不断地扩散到整个程序中，增加了修改的难度 ==示例== : 为每一个请求启动一个新线程的Executor 123456789101112/** * @author dreamyao * @title 为每一个请求启动一个新线程的Executor * @date 2018/3/12 下午1:06 * @since 1.0.0 */public class ThreadPerTaskExecutor implements Executor&#123; @Override public void execute(Runnable command) &#123; new Thread(command).start(); &#125;&#125; 执行策略 在什么线程中执行任务 任务按照什么顺序执行（FIFO、LIFO、优先级） 有多少个任务能并发执行 在队列中有多少个任务在等待执行 如果系统由于过载而需要拒绝一个任务，那么应该现在哪一个任务？另外，如何通知应用程序有任务被拒绝 在执行一个任务之前或之后，应该进行哪些动作 各种策略都是资源管理工具，最佳策略取决于可用的计算资源以及对服务质量的需求 线程池线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务，工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务 newFixedThreadPool：将创建一个固定长度的线程池 newCacheThreadPool：将创建一个可缓存的线程池，线程池不存在任何线程 newSingleThreadPool：newSingleThreadPool是一个单线程的Executor，它创建当工作者线程来执行任务，这个线程异常结束，会创建另一个线程来替代，newSingleThreadPool能确保依照任务在队列中的顺序来串行执行（例如：FIFO、LIFO、优先级）newSingleThreadPool还提供了大量的内部同步机制，从而确保了任务执行的任何内存写入操作对于后续任务来说都是可见的，这意味着，即使这个线程会不时的被另一个线程替代，但是对象总是可以安全的封闭在任务线程中 newScheduledThreadPool：创建一个固定长度的线程池，而且以延迟或者定时的方式来执行任务 ExecutorService的生命周期有3种状态：运行、关闭、已终止，ExecutorService在初始化创建时处于运行状态，shutdown方法将执行平缓的关闭过程，不在接受新的任务，同时等待已提交的任务执行完成（包括哪些还未开始执行的任务），shutdownNow方法将执行粗暴的关闭过程，它尝试取消所有运行中的任务，并且不在启动队列中尚未开始执行的任务 延迟任务与周期任务Timer类负责管理延迟任务已经周期任务，然而Timer类存在缺陷，因此应该考虑用ScheduledThreadPoolExecutor来替代它，Timer支持基于绝对时间而不是相对时间，因此任务的执行对系统时钟变化很敏感，而ScheduledThreadPoolExecutor只支持基于相对时间的调度 Timer在执行所有定时任务时只会创建一个线程，如果某个任务的执行时间过长，那么将破坏其他TimerTask的定时精确性 Timer的另一个问题是，如果TimerTask抛出一个未检查异常，那么Timer将表现出糟糕的行为，Timer线程并不捕获异常，因此当TinmerTask抛出未检查的异常时将终止定时线程，这种情况下Timer也不会恢复线程的执行，而是会错误地认为整个Timer都被取消了，因此已经被调度但尚未执行的TimerTask将不会再执行，新的任务也不能被调度（这个问题称之为线程泄漏） 如果要构建自己的调度服务，那么可以使用DelayQueue，它实现了BockingQueue，并为ScheduledThreadPoolExecutor提供了调度功能，DelayQueue管理着一组Delayed对象，每个Delayed对象都有一个相应的延迟时间，在DelayQueue中，只有某个元素逾期后，才能从DelayQueue中执行take操作，从DelayQueue中返回的对象根据他们的延迟时间进行排序 找出可利用的并行性Executor框架帮助指定执行策略，但如果要使用Executor，必须将任务表述为一个Runnable，在大多数服务器应用程序中都存在一个明显的任务边界：单个客户请求。但是有时候任务边界并非是显而易见的，例如：很多桌面应用中，即使是服务器应用程序，在单个客户请求中仍可能存在发掘的并发性，例如：数据库服务器 携带结果的任务Callable与FutureExecutor框架使用Runnable作为其基本的任务表示形式，Runnable是一种有很多局限的抽象，虽然run方法能写入到日志文件或者将结果放入某个共享数据结果中，但他不能返回或者抛出受检查异常 Runnable和Callable描述的都是抽象的计算任务，这些任务通常是有范围的，即都有一个明确的起点，并且最终会结束 Executor执行的任务有4个生命周期阶段：创建、提交、开始、完成，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能响应中断时，才能取消，取消一个已完成的任务不会产出任何影响 Future任务的生命周期只能前进，不能后退，就像ExecutorServer的生命周期一样，如果任务被取消，get方法将抛出CancellationException，如果get抛出ExecutionException，则可以通过getCause来获得被封装的初始异常 要使用Callable 来表示无返回值的任务，可以使用Callable 在异构任务并行化中存在的局限两个不同类型的任务称为异构任务，然而通过对异构任务的并行化来获得重大的性能提升是很困难的，如果没有在相似的任务之间找出细粒度的并行性，那么这种并行执行的方式带来的好处将减少。 只有大量相互独立且同构的任务可以并行进行处理时，才能提现出程序的工作负载分配到多个任务中带来的真正性能提升。 CompletionService：Executor与BlockingQueue如果向Executor提交了一组计算任务，并且希望计算完成后获得结果，那么可以保留每个任务关联的Future，然后反复使用get方法，同时将参数timeout指定为0，从而通过轮询来判断任务是否完成，这种方法虽然可行，但是却有些繁琐，幸运的是还有一种更好的方法：完成服务（CompletionService） CompletionService将Executor和BlockingQueue的功能融合在一起，可以通过将Callable的任务提交给他来执行，然后使用类似于队列操作的take和poll等方法来获得已完成的结果 示例：使用CompletionService实现页面渲染器1234567891011121314151617181920212223242526272829303132333435363738/** * @author dreamyao * @title * @date 2018/3/12 下午3:58 * @since 1.0.0 */public class Renderer &#123; private final ExecutorService executor; Renderer(ExecutorService executor) &#123; this.executor = executor; &#125; void renderPage(CharSequence source) &#123; List&lt;ImageInfo&gt; info =scanForImageInfo(source); CompletionService&lt;ImageInfo&gt; completionService = new ExecutorCompletionService&lt;&gt;(executor); for (final ImageInfo imageInfo:info)&#123; completionService.submit(new Callable&lt;ImageInfo&gt;&#123; public ImageInfo call()&#123; return imageInfo.downloadImage(); &#125; &#125;); renderText(source); try &#123; for(int t=0,n=info.size();t&lt;n;t++)&#123; Future&lt;ImageInfo&gt; f=completionService.take(); ImageInfo imageInfo=f.get(); renderImage(imageInfo); &#125; &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125;catch (ExecutionException e) &#123; throw launderThrowable(e.getCause()); &#125; &#125; &#125;&#125; 多个ExecutorCompletionService可以共享Executor，因此可以创建一个对于特定计算私有，又能共享一个公共Executor的ExecutorCompletionService。 取消与关闭要使任务和线程能够安全、快速、可靠地停下来，并不是一件容易的事情，Java没有提供任何机制来安全地停止线程，虽然Thread.stop() 和suspend()等方法提供了这样的机制，但由于存在着一些严重的缺陷，因此避免使用，但它提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。 这种协作方法是必要的，因为我们很少希望某个任务或者线程立马停止，因为这种立即停止会使共享的数据结构处于不一致的状态。 任务取消如果外部代码能在某个操作正常完成之前将其置入完成状态，那么这个操作就可以称为可取消的，取消某个操作的原因有很多，例如： 用户请求取消 ：用户显示的进行关闭，如点击取消按钮 有时间限制的操作 ： 应用程序事件 错误 关闭 在Java中没有一种安全的抢占式方法来停止线程，因此也就没有安全的抢占式方法来停止任务，只有一些协作式的机制，使请求取消的任务和代码都遵循一种友好协商的协议。 示例 ：使用volatile类型的域来保存取消状态 1234567891011121314151617181920212223242526272829303132/** * @author dreamyao * @title * @date 2018/3/14 下午8:23 * @since 1.0.0 */@ThreadSafepublic class PrimeGenerator implements Runnable &#123; @GuardedBy("this") private final List&lt;BigInteger&gt; primes = new ArrayList&lt;&gt;(); private volatile boolean cancelled; @Override public void run() &#123; BigInteger p = BigInteger.ONE; while (!cancelled) &#123; p = p.nextProbablePrime(); synchronized (this) &#123; primes.add(p); &#125; &#125; &#125; public void cancel() &#123; cancelled = true; &#125; public synchronized List&lt;BigInteger&gt; get() &#123; return new ArrayList&lt;&gt;(primes); &#125;&#125; 线程池的使用在任务与执行策略之间的隐形耦合依赖性任务 大多数行为正确的任务都是相互独立的，它们不依赖于任务任务的执行结果或者其他效果，当在线程池中执行独立的任务时，可以任意的改变线程池的大小和配置，这些修改只会对执行性能产生影响，但是提交给线程池的任务依赖其他的任务时，那么就隐含地给执行任务带来了约束，此时必须小心的维持这些执行策略以避免产生活跃性问题 使用线程封闭机制的任务 对象可以封闭在任务线程中，使得在该线程中执行的任务在访问该对象时不需要额外的同步机制，即使资源部是线程安全的也没有问题，这种情形将在任务与执行策略之间形成隐式的耦合—— 任务要求其执行所在的Executor是单线程的：这正式newSingleThreadExecutor所保证的 对响应时间敏感的任务 如果将一个运行时间较长的任务提交到单线程的Executor中，或者将多个运行时间较长的任务提交到一个包含较少线程的线程池中那么将降低由该Executor管理的服务的响应性。 使用ThreadLocal的任务 ThreadLocal使每个线程都可以拥有某个变量的一个私有版本，只有当线程本地生命周期受限于任务的生命周期时，在线程池的线程使用ThreadLocal才有意义，而在线程池的线程不应该使用ThreadLocal在任务之间传递值 在一些任务中，需要拥有或排除某种特定的执行策略，如果某些任务依赖于其他的任务，那么会要求线程池足够大，从而确保他们依赖的任务不会被放入等待队列中或被拒绝，而采用线程封闭机制的任务需要串行执行。 线程饥饿死锁在单线程的Executor中，如果一个任务将另一个任务提交到了同一个Executor，并且等待这个提交任务的结果，那么通常会引发死锁，只有线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供的资源或条件，例如：某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够的大，否则将发生线程饥饿死锁。 1234567891011121314151617181920212223/** * @author dreamyao * @title * @date 2018/3/24 下午1:05 * @since 1.0.0 */public class ThreadDeadlock &#123; ExecutorService exec = Executors.newSingleThreadExecutor(); public class RenderPageTask implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; Future&lt;String&gt; header, footer; header=exec.execute(new LoadFileTask("header.html")); footer=exec.execute(new LoadFileTask("footer.html")); String page=renderBody(); // 将发生死锁由于任务在等待子任务的结果 return header.get() + page + footer.get(); &#125; &#125;&#125; 每当提交一个有依赖性的Executor任务时，要清楚地知道可能会出现线程饥饿死锁，因此需要在代码或配置Executor的配置文件中记录线程池的大小限制或配置线程 运行时间较长的任务如果任务阻塞的时间过长，那么即使不出现死锁，线程池的响应性也好变的糟糕，如果线程池中的线程数量远小于在稳定状态下执行时间较长任务的数量，那么到最后可能所有的线程都会运行这些执行时间较长的任务，从而影响整体的响应性 有一项技术可以缓解时间较长任务造成的影响，即限定任务等待资源的时间，而不要无限制的等待，在平台类库中大多数可阻塞的方法中，都同时定义了限时版本和无限时版本，例如：Thread.join()、BlockingQueue.put()、CountDownLatch.await()以及Selector.select()等 如果线程池中总是充满了被阻塞的任务，那么也可能表明线程池的规模过小 设置线程池的大小设置线程池的大小也并不困难，只需要避免过大和过小这两种情况 想要真正的设置线程池的大小需要如下分析： 分析计算环境 分析资源预算 分析任务的特性 在部署的系统中需要多少CPU、多大内存、任务是计算密集型、I/O密集型还是二者皆可，他们是否需要像JDBC连接这样的稀缺资源，如果执行不通类别的任务，并且它们之间的行为相差很大，那么应该考虑使用多个线程池，从而使每个线程池可以根据各自的工作负载来调整 对应计算密集型任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的利用率（即使当计算密集型的线程偶尔由于页缺失故障或其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费） Nthread=Ncpu*Ucpu*(W/C) Ucpu=CPU利用率当然CPU周期并不是唯一影响线程池大小的资源，还包括，内存、文件句柄、套接字句柄和数据库连接等 配置ThreadPoolExecutorThreadPoolExecutor为一些Executor提供了基本的实现，这些Executor是由Executor中的newCachedThreadPool、newFixedThreadPool和newScheduleThreadExecutor等工厂方法返回的，ThreadPoolExecutor是一个灵活的、稳定的线程池，允许进行各种定制 如果默认的执行策略不能满足需求，那么可以通过ThreadPoolExecutor的构造函数来实列化一个对象，并根据自己的需求来定制 线程的创建与销毁线程池的基本大小、最大大小以及存活时间等因素共同负责线程的创建与销毁，基本大小也是就是线程池的目标大小，即在没有任何任务执行时线程池的大小（在创建ThreadPoolExecutor初期，线程并不会立即启动，而是等到有任务提交时才会启动，除非调用prestartAllCoreThreads）并且只有在工作队列满了的情况下才会创建超出这个数量的线程，线程池的最大大小表示同时活动的线程数量的上限，如果某个线程超出了存活时间，那么将被标记为可回收的，并且当线程池的当前大小超过了基本大小时，这个线程将被终止。 newFixedThreadPool工厂方法将线程池的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时，newCacheThreadPool工厂方法将线程池的最大大小设置为了Integer.MAX_VALUE，而将基本大小设置为0，并将超时时间设置为1分钟，这种方式创建出来的线程池可以被无限扩展，并且当需求降低时会自动收缩 开发人员以避免将线程池的基本大小设置为0，从而最终销毁工作以免阻碍JVM的退出，然而如果线程池中没有使用SynchronizeQueue作为其工作队列（例如：newCacheThreadPool中就是如此）那么这种方式将产生一些奇怪的行为，如果线程池中的线程数量等于线程池的基本大小，那么仅当在工作队列已满的情况下ThreadExecutor才会创建新的线程，因此当线程池的基本大小为0并且其工作队列有一定的容量，那么当把任务提交给线程池时，只有当线程池的工作队列被填满后，才会开始执行任务，而这种行为通常不是我们所希望的。 管理队列任务有限的线程池中会限制可并发执行的任务数量（单线程的Executor是一种值得注意的特例：他们能确保不会有任何任务并发的执行，因为他们通过线程封闭实现线程安全性） 无限制的创建线程将会导致不稳定性，可以通过固定大小的线程池来解决这个问题，但是这个方案并不完整，在高负载的情况下应用程序扔可能耗尽资源，技术请求平均达到速率很稳定，仍然会出现请求突增的情况，经管队列有助于缓解任务的突增问题，但是如果任务持续高速的到来，那么最终还是会抑制请求的到达速率以避免耗尽内存（类似于通信网络中的限流）甚至在耗尽内存前，响应性能也将随着队列任务的增长变的越来越糟糕 ThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务，基本的任务排队方法有三种： 无界队列 有界队列 同步移交 newFixedThreadPool和newSingleThreadExecutor默认情况下将使用一个无界的LinkedBlockingQueue，如果所有工作者线程处于忙碌状态，那么任务将在队列中等候，如果任务持续的快速到达，并且超过了线程池处理他们的速度，那么队列将无限制的增加 一种更为稳定的资源管理策略是使用有界队列，例如：ArrayBlockingQueue、有界的LinkedBlockingQueue、PriorityBlockingQueue，有界队列有助于避免资源耗尽的情况发生，但它又带来了新的问题，当队列满了后，新的任务改怎么处理（有许多饱和策略）可以解决这个问题，在使用有界队列时，队列的大小与线程池的大小必须一起调节，如果线程池较小而队列较大，那么有助于减少内存使用量，降低CPU的使用率，同时还可以减少上下文切换，但付出的代价可能会限制吞吐量。 对于非常大的或者无界的线程池，可以通过使用SynchronizeQueue来避免任务排队，以及直接将任务从生产者移交给工作者线程，SynchronizeQueue不是一个真正的队列，而是一种线程之间进行移交的机制，将一个元素放入SynchronizeQueue中，必须有另外一个线程正在等待接收这个元素，如果没有线程正在等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor将创建一个新的线程，否则根据饱和策略，这个任务将被拒绝 饱和策略当有界队列被填满后，饱和策略就开始发挥作用，ThreadPoolExecutor的饱和策略可以通过调用serRejectedExcutionHandler来修改（如果任务被提交到了一个已经关闭的Executor时，也会用到饱和策略）JDK提供了几种不同的RejectedExecutionExecutionHandler实现，每种实现都包含不同的饱和策略，AbortPolicy、CallerRunsPolicy、DiscarDPolicy和DiscardOldestPolicy。 中止（Abort）策略是默认的饱和策略，该策略将抛出未检查的RejectedExecutionException，调用者可以捕获这个异常，然后根据需求来编写自己的处理代码 抛弃（Discard）当新提交的任务无法保存到队列中的等待执行时，抛弃策略会悄悄的抛弃该任务。 抛弃最旧的（Discard-Oldest）抛弃最旧的测试则会抛弃下一个被执行的任务，然后尝试重新提交新的任务（如果工作队列是一个优先级队列，那么抛弃最旧的策略将导致抛弃优先级最高的任务，因此最好不要将抛弃最旧的饱和策略和优先级队列放在一起使用） 调用者运行（Caller-Runs）策略实现了一种调节机制，该策略不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量，他不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务 示例：创建一个固定大小的线程池，并采用有界队列以及调用者运行饱和策略 1234public void createThreadPool()&#123; ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 20, 60, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;(20)); executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); &#125; 当工作队列填满后，没有预定义的饱和策略来阻塞execute，然而，通过使用Semaphore来限制任务的到达率，就可以实现这个功能 示例 使用信号量来控制任务的提交速率 1234567891011121314151617181920212223242526272829303132/** * @author dreamyao * @title * @date 2018/3/29 下午1:33 * @since 1.0.0 */@ThreadSafepublic class BoundedExcutor &#123; private final Executor exec; private final Semaphore semaphore; public BoundedExcutor(Executor exec, int bound) &#123; this.exec = exec; this.semaphore = new Semaphore(bound); &#125; public void submitTask(final Runnable command) throws InterruptedException &#123; semaphore.acquire(); try &#123; exec.execute(() -&gt; &#123; try &#123; command.run(); &#125; finally &#123; semaphore.release(); &#125; &#125;); &#125; catch (RejectedExecutionException e) &#123; semaphore.release(); &#125; &#125;&#125; 线程工厂每当线程池需要创建线程时，都是通过线程工厂来完成的，默认线程工厂方法创建一个新的、非守护线程，并且不包含特殊的配置信息。 示例 12345678910111213141516171819/** * @author dreamyao * @title * @date 2018/3/30 下午1:02 * @since 1.0.0 */public class MyThreadFactory implements ThreadFactory &#123; private final String poolName; public MyThreadFactory(String poolName) &#123; this.poolName = poolName; &#125; @Override public Thread newThread(Runnable r) &#123; return new MyAppThread(r, poolName); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @author dreamyao * @title * @date 2018/3/30 下午1:03 * @since 1.0.0 */public class MyAppThread extends Thread &#123; public static final String DEFAULT_NAME = "MyAppThread"; private static volatile boolean debugLifecycle = false; private static final AtomicInteger created = new AtomicInteger(); private static final AtomicInteger alive = new AtomicInteger(); private static final Logger logger = LoggerFactory.getLogger(MyAppThread.class); public MyAppThread(Runnable target, String name) &#123; super(target, name + "_" + created.incrementAndGet()); setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler()&#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; logger.info("UNCAUGHT in thread" + t.getName(), e); &#125; &#125;); &#125; public void run()&#123; boolean debug = debugLifecycle; if (debug) &#123; logger.info("Created" + getName()); &#125; try &#123; alive.incrementAndGet(); super.run(); &#125;finally &#123; alive.decrementAndGet(); if (debug) &#123; logger.info("Exiting " + getName()); &#125; &#125; &#125; public static int getThreadsCreaded()&#123; return created.get(); &#125; public static int getThreadsAlive()&#123; return alive.get(); &#125; public static boolean getDebug()&#123; return debugLifecycle; &#125; public static void setDebug(boolean b) &#123; debugLifecycle = b; &#125;&#125; 扩展ThreadPoolExecutorThreadPoolExcutor提供了几个在子类化中改写的方法：beforeExecute、afterExecute、terminated 在执行任务的线程中将调用beforeExecute、afterExecute等方法，在这些方法中还可以添加日志、计时、监视、统计信息收集的功能。无论任务是从run中正常返回还是抛出异常而返回，afterExecute方法都会被调用（如果任务在完成后带有一个Error，那么就不会调用afterExecute）如果BeforeExecute抛出一个RuntimeException，那么任务将不被执行，并且afterExecute也不会被调用。 在线程池关闭操作时调用terminated，terminated可以用来释放Executor在其生命周期里分配的各种资源，此外还可以执行发送通知、记录日志、或者收集finalize统计信息等操作。 示例 线程池添加统计信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @author dreamyao * @title * @date 2018/3/30 下午1:31 * @since 1.0.0 */public class TimingThreadPool extends ThreadPoolExecutor &#123; private final ThreadLocal&lt;Long&gt; startTime = new ThreadLocal&lt;&gt;(); private final Logger logger = LoggerFactory.getLogger(TimingThreadPool.class); private final AtomicLong numTasks = new AtomicLong(); private final AtomicLong totalTime = new AtomicLong(); public TimingThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); &#125; public TimingThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory); &#125; public TimingThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler); &#125; public TimingThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); &#125; @Override protected void beforeExecute(Thread t, Runnable r) &#123; super.beforeExecute(t, r); logger.info(String.format("Thread %s: start %s", t, r)); &#125; @Override protected void afterExecute(Runnable r, Throwable t) &#123; try &#123; long endTime = System.nanoTime(); long taskTime = endTime - startTime.get(); numTasks.incrementAndGet(); totalTime.addAndGet(taskTime); logger.info(String.format("Thread %s: end %s, time=%dns", t, r, taskTime)); &#125; finally &#123; super.afterExecute(r, t); &#125; &#125; @Override protected void terminated() &#123; try &#123; logger.info(String.format("Terminated: avg time=%dns", totalTime.get() / numTasks.get())); &#125; finally &#123; super.terminated(); &#125; &#125;&#125; 递归算法的并行化如果在循环体中包含了一些密集计算，或者需要执行可能阻塞的I/O操作，那么只要每次迭代是独立的，都可以对其进行并行优化。 如果循环中的迭代操作都是独立的，并且不需要等待所有的迭代操作都完成再继续执行，那么就可以使用Executor将串行循环转化为并行循环。 如果需要提交一个任务集并等待他们完成，那么可以使用ExecutorService.invokeAll，并且在所有任务都执行完成后调用CompletionService来获得结果。 当串行循环中的各个迭代操作之间彼此独立，并且每个迭代操作执行的工作量比管理一个新任务时带来的开销更多，那么这个串行循环就适合并行化 示例 谜题框架 123456789101112131415/** * @author dreamyao * @title * @date 2018/3/31 下午7:46 * @since 1.0.0 */public interface Puzzle&lt;P,M&gt; &#123; P initialPosition(); boolean isGoal(P position); Set&lt;M&gt; legalMoves(P position); P move(P position, M move);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @author dreamyao * @title * @date 2018/3/31 下午7:53 * @since 1.0.0 */public class SequentialPuzzledSolver&lt;P,M&gt; &#123; private final Puzzle&lt;P, M&gt; puzzle; private final Set&lt;P&gt; seen = new HashSet&lt;&gt;(); public SequentialPuzzledSolver(Puzzle&lt;P, M&gt; puzzle) &#123; this.puzzle = puzzle; &#125; public List&lt;M&gt; solve()&#123; P pos = puzzle.initialPosition(); return search(new Node&lt;&gt;(pos, null, null)); &#125; private List&lt;M&gt; search(Node&lt;P,M&gt; node) &#123; if (!seen.contains(node.pos)) &#123; seen.add(node.pos); if (puzzle.isGoal(node.pos)) &#123; return node.asMoveList(); &#125; for (M move : puzzle.legalMoves(node.pos)) &#123; P pos = puzzle.move(node.pos, move); Node&lt;P, M&gt; child = new Node&lt;&gt;(pos, move, node); List&lt;M&gt; result = search(child); if (result != null) &#123; return result; &#125; &#125; &#125; return null; &#125; @Immutable static class Node&lt;P,M&gt;&#123; final P pos; final M move; final Node&lt;P, M&gt; prev; public Node(P pos, M move, Node&lt;P, M&gt; prev) &#123; this.pos = pos; this.move = move; this.prev = prev; &#125; List&lt;M&gt; asMoveList()&#123; List&lt;M&gt; solution = new LinkedList&lt;&gt;(); for (Node&lt;P, M&gt; n = this; n.move != null; n = n.prev) &#123; solution.add(0, n.move); &#125; return solution; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @author dreamyao * @title * @date 2018/3/31 下午8:03 * @since 1.0.0 */public class ConcurrentPuzzleSolver&lt;P, M&gt; &#123; private final Puzzle&lt;P, M&gt; puzzle; private final ExecutorService exec; private final ConcurrentMap&lt;P, Boolean&gt; seen; final ValueLatch&lt;SequentialPuzzledSolver.Node&lt;P, M&gt;&gt; solution = new ValueLatch&lt;&gt;(); public ConcurrentPuzzleSolver(Puzzle&lt;P, M&gt; puzzle, ExecutorService exec, ConcurrentMap&lt;P, Boolean&gt; seen) &#123; this.puzzle = puzzle; this.exec = exec; this.seen = seen; &#125; public List&lt;M&gt; solve() throws InterruptedException &#123; try &#123; P p = puzzle.initialPosition(); exec.execute(newTask(p, null, null)); // 阻塞直到找到解答 SequentialPuzzledSolver.Node&lt;P, M&gt; solnNode = solution.getValue(); return (solnNode == null) ? null : solnNode.asMoveList(); &#125; finally &#123; exec.shutdown(); &#125; &#125; protected Runnable newTask(P p, M m, SequentialPuzzledSolver.Node&lt;P, M&gt; n) &#123; return new SolverTask(p, m, n); &#125; class SolverTask extends SequentialPuzzledSolver.Node&lt;P, M&gt; implements Runnable &#123; public SolverTask(P pos, M move, SequentialPuzzledSolver.Node&lt;P, M&gt; prev) &#123; super(pos, move, prev); &#125; @Override public void run() &#123; if (solution.isSet() || seen.putIfAbsent(pos, true) != null) &#123; // 已经找到了解答或者已经遍历这个位置 return; &#125; if (puzzle.isGoal(pos)) &#123; solution.setValue(this); &#125; else &#123; for (M m : puzzle.legalMoves(pos)) &#123; exec.execute(newTask(puzzle.move(pos, m), m, this)); &#125; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/** * @author dreamyao * @title * @date 2018/3/31 下午8:18 * @since 1.0.0 */public class PuzzleSolver&lt;P,M&gt; extends ConcurrentPuzzleSolver&lt;P,M&gt; &#123; private final AtomicInteger taskCount = new AtomicInteger(0); public PuzzleSolver(Puzzle&lt;P, M&gt; puzzle, ExecutorService exec, ConcurrentMap&lt;P, Boolean&gt; seen) &#123; super(puzzle, exec, seen); &#125; protected Runnable newTask(P p, M m, SequentialPuzzledSolver.Node&lt;P,M&gt; n) &#123; return new CountingSolverTask(p, m, n); &#125; class CountingSolverTask extends SolverTask &#123; CountingSolverTask(P pos, M move, SequentialPuzzledSolver.Node&lt;P, M&gt; prev) &#123; super(pos, move, prev); taskCount.incrementAndGet(); &#125; @Override public void run() &#123; try &#123; super.run(); &#125; finally &#123; if (taskCount.decrementAndGet() == 0) &#123; solution.setValue(null); &#125; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031/** * @author dreamyao * @title * @date 2018/3/31 下午8:06 * @since 1.0.0 */@ThreadSafepublic class ValueLatch&lt;T&gt; &#123; @GuardedBy("this") private T value = null; private final CountDownLatch done = new CountDownLatch(1); public boolean isSet()&#123; return done.getCount() == 0; &#125; public synchronized void setValue(T newValue) &#123; if (!isSet()) &#123; value = newValue; done.countDown(); &#125; &#125; public T getValue() throws InterruptedException &#123; done.await(); synchronized (this) &#123; return value; &#125; &#125;&#125; 避免活跃性危险死锁当一个线程永远的持有一个锁，并且其他线程尝试获得这个锁时，那么他们将永远被阻塞。 锁顺序死锁两个线程以不同的顺序来获取相同的锁，那么会发生死锁，如果所有的线程都以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题。 示例 简单的锁顺序死锁 123456789101112131415161718192021222324252627/** * @author dreamyao * @title * @date 2018/4/4 下午1:28 * @since 1.0.0 */public class LeftRightDeadLock &#123; private final Object left = new Object(); private final Object right = new Object(); public void leftRight() &#123; synchronized (left) &#123; synchronized (right) &#123; &#125; &#125; &#125; public void rightLeft() &#123; synchronized (right) &#123; synchronized (left) &#123; &#125; &#125; &#125;&#125; 注：文章来源DreamYao，转载请获得许可,谢谢。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从最简单的测量误差讲到极大似然，最小二乘和高斯分布]]></title>
    <url>%2F2018%2F04%2F10%2F%E4%BB%8E%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%B5%8B%E9%87%8F%E8%AF%AF%E5%B7%AE%E8%AE%B2%E5%88%B0%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%EF%BC%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E5%92%8C%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[引言 还在我们上小学自然科学课的时候,就在接触各种实验数据了。比如：小车的长度、烧开一壶水的时间、化学容器的容积等等。当然粗心大意的我们在做完一系列实验过后惊奇的发现，实验结果竟然和书上写的结论不符。看着我们一脸稚气、迷惑而自责的样子，于是老师安慰道：没事，一切都是在误差允许的范围内的。 这个时候我们第一次接触了误差这个东西。那么怎么减少误差呢？或许这道题目就出现过在你的试卷上。其中一个正确的答案是：多次测量取算数平均值。 但是，为什么呢？为什么取算数平均值可以减少误差呢？让我们来解决这问题吧！ 追寻高斯的影子故事的开始 关于取平均值法，实际上在人们弄清楚它到底是科学的还是凭感觉之前，古人们已经使用大约一千年不止了。可是如此数学家们还是很好奇这个问题的答案。此前也有几个人给出过一些解释，不过都效果不太好，直到一个叫做高斯的男人出现。今天我们就来看看这个数学伟人是怎么证明的吧。 在开始数学证明开始之前，我们先来看一下故事的开始。 1801年1月，天文学家Giuseppe Piazzi发现了一颗从未见过的光度8等的星在移动，这颗现在被称作谷神星（Ceres）的小行星在夜空中出现6个星期，扫过八度角后在就在太阳的光芒下没了踪影，无法观测。而留下的观测数据有限，难以计算出他的轨道，天文学家也因此无法确定这颗新星是彗星还是行星，这个问题很快成了学术界关注的焦点。高斯当时已经是很有名望的年轻数学家了，这个问题也引起了他的兴趣。高斯以其卓越的数学才能创立了一种崭新的行星轨道的计算方法，一个小时之内就计算出了行星的轨道，并预言了它在夜空中出现的时间和位置。1801年12月31日夜，德国天文爱好者奥伯斯(Heinrich Olbers)在高斯预言的时间里，用望远镜对准了这片天空。果然不出所料，谷神星出现了！ 高斯为此名声大震，但是高斯当时拒绝透露计算轨道的方法，原因可能是高斯认为自己的方法的理论基础还不够成熟，而高斯一向治学严谨、精益求精，不轻易发表没有思考成熟的理论。直到1809年高斯系统地完善了相关的数学理论后，才将他的方法公布于众。 如果你也是数学爱好者，一定记得这就是松鼠科学会中的相关文章。那么问题来了高斯是怎么解决的呢？让我们开始进入数学模式。 这里我向各位保证只要你有一些简单的高等数学知识就可以听的懂，我也会尽量解释的详细，如果觉得自己理解能力差的，不妨把这当成一个挑战总之，让我们开始吧。 数学证明开始 首先让我们确定一下问题的本质：我们要了解的是什么呢？是误差。误差是不确定的因素，我们不可能知道我们对下一次测量的误差是多少，不过我们或许可以给出下一次测量的时候出现某个大小的误差的发生的可能性。如果说真实的值是不变的，那么误差就是那个经常改变的那个东西。那么怎么分析一个经常改变的量呢？概率密度曲线。还记得吧。 现在我们不妨认为误差的概率密度是函数 f(x) 这个 $ f(x) $ 在这里表示什么呢。比如出现的误差是 $x_1$ ，那么我轻易的知道出现误差是 $ x_1 $ 的概率为 $ f(x_1) $ ,这再明显不过了，因为这就是概率密度的定义。 现在我们设物体的实际的值为$ \Psi $,那么可以轻松的知道测量时得到某个值的概率大小。 f(X-\Psi) 其中 $X$ 是每次观察的值。那么我们怎么研究误差呢？和一切科学一样我们要实验，我们要有一组观测数据。当然这里你没有必要真正的观测，而是认为自己观测了一组数据 $X_i$，其中i为1到N，N为你观测的次数。 注意！这里第一个关键的问题来了。 极大似然法简单介绍（选读） 这里请读者思考一个问题：我为什么会实实在在的观测到这些值呢？ 当然答案有很多种，思考的角度不同结果也不相同。极大似然法是这样思考的。既然我观测到了这样的数据，证明原来数据的概率分布一定是使我观察到这样结果最大的分布。 你或许会说，这太自负了。数据和你本身有什么关系。别自以为是了。然而，就经验而言，这样的自以为是是有着他的道理的。比如我们说一个小口袋里有若干小球，其中只有红色和白色。你有放回的摸了10次，其中红球是3个，白球是7个。那么你觉得袋子里的红白颜色球的比例是多少呢？3比7。你甚至不需要计算时间。但是为什么是这个数字呢。 实际上我们在计算试这个10次随机实验中发生当前概率最大的红白分布。假设其中红球的概率是$P(X=red)=p$，那么白球出现的概率就是$P(X=wite)=(1-p)=q$，那么我们发现当前这个结果发生的概率是 p^3 .(1-p)^7 我们实际在求这个函数的极大值时的p的值。当然有一种写法。 \mathop{\arg\max}_{p} {p^3 .(1-p)^7}使用极大似然法 接上方。根据极大似然我们便可以知道产生我们这组观测数据的概率是,每个发生的概率的积。 F(X) = \prod_{i=1}^{N}{f(X_i-\Psi)} 那么我们要做的就是求这个函数的极值点。这里有一些小技巧。其实说不上技巧啦，你看多了别人的推到经常使用，就是我们在取极值点时不喜欢相乘的形式而喜欢相加的形式。于是这我们往往取以$e$为底的对数。原式变为： ln{\prod_{i=1}^{N}{f(X_i-\Psi)}}\sum_{i=1}^{N}{ln{f(X_i-\Psi)}} 根据对数的性质很容器得到上式。 这里使用了对数的性质：$ln{(X.Y)}=ln{X}+ln{Y}$ 那么我们就要去求这个式子的导数，然后令他等于0就好了。于是： \sum_{i=1}^{N}{\frac{f^{'}(X_i-\Psi)}{f(X_i-\Psi)}} = 0 这里使用了联合函数求导公式和对数求导公式：$h(x)=f(g(x)) =&gt; h^{‘}(x)=f^{‘}(g(x).g^{‘}(x);{ln{X}}^{‘}=\frac{1}{X} $ 这里我们不妨令$g(x) = \frac{f^{‘}(x)}{f(x)}$于是乎原式变为： \sum_{i=1}^{N}g(X_i-\Psi) = 0 现在，第二个重要的部分来了。这个怎么求出函数$f(x)$呢？我们天才高斯这里做了一个假设。那就是我们刚才的真实值$\Psi = \bar{x}$,既然我们多年使用的算术平均值是有效的，那么我便认为平均值就是真实值好了。这个简单而合理的假设就是高斯天才的地方。现在原式变为： \sum_{i=1}^{N}g(X_i-\bar{x}) = 0 这里要注意一下，很多时候我都容易想不清楚。这里上式是具有一般性的式子。也就是说我们可以任意的捏造X的数值特征下，它都满足。以此方法求出我们需要的$f(x)$。这就是典型的由一般到特殊再到一般的过程。 首先让$N=2$，我们先考虑只有两个测量值的简单情况。看看代入到原式会发生什么。 g(x_1-\bar{x}) = -g(x_2-\bar{x}) 注意观察这个公式。请记住我们有$x_1$和$x_2$的算术平均值$\bar{x}$。于是有了$x_1+x_2=\bar{x}+\bar{x}$。现在简单的进行变换可以得到一个和上式有关的形式。 x_1-\bar{x} = -(x_2-\bar{x}) 于是我们得到了下面这等式： g(x)=-g(-x) 那么g(x)是一个奇函数没跑了。 接下来对$X$的限制比较多。但是没有到达不能理解的地步，让我们来看一下。现在不妨令$N=m+1$,之后令前m项目都相等值为$x$，而最后一项的值正好是$-mx$。下面我们用公式来表示这个要求： x_1 = x_2 = \cdots =x_m = x;x_{m+1} = -mx; 这样有一个好处就是这时我们可爱的$\bar{x}$已经光荣的等于0了。好了我们现在往原式带入便得到了下面的形式。 mg(x)=-g(-mx)=g(mx) => mg(x) = g(mx) 好了，如果熟悉柯西方程的同学们应该一口就说出了$g(x)=cx$(其中c是一个常数)。当然你不熟悉也没有关系，我这里会进行一个简单的证明。这里或许和你的教科书上并没有什么不同。你当然可以跳过这一段了。 柯西方程(选读) 如果你有耐心读下去会发现真的不难，甚至会自然的解答关于上一些证明方法的部分疑问的情绪。好了先让我们忘了上面该死的 $g(x)$。来看看一个简单的形式： f(x+y) = f(x)+f(y) 由此式超级容易知道： f(x_1 + x_2+ \cdots + x_n) = f(x_1)+f(x_2)+ \cdots + f(x_n) 现在令$x_1= x_2 = \cdot =x_n = x$，于是乎原式等于： f(nx)=nf(x) 现在再令$x=\frac{m}{n}$注意这里面的m与n都是整数。代入继续看看会发生什么： f(m) = nf(\frac{m}{n}) = f(m.1) = mf(1)nf(\frac{m}{n}) = mf(1) 我们现在把等号左侧的n除过去，便可以得到我们需要的形式了： f(\frac{m}{n}) = \frac{m}{n}.f(1) 现在我们将$\frac{m}{n}$作为一个整体，其中$f(1)$是一个常数我们认为他就是c就好了。于是乎得到了$f(x)=cx$了。注意这里的m与n都是整数，所以上面的证明其实不完备，只是证明了有理数的部分。如果为了严谨我们要证明在无理数的情况下依然成立。这里只需要证明cx的形式在无理数的情况下也成立即可。我此处省略了，欢迎大家查阅资料。 最后的函数方程 现在我们回到正题刚才我们得到了$g(x)=cx$,但是还记得吗？我们要求的是$f(x)$。于是乎我们最终要求的函数方程便成为： \frac{f^{'}(x)}{f(x)} = cx 这里我没有找到现成的证明，于是我自己尝试了一个解法。可能是错的，大家也可以尝试着自己解一下。我的方法是： f(x) = \exp{g(x)}; g(x) = \ln{f(x)} 这里的exp表达的是$e^x$ 之后带入原式就可以解出来了： f(x)=M\exp{cx^2} 这个形式其实是和我们熟悉的高斯分布的形式是等效的。 小结 我们现在来看一下我们熟悉的高斯分布的形式然后我会对我们得到这个形式做一定的解释。高斯分布他老人家是张的这样的： f(x)=\frac{1}{\sqrt{2\pi}\sigma}\exp{(-\frac{(x-\mu)^2}{2\sigma^2})}其中我们可以清楚的看到我们误差的均值是0。认真思考一下误差的均值一定是零的。于是乎我们跟随高斯大神当年的脚步，发现了高斯分布。其中关键就是一个符合常理的假设，真实值为算术平均值。 向高斯提出质疑 我们现在好好回想一下高斯的证明。会发现有一些问题。首先为啥实际值可以为算术平局值呢？是因为测量的误差符合正态分布。但是还记得我们怎么推到出正态分布吗？我们假设了真实值就是算术平局值吗？我的天，难道高斯的证明虽然很优美但是却是循环论证。不错，仔细思考一下这就是循环论证。那么问题在哪里呢？怎能逃出这个怪圈呢？ 现在我们想一下误差要服从正态分布的原因。真的是因为真实值是算术平局值吗？不，不是的。那么我们怎么确信误差就是符合正态分布的呢？答案有很多。其中有两个说发比较经典。 中心极限定理。这个定理说明什么呢？许多概率分布在满足一定条件下，有无穷多个的时候，他们的总体概率分布竟然意外的可以近似为正态分布。我的天，这也太神奇了。也就说，一般有许多不确定因素引起的误差，一起作用的结果就是符合正态分布的。 还有一个解释是最大熵原则。也就是说在确定了均值和方差的情况下，正态分布是保证系统熵最大的分布。（关于这结论的具体证明我没有找到）也就是说我们在测量了一组数据之后，我们认为他是符合正态分布是有道理的。 由极大似然到最小二乘法 现在我们再简单的介绍一下最小二乘法。在进行数学推导之前，我们先给出他的思想，因为他的思想真的很好的理解。就是总体误差值的距离和最小。我们知道误差是有正有负的，不过那些数学家不太愿意去分情况了解其正负，反正是取距离的大小趋势，那么比起取绝对值，使用平方研究起来简单多了。我们只要保证所有的误差和的平方最小就好了。用公式表示就是这样： x = \mathop{ \arg\min }_{x} {\sum_{i=1}^{N}(x-x_i)^2} 那么这里和极大似然法又有什么联系呢？让我们把均值为0的高斯分布作为误差函数代回到之前的极大似然法中 f(x) = \frac{1}{\sqrt{2\pi}\sigma}\exp{(-\frac{x^2}{2\sigma^2})} 要注意的是这里x是误差值哦。那么出现某个测量值概率应该是什么呢？ f(X) = \frac{1}{\sqrt{2\pi}\sigma}\exp{(-\frac{(x-X)^2}{2\sigma^2})} 所以我们可以得到极大似然的目标函数 \sum_{i=1}^{N}\ln{\frac{1}{\sqrt{2\pi}\sigma}\exp{(-\frac{(x-X_i)^2}{2\sigma^2})}} 我们要使这个式子得到最大值。那么我们就要使$\frac{(x-X_i)^2}{2\sigma^2}$得到最小值，因为前面有个负号嘛。欸，这样不就等效了吗？ 也就是说在误差符合正态分布的情况下，最小二乘和极大似然是等效的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高斯分布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅入浅出的Spring+Websocket的探索]]></title>
    <url>%2F2017%2F12%2F05%2F%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E7%9A%84Spring-Websocket%E7%9A%84%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[OverView Spring + WebSocket 简单配置 前端SockJS 的简单配置 一点我自己没有用的讨论 Spring + WebSocket 简单配置mean 依赖12345&lt;!--spring websocket库--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 修改web.xml配置 使用Spring Mvc,要在servlet的spring配置里面加上&lt;async-supported&gt;true&lt;/async-supported&gt;的配置，下方仅仅是一个示例。 1234&lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; 编写配置类 Websocket暴露的地址是怎么注册的呢？有两种方法一种是写配置文件（在xml里面），一种是写配置类。这里我使用的是配置类的方法。 这里要注册websocket的地址，并且要让项目启动的时候生效。所以我们要自己写一个类，继承WebMvcConfigurerAdaptermvc的配置适配器，并且实现WebSocketConfigurer接口，来完成websocket使用地址的注册。 1234567891011121314151617181920212223242526272829import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.socket.WebSocketHandler;import org.springframework.web.socket.config.annotation.EnableWebSocket;import org.springframework.web.socket.config.annotation.WebSocketConfigurer;import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;/** * 配置webSocket * Created by An alone-banner */@Configuration@EnableWebMvc@EnableWebSocketpublic class webSocketConfig extends WebMvcConfigurerAdapter implements WebSocketConfigurer &#123; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; //todo 注册的websocket的代码就写在这里 项目启动时这里就会生效的 registry .addHandler(new systemWebSocketHandler(),"/ws/chat") .addInterceptors(new SystemHandshakeInterceptor()) .setAllowedOrigins("*") .withSockJS() .setClientLibraryUrl("https://cdn.jsdelivr.net/sockjs/1.1.2/sockjs.min.js"); &#125;&#125; 顺便一提上面的注解是必须的。 明显的注册器允许你注册多个地址，并且每个地址有自己处理器(Handler)和拦截器(Interceptor)。其中一个用来处理链接后的消息的行为。另外一个拦截器择在网络层直接处理请求，于是可以获取请求中的许多多东西，并且可以给每个webScoeket会话（Session 注意区别Http 中的session 这里指建立的一个链接）加上属性，以方便管理。 当然这里两个东西都要你自己实现。就像上文中的 systemWebSocketHandler,SystemHandshakeInterceptor一样，你都需要继承或实现接口官方的东西，然后加上你自己的代码。先不要管他们，我一会说到的，现在你只要对这两个东西有一个大体的功能有个认识就好。 在往下看. setAllowedOrigins是设置支持的域名的，如果你发现报错是403的问题，那么你可能要注意一下这里的值是什么。 最后是设置支持SockJS和它的第三方库地址。直接用cdn加速的地址就好了。SockJS是个好东西，他可以在浏览器不支持Websocket的情况下，对服务进行降级。 编写Handler类 编写自己的Handler类的要求并不高，只需要实现官方的接口即可。1234567891011121314151617181920212223242526272829303132333435import org.springframework.web.socket.CloseStatus;import org.springframework.web.socket.WebSocketHandler;import org.springframework.web.socket.WebSocketMessage;import org.springframework.web.socket.WebSocketSession;/** * * Created by An AloneBanner */public class MyWebSocketHandler implements WebSocketHandler &#123; @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; //todo 成功建立的会话后的操作 &#125; @Override public void handleMessage(WebSocketSession session, WebSocketMessage&lt;?&gt; message) throws Exception &#123; //这里是写收到消息后逻辑代码的地方 &#125; @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; //这里是处理链接异常的地方 &#125; @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception &#123; //这里是处理链接关闭的地方 &#125; @Override public boolean supportsPartialMessages() &#123; return false; &#125;&#125; 这里就要写处理消息的代码了。一般的做法是在建立链接的时候把session都放在一个统一的地方进行管理保证，实现更加复杂的逻辑。一般是建立一个管理链接的链接池。一般的处理思路有两种，一种是缓存在内存里面，还有一种是使用redis对会话进行缓存。我个人倾向于使用内存进行管理。但是这是后话了。 其他地方的操作也简单，处理处理消息的地方需要你用一些必要的技巧，剩下的断开连接的地方释放连接池里的链接就可以了。 便一提我这里的类名和上面的类名是不一致的。请你在自己学习的时候是理解我在做什么，而不是抄代码。：） 编写拦截器 同理编写链接器，需要你自己的类继承官方的类HttpSessionHandshakeInterceptor。注意你也可以的什么都不做在注册的时候直接使用这个类。但这就意味着你什么也没有做。其实这里可以做很多的事。让我们先看一下代码吧。 1234567891011121314151617181920212223import org.springframework.http.server.ServerHttpRequest;import org.springframework.http.server.ServerHttpResponse;import org.springframework.web.socket.WebSocketHandler;import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;import java.util.Map;/** * http会话的过滤器 * Created by Prince of Wind */public class MyHandshakeInterceptor extends HttpSessionHandshakeInterceptor&#123; @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception &#123; return super.beforeHandshake(request, response, wsHandler, attributes); //todo 可以在这里进行一些处理 &#125; @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) &#123; super.afterHandshake(request, response, wsHandler, ex); &#125;&#125; 我这里仅仅介绍两个你有可能用到的需要覆盖的方法。我就是觉得好的代码就是这样，只要你看看名字就知道他们分别是握手前,和握手后的操纵。注意在这里你就可以取到java标准的Http请求对象。这里你便可以获取到请求中的URL参数，请求头，协议等等信息。并且你可以为你的这次会话加上属性，这个太方便了，使用这个方法你可以有效的管理以后你要处理的WebSocket链接们。 当然具体怎么处理还要依赖对业务逻辑的设计。如果是简单的群发，就遍历所有的链接就可以了，如果是分组发生，要知道发生给哪些用户，可以在这里对WebSocket Session打上标签，在遍历的时候判断就好了。当然还有其他很多的可能我们一会再讨论。 前端SockJS 的简单配 首先送上SockJS的传送门。我们这里是SockJS的客户端，这个组件还有个node的服务端，由于我们用java提供了服务端，于是我们便可以直接使用它的服务端,这也说明我们并不关心websocket是那种语言提供的服务端，这也是协议的特点。 在前端我们可以用npm下载依赖，也可以使用cdn加速。&lt;script src=&quot;https://cdn.jsdelivr.net/sockjs/1/sockjs.min.js&quot;&gt;&lt;/script&gt;。现在我们看看官方给的资料中的demo。 123456789101112var sock = new SockJS('https://mydomain.com/myendpoint');sock.onopen = function() &#123; console.log('open');&#125;;sock.onmessage = function(e) &#123; console.log('message', e.data);&#125;;sock.onclose = function() &#123; console.log('close');&#125;;sock.send('test');sock.close(); 这里在建立链接的时候必须是http或者https。也就是直接你后端注册的地址。比如我刚才写的的’ws/chat’使用这种方法建立链接。这里不用担心，他开始会建立原生的Websocket链接，如果浏览器不知道便会降级为浏览器可以使用的方法，前端感知的就是一个抽象的websocket对象。（具体是长链接还轮询就不得而知了） Under the hood SockJS tries to use native WebSockets first. If that fails it can use a variety of browser-specific transport protocols and presents them through WebSocket-like abstractions. 在建立链接后就可以像监听器一样的发生消息给服务端，也可以随时的接受到服务端的消息了。这里实现聊天功能或者是实现对某个状态值的绑定更是不在话下了。只需要在onmessage里对页面中的某个元素进行刷新就好了。这些对js来说没有什么难度的。 一点我自己没有用的讨论怎么区分用户 这里讨论一下之前遗留下来的，关于区别用用户的问题。我们前面说道要在拦截器的时候在握手建立之前可以获取用户的session,用这个方法可以知道用户的登录信息，也可以包括一些其他信息（比如用户所在的讨论组的房间id，用户隐身状态等）。除此之外还有别的办法，比如在建立链接后再让用户发送自己的登录信息，这种方法也是可行的，这不过不是给Websocket 会话加上属性，而是自己管理一个HashMap（也可以是特殊的数据结构）管理链接池。这样当然没有前一种方法显得的优雅，但是可以很好处理一下和用户登录绑定的其他附加属性。所以我的建议只在拦截器一层处理一些必要的信息，比如用户的id而已，而其他状态再连接池中管理。 但即便如此，我还没有思考怎么管理效率才最好。 怎么实现统一的消息平台 我们知道很多的所谓的云推送的平台，只要你交钱就可以使用api实现云推送的能力。于是我思考怎么去定义一套可以给全公司所有部门介入的开发组件。可以让接入方通过自定义的方法去实现云推送的效果，而不是一个新的业务逻辑，就要新写一个websocket服务（或者其他消息推送的方案）。 想象一下我们要知道这个链接是给那个app的。或者说那个域名独享的。还要知道它是和登录状态有关的还是无关的。其次我们要用户自定义不同处理的数据结构。但是还需要他们遵循同一套接口标准。 我没有时间和运气思考清楚具体的技术方案。欢迎讨论。 我将一直的迷惑和无知，我是黄油香蕉君，谢谢，再见。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次数据库崩溃的处理]]></title>
    <url>%2F2017%2F11%2F29%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B4%A9%E6%BA%83%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[现象描述 本人使用mac电脑。在docker上搭建php+mysql+ubuntu开发环境。使用phpmyadmin去管理数据库。在容器关闭之后再次启动进入之后发现了phpmyadmin不能使用了。如果按照报错查询资料是要求修改phpmyadmin的配置文件这个是错的。其实使用service mysql status会发现mysql已经启动不了了。这个才是问题关键。 排查过程 在处理问题上我这次是有点实用主义的原则。能拿到可以处理问题的报错就好，不会深入的纠结于到底发生了什么。但是我使用service mysql start启动的时候，什么错误也没有是怎么回事呢？ 那是因为报错文档都写到了log里面。都在/var/log/mysql/error.log里面。我们不妨看一下. 1234567891011121314151617 2017-11-29T03:07:42.750695Z 0 [Note] InnoDB: File &apos;./ibtmp1&apos; size is now 12 MB.2017-11-29T03:07:42.751483Z 0 [Note] InnoDB: 96 redo rollback segment(s) found. 96 redo rollback segment(s) are active.2017-11-29T03:07:42.751515Z 0 [Note] InnoDB: 32 non-redo rollback segment(s) are active.2017-11-29T03:07:42.752010Z 0 [Note] InnoDB: 5.7.20 started; log sequence number 26749822017-11-29T03:07:42.752373Z 0 [Note] Plugin &apos;FEDERATED&apos; is disabled.2017-11-29T03:07:42.755688Z 0 [Warning] Failed to set up SSL because of the following SSL library error: SSL context is not usable without certificate and private key2017-11-29T03:07:42.755744Z 0 [Note] Server hostname (bind-address): &apos;127.0.0.1&apos;; port: 33062017-11-29T03:07:42.755765Z 0 [Note] - &apos;127.0.0.1&apos; resolves to &apos;127.0.0.1&apos;;2017-11-29T03:07:42.755792Z 0 [Note] Server socket created on IP: &apos;127.0.0.1&apos;.2017-11-29T03:07:42.755974Z 0 [Note] InnoDB: Loading buffer pool(s) from /var/lib/mysql/ib_buffer_pool2017-11-29T03:07:42.757059Z 0 [Note] InnoDB: Buffer pool(s) load completed at 171129 3:07:422017-11-29T03:07:42.758298Z 0 [ERROR] /usr/sbin/mysqld: Table &apos;./mysql/db&apos; is marked as crashed and should be repaired2017-11-29T03:07:42.760700Z 0 [ERROR] Couldn&apos;t repair table: mysql.db2017-11-29T03:07:42.760783Z 0 [ERROR] Fatal error: Can&apos;t open and lock privilege tables: Incorrect key file for table &apos;db&apos;; try to repair it2017-11-29T03:07:42.761125Z 0 [ERROR] Aborting2017-11-29T03:07:42.761211Z 0 [Note] Binlog end 对不起我就截取了一段。但是就够用了。我们看一下这里面关键的是ERROR哪里。稍微百度翻译一下你会发现他说这里的表被记录为已经损坏了不能启动了。可能你报错的时候不是mysql这个而是user什么的。其实都是一样的，告诉你表已经崩溃要修复。 好了你可能会查询修复表的命令。于是查到这个mysqlcheck。结果发现不行啊。那是当然这条指令是要你启动了mysql才能用的。那怎么办呢？ 我在网站找到了一个跳过这个东西先启动然后在登陆的方法。我试试那条指令（一会会告诉你的），结果发现报错，是上面的那一坨，于是要先修复了这个mysql的表才行，至少能让我跳过启动。于是我有查询，得到了修复二进制文件的指令myisamchk这条好不用启动mysql。于是乎就好了。 流程记录 修复二进制文件(先cd到/var/lib/mysql/mysql)myisamchk -f *.MYI 跳过启动在修复service mysql start –skip-grant-tablesmysqlcheck -r mysql user 喝杯咖啡🎉一下。 传送门 传送门1 传送门2 我将一直的迷惑和无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次有趣的数学题]]></title>
    <url>%2F2017%2F11%2F09%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记录一次有趣的数学题 前言 我本人数学水平极差，就是一个概念都要思考半天的人。但是很可惜我喜欢数学。我也很喜欢编程和算法。所以如果有什么工作是结合算法、数学和编程的我一定很喜欢。我知道很多大学生和研究生的作业题就是这样。于是我很乐意去动动我已经成白痴的脑子来尝试看一下。我已经工作了，于是乎心态和你们或许有很大不同。你们或许觉得很恶心因为你们不得不去做，我仅仅是觉得好玩慢慢的思考。 但是不代表我就比你们幸运哦。 问题描述 有一个函数f(x)对一组不重复的列表进行全排列（使用递归）。设这个类别中元素的个数是N个，于是我们定义计算递归函数f(x)调用次数的函数叫做F(n)。那么现在求下面这个公式的值： {\lim_{n \to +\infty}} \frac{F(n)}{n!}解 现在可以看出来这个题目分两个部分，其一是要知道这个程序怎么写，然后是算出F(n)的公式。之后辨识一个球极限的数学问题。于是我们先看看这数学问题。 编程问题 全排列吗？我们可以轻易的看出来全排列是一个递归的过程。 想想我们人类手动全排列的时候是怎么思考的。我们先确定第一位数字是什么。那么这个排列需要知道剩下的（n-1）个数据的全排列，和第一个数组成新的排列。这样把每个数据都当成第一个元素一遍就可以得到所有的排列。 （看看下面的伪代码） 12345678910111213这里认为 A是全排列的函数 list是一个有n个元素的列表function A(list)&#123;//如果列表的长度是1就返回他本身 if(list.length==1): return list res = [];//保存结果的变量// 对foreach(obj on list): tmp = [obj : A(list without obj)] //注意这里表示 由obj 和 除了obj的list剩下的元素的全排列组成的新的排列的集合 res-&gt;push(tmp)return res; 相信编程能力很好的你。可以看出来我这里对于变量的表示不严谨，但是没有关系，这部妨碍我们理解这个递归的原理。和下一步进行解题。明白了为什么全排列是一个递归之后，我们便关心其中的这个解构就好了。我抽象出来如下。 123456789//这里认为react是一个根据自然数n生成升序列的函数 比如 // react(5) =&gt; [1,2,3,4,5] n也表元素的个数// 现在用react(5)-[2]表示 除去2这个元素 react(5)-[2] =&gt; [1,3,4,5] 显然它的元素个数是n-1function a(react(n)&#123; for(react(n) as index=&gt;value)&#123;//表示索引加上值 则需要的排列 value + a( react(n) - value);//注意这个也是一组排列 &#125;&#125; 可以看出来开始的时候有n个循环调用了n次函数a。然后每个调用又要循环n-1次。那么第二层的调用就有多少呢？n(n-1)。第三次就是n(n-1)(n-2).于是要求这些数的和。最后一个是多少呢？好好想想！，最后的结束条件是列表长度变为1。那么表示最后每个前一级调用了一次。于是n(n-1)(n-2)…(n-(n-1))也就是n！。哈哈那么这个公式是不就清晰了呢？ {\lim_{n \to +\infty}} \frac{n+n(n-1)+n(n-1)(n-2)+ ... +n!}{n!} 开始算吧少年。 数学问题 这其实已经很简单了。为了方便我们把公式抄一遍： {\lim_{n \to +\infty}} \frac{n+n(n-1)+n(n-1)(n-2)+ ... +n!}{n!} 现在看看分数符号上方的部分。 n+n(n-1) + n(n-1)(n-2) + ... + n! 我们看看n怎么表示呢。$ n = \frac{n!}{(n-1)!} $ 使用这个公式来替换就会有一个有趣的现象发生了。 \frac{n!}{(n-1)!} + \frac{n!}{(n-2)!} + ... + \frac{n!}{1} 注意这里下面还除以了一个n!呢！现在正好可以和分母的n!消掉。ok看看下面的公式 \frac{1}{(n-1)!} + \frac{1}{(n-2)!} + ... + \frac{1}{1} 这个是啥呢？？ 你还没有看出来吗？？好吧同学我换一个顺序。 1 + \frac{1}{1x2} + \frac{1}{1x2x3} + ... + \frac{1}{n!} 也就是 \lim_{a \to +\infty} \sum_{n=0}^a (\frac{1}{n!}) 哦是不是似曾相识的感觉，这个数是什么？ 是自然常数 e。 我开始得到这里的时候就方了。还在想这个数是多少呢！看这个格式还以为是泰勒公式的逆运算。结果查了好久，算了好久，才发现这个数是e。哎~~老了。 传送门自然常数 我将一直迷惑和无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相思累]]></title>
    <url>%2F2017%2F10%2F06%2F%E7%9B%B8%E6%80%9D%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[序 于那日醉酒后，做于手机。抄录于此以记之。 正文12345678910相见不如怀念，留着个物件，不过是刻舟求剑。 近水楼台先得月，费劲心血，为伊消得人憔悴，却是镜中花，水中月。 巧者劳而智者忧，玲珑心灵，烦恼多处于猜不透。 万万不可细思量，一思一断肠。 闷在胸口，手发凉，泪珠儿转在眼眶上。 说不清，有冤无处诉。道不明，不敢在动情。 从此分两地，相知不相闻。 装作你不在，我亦多情人。 如此日复日，如此年复年。年年似一日，日日度如年。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学生党福利使用websocket实现简单的聊天室]]></title>
    <url>%2F2017%2F10%2F01%2F%E5%AD%A6%E7%94%9F%E5%85%9A%E7%A6%8F%E5%88%A9%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[前言 终于到了十一国庆，有时间更新一些东西了。 先从回忆开始。我是重邮的学生，记得上通信软件基础的时候，(@罗文丰)老师给我们留的作业是，写一个简单的聊天室。技术不限制。当时我想写一个web端聊天室。这条技术路线给我当时填了很多的麻烦。也就是说我要实现的是，web端的即时通信。web端我们可以用的协议是http。http是一个无状态的协议，怎么完成即使通信呢？当时自己脑壳都想废了。答案无非两种。 使用轮询。就是使用ajax过一段时间查询一次。 或者长连接。就是我发一个请求了，等有消息了在回复，然后处理了再发长连接。 可是那时我骄傲的认为都不好。都垃圾！怎么这就是现在业内的主流方案。不优雅！老子弄个更加牛逼的。结果搞出来了一个更加垃圾的。ajax+xml的方法。功能都没有实现是请求的时候获取更新的。（我当时固执的认为，网络效率要高，现在想想一个课程设计高个锤子！） 所以，我为学生党的你奉献出这个富有创造力的解决方案。 技术方案 websocket协议API传送门 + js 后端服务提供 websocketd 传送门 前端服务提供 http-server 传送门 注意 如果你以为这篇文章是给伸手党准备的，你就错了。你要在电脑上运行起这段代码。你至少要你学会一下这些技能。git 安装运行linux虚拟机（windows用户） JavaScript只是了解dom 简单的计算机网络知识 翻墙技术（非必须）简单的shell脚本知识 但是不要紧张我保证这些知识花一周就可以掌握。而且遇到了困难了还可以问学长。欢迎评论和邮箱:) 原理 先简单的说一下这个websocket的协议（这个阮一峰的教程说的很好可以先传送一下看一下传送门）。他保证了一个到web的有状态连接。保证两边都是可以发送消息。这个对web开发即时场景来说简直太好了。 所以原来很简单。就是每个页面连接到一个ws（websocket）服务。然后把数据存到一个文件中，在读取这个文件中的信息返回给每个连接的用户。这里使用websocketd（注意多了一个d，这是一个提供websocket服务的服务器）。它很强大，它不分语言，只有在命令行里打包可以运行的命令他都可以进行提供服务。你甚至可以用c++写一个游戏服务器，给前端提供服务。如果各位感兴趣我可以在日后为大家完成demo。 所以，你可以看到这个原理是如此的简单，这都得益于优雅的websocket协议，富有创造力的websocketd服务器。 代码客户端代码很少。只有两个一个页面，和一个服务器脚本。这个没什么好说的，直接看代码吧；1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;CTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;title&gt;简单的聊天室&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content" &gt; &lt;span&gt;等待输出在开始通信&lt;/span&gt; &lt;br&gt; &lt;/div&gt; &lt;input type="text" id="input" /&gt; &lt;button type="submit" id="submit"&gt;发送&lt;/button&gt; &lt;script&gt; //注意这里的地址 需要你进行修改！ var ws= new WebSocket('ws://zhouzihaodeMacBook-Pro.local:8080/'); var btn = document.getElementById("submit"); var text = document.getElementById("input"); var content = document.getElementById("content"); ws.addEventListener('message', function (event) &#123; console.log('Message from server ', event.data); content.innerHTML += event.data+"&lt;br&gt;"; &#125;); ws.onclose = function(event)&#123; console.log('closed'); &#125; //给按钮添加监听事件然后发送消息 btn.onclick = function()&#123; //如果内容为空就不发送出来 if(text.value == '')&#123; //donothing &#125;else&#123; ws.send(text.value); //吧刚刚发的消息 回显出来 console.log('send'+text.value); text.value = ''; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务端然后是服务端的脚本。捂脸。这个都是我照着官方的demo抄的改的。看一下吧。 1234567891011121314#!/bin/bash# 代码源自websocketd官方项目的demo我做了一些小的修改！每次发消息的时候也会显示回来~# 注意这是不需要的！我为了方便在这么做的。但是这加大了网络的io。正常做法是用js直接现在在页面里。# 这段代码只能跑在 可以使用这些命令的机器上 的服务器上。如果你使用的是windows请检查这个文件是否可以使用。# 或者我将在别的时间内。补充windows可用的版本echo "Please enter your name:"; read USERecho "[$(date)] $&#123;USER&#125; joined the chat" &gt;&gt; chat.logecho "[$(date)] Welcome to the chat $&#123;USER&#125;!"# 注意这里 这里如果没有生效要改成自己的地址MYDIR=`pwd -L`tail -n 0 -f "$&#123;MYDIR&#125;/chat.log" &amp;while read MSG; do echo "[$(date)] $&#123;USER&#125;&gt; $&#123;MSG&#125;" &gt;&gt; chat.log; done 最后是我的git代码传送门 结果首先启动文件夹下的chat为websocket服务。websocket --port=8080 $project-dir$/chat这里的project_dir是项目文件夹的绝对路径。然后在把index.html发布成web就可以了。http-server之后按照提示访问就好。为了看效果要开两个tab来看。 我将一直迷惑和无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node黑魔法js操作命令行的方法续]]></title>
    <url>%2F2017%2F09%2F17%2Fnode%E9%BB%91%E9%AD%94%E6%B3%95js%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[前言 之前向朋友们介绍过使用shelljs这个包来对命令行进行操作。其实在nodejs中提供了更加优雅的方法来帮助我们对命令行进行操作。现在就可以使用child_process作为关键字进行查询。他是nodejs原生支持的一个模块，作用是开始一个子进程。使用这个模块中的exec方法就可以运行某些指令了。但是呢要注意，这里是异步的，如果你要封装一个调用的函数，不一定可以直接运行出值。这的处理办法是：使用回调函数或者使用Promise。 代码示例 这里直接上一个封装了Promise的代码。 123456789101112131415161718//使用SE 的写法封装一个git的命令var cp = require("child_process")export function gitStatus(directory)&#123; var comd = "git status" //返回了一个Promise对象 return new Promise(function(resolve,reject)&#123; cp.exec(comd,&#123;cwd:directory&#125;,function(error,stdout,stderr)&#123; if(error)&#123; //返回报错信息 reject(stderr) &#125;else&#123; //返回命令行输出 resolve(stdout) &#125; &#125;); &#125;)&#125; 简单的解释一下代码里的内容。其中exec()是运行一个函数的意思。其中的第二个参数cwd是命令运行的文件夹。然后这返回了一个Promise对象。这样就优雅的解决的调用时异步的问题。也就是说在使用的时候使用.then()的写法就可以了。 后记 当然如果你是一个js的新手或许没有理解我说的。这里主要涉及了三个知识点。现在分别献上传送门。 ES6 中文文档 Promise Promise迷你书 child_process nodejs文档相信你看了这些就明白了，也不需要我多说了。 我将一直的迷惑与无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>js</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Common-Lisp常用函数速查速记笔记]]></title>
    <url>%2F2017%2F08%2F10%2FCommon-Lisp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E9%80%9F%E6%9F%A5%E9%80%9F%E8%AE%B0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Common-Lisp常用函数速查速记笔记 这是一本Common-lisp常用函数和宏查询手册，将持续更新。当然如果你有英文阅读能力，我还是建议你手中常备一本CookBook。 列表操作list 生成列表生成列表。 12(list 'a 'b); (A B) cons 构造列表把两个列表构造成一个列表。 12345678(cons 'a '(b c d)); (A B C D)(cons 'a (cons 'b nil)); (A B)(cons 'a 'b); (A.B) car 获取列表中的第一个元素12(car '(a b c));A cdr 获取第一元素后面的所有元素12(cdr '(a b c)); (B C) copy-list建立一个列表的拷贝。注意是新建cons而不是之前原来的列表对象。 123(setf x '(a b c) y (copy-list x));(A B C) make-list关键字参数来构建一个任意长度的元素的列表。 12(make-list 3 :initial-element 0);(0 0 0) nth 获取列表中的car指针（0索引）获取列表中某个索引的元素。 12(nth 0 '(a b c));A nthcdr 获取列表中的cdr指针（0索引)获取列表中某个元素后面的其他元素构成的列表。 12(nthcdr 1 '(a b c));(C) subseq 截取列表根据开始和结束索引截取列表的子列表。1234(subseq '(a b c d) 1 2);(B)(subseq '(a b c d) 1);(B C D) reverse 反转列表12(reverse '(a b c));(C B A) sort 排序适应自定义的函数对列表进行排序。注意这个是函数是产生副作用的。所以为了保护数据，可以使用（copy-list）对原来的数据进行保护 12(sort '(0 1 3 2 55 4) #'&gt;);(55 4 3 2 1 0) remove 不含元素的新列表举例来说，函数 remove 接受一个对象和一个列表，返回不含这个对象的新列表注意原理的列表并没有发生任何的改变123(setf lst '(a c a r t))(remove 'a lst)lst 逻辑操作if(if [逻辑表达式] [表达式1] [表达式2]) 逻辑表达式为真 求值表达式1 否则求值表达式2 12(if (listp ‘(a b c)) (+ 1 1) (- 1 1)); 2 其中listp 是判断一个元素是不是列表。 and输入一组表达式。如果所有都为真，那么返回最后一个表达式的值。否则返回nil； 1234(and t t t (- 1 1) (+ 1 1)); 2(and nil t t t (+ 1 0)); nil or值返回第一个值位真的表达式的值。 12(or (+ 1 1) 'no); 2 循环操作do (do-while循环)循环语句 (do (参数列表) (退出条件 退出返回) (循环求值表达式));参数列表（变量名 初始化值 变量更新方式） 123456789101112(defun test (x) (do ((i 0 (+ i 1))) ((&gt; i x) 'done) (fromat t "~A~%" i)))(test 3);0;1;2;3;DONE dolist循环一个列表（用法类似其他语言中的foreach） 123456789(defun my-list-length (lst) (let ((len 0)) (dolist (obj lst) (setf len (+ len 1))) len)) (my-list-length '(a b c));3 函数apply调用一个函数求值并返回。参数作为列表传入。 12(apply #'+ '(1 2 3 4 5));15 funcall调用一个函数求值并返回。参数不需要使用列表包裹。 12(funcall #'+ 1 2 3);6 lambda用于生成一个匿名函数。相当于返回了函数名。 12(funcall #&apos;(lambda (x) (+ x 100)) 1);101 mapcar （映射函数）把列表中每个个car指针送到函数中求值，然后返回值构成新的列表。 12345678(mapcar #'(lambda (x) (+ x 10)) '(1 2 3));(11 12 13)(mapcar #'list '(a b c) '(1 2 3 4));((A 1) (B 2) (C 3)) maplist把列表中每个个car指针送到函数中求值，然后返回值构成新的列表。 12(maplist #'(lambda (x) x) '(a b c)) 其他progn对一组表达式，依次求值，并且返回最后一个表达式的值。 集合操作member 返回符合条件的列表（集合）中的元素返回一个列表中符合要求的元素之后的列表。其中条件可以进行自定义。也可以对列表中元素进行自定义。 12(member 2 '((1) (2)) :key #'car :test #'equal);((2)) member-if 返回任意一个要求函数的元素后面的列表其中条件是一个函数这个函数是自定义的。 12(member-if #'oddp ‘(2 3 4));(3 4) adjoin接受一个元素和一个列表。如果这个元素不存在在列表中在加入到列表中。 12(adjoin 'a '(b c));(A B C) union 并集intersection 交集set-difference 补集栈push 压栈pop 出栈pushnew 只进新元素的压栈数学oddp判断一个数字是不是奇数。是返回T 否则返回NIL 输入输出read 输入（PS：这里更像是等待输入）记住 read 会一直永远等在这里，直到你输入了某些东西，并且（通常要）按下回车。因此，不打印明确的提示信息是很不明智的，程序会给人已经死机的印象，但其实它是在等待输入。第二件关于 read 所需要知道的事是，它很强大： read 是一个完整的 Lisp 解析器（parser）。不仅是可以读入字符，然后当作字符串返回它们。它解析它所读入的东西，并返回产生出来的 Lisp 对象 format 输出123(format t "~A is a ~A ~% !!" 1 (+ 1 1)'DONE);; 其中 ~A是占位符 ~%是换行符。最会返回NIL而不是T。NIL不代表着打印失败了。打印是程序的副作用和取值无关。 变量let 局部变量PS. 我敢打包票js中的关键字是灵感来源于此。123(let ((x 1) (y 2))) (+ x y));;3 defparameter 全局变量1(defparameter *glob* 99) defconstant 全局常量1(defconstant limit (+ *glob* 1)) boundp 检查一个符号是否是全局的变量或者常量1(boundp &apos;*glob*) typep 变量类型判断特殊的数据结构数组操作make-array 创建数组1(setf arr (make-array '(2 3) :initial-element nil)); 上面的代码可以创建一个2X3的数组。其中使用了关键字参数。表示初始化所有的值都是nil aref 取出数组中的位置的值（0索引的）1234(aref arr 0 0); NIL(setf (aref arr 0 0) 'b);B 这里就可以把数组里（0，0）的位置赋值为B了，但是注意这里是赋值成了符号’B,不是字符串“B”哦。 表示字面常量的数组一般来说使用#na的语法来表，比如:#2a((a b c) (nil nil nil))如果全局变量 *print-array* 为真，则数组会展示成这种形式。 vector 和 svref 向量操作一维的数组表示为向量，生成时直接传参数就可以了。读取和数组是一样的0索引。 字符串字符串就是字符构成的数组 char-code code-char 字符串的ASCII转换char取字符串的第n个字符 字符串的比较 sring-equal 不区分大写写的比较 equal 区分大小写的比较 结构体defstruct 定义结构体123(defstruct pointxy) 这个方法是定义了一个结构体。同时隐式的定义了一些方法: make-point point-p copy-point point-x point-y 输入输出流路径名 make-pathname路径名（pathname）是一种指定一个文件的可移植方式。路径名包含了六个部分：host、device、directory、name、type 及 version。你可以通过调用 make-pathname 搭配一个或多个对应的关键字参数来产生一个路径。在最简单的情况下，你可以只指明名字，让其他的部分留为缺省：12(setf path (make-pathname :name "my.file")); #P"my.file" open 打开一个文件流open可以接受一个上面那样的标准路径名数据，之后打开一个文件流。在创建这流的时候，可以使用关键字参数来指定流的行为。比如读写或者是读写都做。还可以指定在缺省条件下的行为。比如我们现在建立一个新建文件的输出流。他是这样的。123456789;;创建一个路径到myfile.md(setf filepath (make-path :name "myfile.md"));;创建输出流 :supersede 表示取代之在文件存在的情况下(setf mysteam (open filepath :direction :output :if-exists :supersede));;现在我们用之前format函数随便写点什么吧！(format mysteam "Holle dream! ~%");;记得关闭流 不然现在查看文件很可能是空的(close mysteam) read-line 读取流中的一行少废话上代码：1234567(setf path (make-path :name "myfile"))(setf stream (open path :direction :input))(read-line stream);;打印出来文件中的第一行(close stream);;关闭流养成好习惯 with-open-file (打开文件宏)打开操作一起哈成 123(with-open-file (str path :direction :output :if-exists :supersede) (format str "Something~%")) 包定义123456(defpackage "MY-APPLICATION" (:use "COMMON-LISP" "MY-UTILITIES") (:nicknames "APP") (:export "WIN" "LOSE" "DRAW"))(in-package my-application) 这里主要是在export是你要 分享出去的包。 类型转化float 将任何实数转换成浮点型12(mapcar #'float '(1 2/3 .5));;(1.0 0.6666667 0.5) truncate 返回任何实数的整数部分123(truncate 1.3);1;0.2999995 floor 向下取整ceiling 向上取整round 四舍五入mod 取余数signum 符号函数abs 绝对值函数random 随机数expt 指数X^{n}1(expt x n) 宏相关defmacro 宏定义下面有具体的例子 ` 和 , 和 ,@少废话看代码。 123456(setf lst '(a b c));(A B C)`(a is ,lst);(A IS (A B C))`(b is ,@lst);(B IS A B C) 那么这样的好处是什么？看看我们自己定义一个while函数。 1234(defmacro while (test &amp;rest body) `(do () (not ,test) ,@body)) gensym 返回一个独一无二的符号在宏的定义的时候为什么要使用这个函数呢？那是因为在使用内部的变量的时候会出现，外面的定义个宏内部定义一样导致变量被入侵的情况。于是在写宏的时候就要考虑得和程序设计人员一样。除此之外还有就是 传入的表达式很肯能导致变量被多重取值了。这是很恐怖的。 这里有一个把一段代码取值n次的宏定义。注意体会他的脊髓。 1234567(defmacro ntimes (n &amp;rest body) (let ((g (gemsym)) (h (gemsym))) `(let (,h ,n)) (do ((,g 0 (+ ,g 1))) ((&gt;= ,g ,h)) ,@body))) 注意这没有反引号的生成的新符号保证了在，反引号里面的h并不在被重新求值了。这个是很重要的。在宏的设计里面。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概念自然语言的思考]]></title>
    <url>%2F2017%2F08%2F07%2F%E6%A6%82%E5%BF%B5%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[概念的产生 和 自然语言 的思考 概念 不是客观的存在 这个有个古老的疑问：如果有一个人看见的蓝色和红色恰好是相反的。然后我们怎么知道他知道是错的呢？ 这个是一个很有趣的例子。你可能会为此迷惑一到两秒。请相信，在本文中我们所提到“概念”这个词。和上面这个例子中提到的是一样的，就是你大脑中想到的东西。因为是你想到的，或者是我想到，所以显然这是不具有客观性的。 注意 这是一个基本的思想。可能和你之前的认知有一定的冲突。但是请理解这一点。这对后面的描述很重要。 或许你对上面的描述产生很大的疑问。那么我将在这个小单元简单的讨论。我本来想这样写：这里概念分为两类，一直是客观事实是客观的概念，一个是主观的感受是我们“感觉到”的概念。这样描述起来似乎轻松一点。但是这种二分法是错误的。根本不存在什么客观事实的概念。仔细想一下，没有人就没有概念！（这里严谨的说不一定是只有人类）然后你会说假设没有人，也会有红色，有蓝色吧！错！！！没有人类，这个大前提是假，所以有或者没有都是成立的。 这里问题关键是主观和客观的问题。那什么才是主观，什么是客观的呢？或许你会想到一个定义的方法：对于一个物体（事物）的性质不根据观察者的意识所改变，那么我们就可以认为他是客观的。反之是主观的。这里就有一个有意思的地方了。这个定义里面有个叫做观察者的词。 上面的例子中，只是观察者的感觉是红和蓝的，我们便说他是错的。可是，某种程度上他没有错。这个描述中有个陷阱！我们看到的红色和蓝色都是一样的感觉吗？ 明白了吧，我们都是以“自己”（自我）为尺度来观察这个世界，当我们对于客观世界形成概念时，其实就是主观的。那么什么是客观呢？ 哈哈。当然是我们脑海中一个叫做“客观”的概念啦。 这个时候你或许已经疯了。在中国这一定与你从小建立的认知不符。那么我们学着科学家的思路来“客观的”看看红色和蓝色。注意，这个过程很有趣！什么是红色和蓝色呢？是进入到我们眼睛中的光，于是我们对光进行频谱分析，然后在仪器上使用传感器分析得到红光的频率是多少多少到多少多少。于是我们定义并且得到了红色的客观存在。哈哈。注意！科学家做了什么！他不使用自己做世界的尺度，而是使用世界上的另外一个实物来做这个尺度。这个比自己观察来说“客观”多了。现在你明白了什么是客观了吧。 这里进行一个展开。首先我们不信任自己的感觉啦（注意还是相信自己的眼睛看到了，只是不相信眼睛啦），倒是信任仪器上的符号啦。我们聪明的承认每个人看到的颜色是不一样的。但是却坚定的认为每个人看到“符号”是一样的。说来也巧，还真没有这种事情发生。不过这个在我看来就涉及到可知论与不可知论了。随便一提，光进入我们眼睛里后，开始接受这个光信息的是眼球下的视觉神经细胞。我现在越来越“感觉”管神经细胞，叫做“神”经的人是天才了。 概念是 被观测世界的 本真反应 概念的产生，必须依赖可以产生概念的生物。保守估计，人类是一种。那么我们就以人类作为研究对象。看看他有什么特点。 那么我发现的结果就是：概念是个很狭隘的东西。为什么这么说。概念是我们观察世界最最本真的反应。为什么我不用真实而是本真这个词呢？因为他不一定真实，但是确确实实的真实感受。感受是真的，但是感受道的东西不一定是真相或者真实。(诡吊的是，我们往往很难知道我们是错的) 怎样更好的理解一下这句话呢？我现在用可能有点庸俗的语言来说。概念是必选观测者的器官和外界作用来产生的。 好好的思考一下这句话，不要笑！然后看看下面推论： 出现什么样的概念，取决于你使用什么器官来感受。 出现什么样的概念，取决于你使用多少器官来感受。 出现什么样的概念，取决于你用来感受的器官怎么样。 前两个推论很好理解，只要你有生活，不难理解。那么我直接来讲三个往往我们忽略了的这点。 第三个推论提现了一种生物，在感受世界时的局限性。什么意思呢？我们如果没有感受某一个物理量的器官，那么狠遗憾，我们将不会出现相关的任何概念。至于语言,就不会有描述“感觉”的词汇。注意哦！这是说没有描述感受的词汇，而不是说没有词汇。因为概念是可以派生的，所以我没有说死。但是却没有描述感受的词汇。 举一个有趣了例子。假设有一种智慧生物，它们进化出了一种器官可以感受空间中电磁场的变化，为了方便你们这些人类理解，我用你们可以听懂的方式来描述。就想海浪一样在空间中有波纹的。这种生物出现两个概念，当波纹的形状像一个V的时候，他们的语言中叫”laV”,而当波纹的形状像U的时候他们的语言中叫”Ual”。现在他们作为天外来客和地球人交谈，就是使用了翻译机器，也发现这个词没有对应人类自然语言中的任何一个词甚至已经有了概念。 概念是 被历史的描述 一个未知的概念只能被已经知道的概念所描述。 （通常情况）反应到语言上就是，我们要理解一个新词的时候，对它下定义的文本段中的词汇必须是我们理解的。不然就需要额外的材料去解释。 研究概念的应该叫什么人呢？暂时我们叫概念学家吧。我不是概念学家，所以初步的找了一些生成新概念的方法。 组合：A+B。消减：A-B。派生。等等。因为我比较懒。没有把这个问题思考的特别清晰。你要是有兴趣自己去想想吧。 语言文字 是对 概念中信息 有损失编码 疑问：词语 和 概念 是一回事吗？ 当然不是一回事！就像我很喜欢的一句哲学诗“当我已经说出来的时候，就不是我要表达的意思了。一旦你明白我的意思时，我就不用说了” 那么语言文字和概念之前是一种什么关系呢？语言是对概念中信息的一种编码。 这个学过通讯的学生都可以很好的理解。比如我和你交流，我先把自己脑子中的概念，编码成字然后打印出来。之后被你看到，然后你在理解成概念。可是这个过程中出现了一些问题值得我们注意一下。 我们使用统一的语言的两个人可以顺利的交流，也是一个很奇迹的事啦。因为他们翻译字符或者语音获取的信息可能完全不同。这是因为这里对字符的解编码的过程是一个使用经验的系统。每个人的经验中的概念都不一样，So 如此来说我们使用翻译词汇的方法来翻译可能存在一些问题。应该是解析概念然后重新编码。 本来编码过程就失去了大部分信息。比如“我想你”。可能是“我今天看到有人在吃饺子，于是想到你也喜欢吃的饺子，于是在想到了你在干么呢？于是很想见到你。可是见到了又能怎么样呢？还是简简单单说一句我想你吧”。所以解码过程中就可能什么也读不出来。相反明明没有什么信息量，反而解释出很的内容 todo 先写到这里有时间在写]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始看懂Java代码系列教程（OOP）]]></title>
    <url>%2F2017%2F08%2F05%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9C%8B%E6%87%82Java%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88OOP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[OOP—面向对象编程 OverView(概述)两种编程方法的战争！基本概念 似乎自从面向对象的编程方法出现以来，关于什么才是最好的编程方法的争论似乎就没有停止过。其中区别比较大的就是传统的面向过程编程和面向对象编程这两种。那么他们又有什么区别呢？ 面向过程编程：面向过程，顾名思义就是按照完成任务的步骤进行编程。他关心的是实现任务过程是什么样。是什么样的就写成什么样。第一步做什么，第二步做什么，第三步做什么依次类推，直到任务完成。 面向对象编程：面向对象，关系的是任务进行的对象是什么。然后对任务进行抽象。让对象按照他们的行为进行任务的完成。 例子： 现在我们使用五子棋程序进行举例。如图所示： 面向过程就是简单的模拟下五子棋的过程。白的走一步，然后黑的走，如此交替进行，然后每次下棋的时候判断输赢条件。而面向对象的方法就不一样的了。可以在下五子棋的过程中抽象出很多的对象。棋盘是对象，棋子也是对象，玩家也是对象。规程可以是对象也可以是属性（甚至是配置文件）。实例化一局游戏，然后进行游戏。你可以发现面向对象的方法有很多好处，比如我现在要把这个游戏变成一个围棋游戏。面向对象的程序员可以很优雅的修改规则就可以了。这里规则就是一个对象或者类文件，如果定义的好甚至就是一个配置文件。这样就可以在两种棋类中任意的切换了。而面向过程的代码，则需要进入到步骤中，把涉及规则的部分全部改掉。也就是说如果要是另外一个程序员接手这个工作，就要读懂全部的代码。而面向对象的程序员仅仅明白规程的部分就可以了。（甚至可以让不是程序员的人按照一定规则写配置文件）于是，面向过程的程序员可能吐槽：“你妹呦，这个程序我啷个改嘛！” 一些编程语言的支持（选读）那么现在的编程语言都是什么样呢？如何你感兴趣我可以和你讲讲。首先是c语言是面向过程的。原因很简单这么语言关注的是底层要的是运行的效率。诚然良好的编程习惯可以使代码有很强的可读性和复用性。可是C语言始终在处理需要对象的大型应用上拙荆见肘。于是乎有了C++他支持面向对象编程的方法，可是C++的api过于烦乱和复杂拥有太多的细节。有人可以说自己精通C语言，但是几乎没有敢说自己精通C++。激进派的人有发明了Objective-C。C+面向对象，完美的解决了他们自认为的问题。所以诚然你在写C++的代码时可以写成面向过程的，它也是可以运行的，只不过没有提现这门语言的特点。PHP就不一样的了，他只从设计出来就仿佛在告诉人们，怎么简单怎么写。他运行程序员，在使用哪种都可以。这点和C++很像，可以php可以说自己是更顶层的，更加面向应用的。现在来说说我们的主角Java，这个是一个纯面向对象的语言，意思是说他鼓励你使用面向对象的方法编程。并且引导你使用java去思考问题。于是有了叫做Thinking in Java的说法。这很形象。java完美的支持着面向对象，甚至程序的入口必选是个对象。可是语言的生命力是如此的强大，比如AOP面向切面编程等。比如支持函数式编程。说道AOP，php也支持不过不是主打的功能。函数式是自从JavaScript火了以来的大的趋势，几乎所新的语言都在标榜自己支持着个特性，老牌的语言也在加入这个行列之中。随便一提的是，有些语言可以通过编程对自身进行扩展，来支持新的特性，比如申请的lisp，但是这种语言学习成本很高，而且没有良好的氛围和圈子，在业界没有成为主流。这也很明显在业界成为主流的一定不是什么特别难的东西。 JAVA 中的面向对象面向对象编程的三大特点和解释封装将对象的行为和属性封装起来，其载体就是类。对使用者而言，它隐藏了实现的具体细节。这就是封装。比如有一款游戏游戏菜单对象中有一个存档的方法。你在使用的时候完全不需要知道，具体都做了什么。（当然类的提供者必须知道，不然代码就是没有实现的了）可能需要把游戏中所有存在的关键对象扫描一遍存在一个静态的文件中方便你下次游戏时加载进来。这种类隐藏属性和行为实现细节的特性就加做封装。 继承继承是梳理类和类之间关系，提高类复用效率的方法。继承性主要利用了特定对象之间的共有属性和方法。比如。四边形式一个类，而平行四边形是它的子类。正方形有是平行四边形的子类。（想一下四边形不就是四边形的“爷类”吗~是这样的。不过一般没有这个说法就是了） 多态刚才提到了父类和子类，有一样的属性和方法，但是要是他们有某个方法的实现不一样怎么办呢？比如走路是动物都有方法，但是人用双脚走路，而袋鼠要用跳的方法走路。这时就体现了类的多态性。类的继承关系中允许对通一个行为有不同的实现，这个就是多态。那么代码中他又是怎么实现的呢？使用的抽象类和接口。抽象类定义了一个不能被直接实例化成对象的类，只有一个继承了它才可以被使用。这个类中是可以带上方法的实现的。可是接口就不一样的，接口只是定义了一个“标准”实现它的类必选去实现这些已经定义好的方法。抽象类只能被继承一个，但是可以实现多个接口。 类的成员变量和成员方法权限修饰符]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾遗录15最后的拾遗]]></title>
    <url>%2F2017%2F08%2F05%2F%E6%8B%BE%E9%81%97%E5%BD%9515%E6%9C%80%E5%90%8E%E7%9A%84%E6%8B%BE%E9%81%97%2F</url>
    <content type="text"><![CDATA[拾遗录.十五.最后的拾遗 前言 好久没有更新了，这个系列的文章其实很小众，很个人向。所以说好的一周一更没有达成，嘻嘻，也没有什么关系吧。之前整理材料的时候没有按照什么时间顺序，其实是不太好的。完全是凭借我个人的喜欢进行筛选和修改的，有一些觉得自己不喜欢的就没有编入进来。现在想想觉得挺对不起他们的。于是在最后一篇的时间里都编辑进来。做最后的整理。 古体诗部分其一1234 绝诗沥血伤心断肠处，无奈黄昏天涯路，堰桥过，柳叶木愁云难改，潇潇落，问君何处，相思树？人道是--缘尽轮回两不知。 其二123 御带花 无题相识未知相依迟，桃红柳垂改火。望秋叹雪两载过，才懂佳人风情。乌梅马尾，点素面回眸笑我。言留平易处，醉生逍遥自得。好梦终破，天命织女孤独泊。嫣然泪落，怎么言尽，当年春丝明月，今日落落。不负泪壶，挥襟徘徊终不舍。难忆姿容，仰挽冰轮空默默。 注释: 改火：典故，过了两年。 泪壶： 典故，忘了你自己查吧~ 冰轮：月亮。 其三1234 无恩情长亭夜晚，骤雨歇，空灵月月长影。断魂酒，一人尽欢不尽饮。孤孤愁对雪。空有霜，霖如血，残香暗倾万丈野。高金冠，紫黄衫，青钢剑气断梅兰。君子笔，佳人诗，千言万语终不睹。人若有义何至此，可惜苍天无恩情。 其四123 蝶恋花 无题芊芊素手留玉人，挽留不住无端南唐雁，只叫羞羞三回首，望恨梅红绿杨柳。左依右依梦难求，回忆不尽昨日连丝藕，起坐点灭香尘否？恍然泪落语某某。 其五123 苏幕遮 无题秋心愁，言吾语，不知否极，泰来何欢喜？朝霞幻妙终泡影，山盟海誓，良言难相依。飞屑乱萤纷烦雨，弦断招魂曲，与谁共画同心苣，苍茫自伤枕案湿《论语》。 其六123 沁园春 无题红袖莫言，度日如年，愁花落尽，枕玉难入眠，拆窗雨雨。纷纷绵绵，自修小草，意满恬恬，送过人雁，看去春来百花颜，独使我，孤独吻残雪，泪可湿砚。伊人嬉嬉笑笑，思人看罢愁字怎少。况斜月空然，萋萋芳草，忽见流星，许愿正好，浑然正思，不知斯情怎么了，风也过，日动破晨晓，悸心难调。 其七12345 无题月明白树耀，鸦栖梧桐阴。若无凤凰落，才子何来琴。和乐枫林晚，夕阳佳更明。昏时江水热，恋花总伤情。 其八123 千秋岁 无题风稀月坏，寒云天高戴。岁已近，谁徘徊？飘零雪花纱，伤至青红白，轻思梦，有无天仙散花台。细听莺莺语，道是寻常来，茶也凉，人不在。走观百芳草，慢收心玉埋，藏丹青，醉唤真真需几载？ 注释： 真真： 典故，自己查去吧:） 其九123 南歌子轻狂折柳鞭，椅马寻杜康，梨花岸边一少年，正是北望慢试青釭剑。铜戈断无光，白骨埋野原，只叹燎烬赤壁荒，不道后世草夫唤阿瞒。 其十12 无题缘分，缘分，有缘无份，相聚时日短，别离时日长，当初笑汝年轻狂，几句言语早忘。怎知日后为人娘，惜得什么沽浊酒，白望喜鹊落闺房。凉，凉，不是三言两语，笑颜强。 其十又一12345 雨后有感雾雨锁黄昏，霜凝柳叶重。最爱秋风过，红妆还罗素。 其十又二123 无题一簇天真白海棠，洋洋洒洒落君旁。谁料春雨怎堪摘，香尽天涯路茫茫。 注释： 海棠无香。 其十又三123 不平花还未开被雨残，雨还未落狂风拦。风欲飞起高墙阻，正道何时回人间。 现代诗部分其一1234 初晓初晓的梦是醒来的梦醒着，却在梦中 其二1234567891011121314151617181920212223242526272829 放弃我想牵你的手，你握着回忆不放开，紧紧看见月牙弯弯骗自己，谁会回来？我想抱你入怀，你急忙将我推开说些莫名其妙的话语让人如何才能释怀我想顺你的发你将头发扭开想以高傲的自尊挽回谁谁谁的青睐我想对你表白你表情显出无奈好像美丽的人被爱就是应该优秀的人，不被喜欢才怪于是我松开自己冰凉的手抛开自己空虚的怀远离了你的长发撕碎了写了一个月的告白走着，走着。泪水要落下来猛回头，笑着坚强。“我离开” 后记 至此，拾遗录，全部完结。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>拾遗录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小小恋歌中文填词]]></title>
    <url>%2F2017%2F08%2F02%2F%E5%B0%8F%E5%B0%8F%E6%81%8B%E6%AD%8C%E4%B8%AD%E6%96%87%E5%A1%AB%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[小小恋歌中文填词 前言 不知道什么时候听到了这首歌曲，仅仅被那温柔的旋律所打动。看到翻译后的歌词更是喜欢的不行。早就有了想要填词的愿望，可是由于种种原因没有进行。今天尝试一下，如果不好，也是没有办法的事啊。 中文歌词 想想就不可思议 这辈子遇见了你 数学家也计算过 概率几亿分之一 不知从何时而起 我们越来越亲密 我也时常在怀疑 是不是爱上了你 于是变的很小心 害怕你会不开心 想用平淡的方式 把我的心意传递~~~ 听啊~ 这幸福的声音 不知从那时的我和你 许下的约定 看吧~ 那天空的流星 我只想拉着你的手 永远走下去 看吧~ 让月光做证明 我想和你慢慢的老去 平淡的勇气~ 看吧 啊~ 啊啊 啊 啊 终于有天我们会成为 老夫和老妻~]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>歌词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用js对汉字和单词混合进行统计]]></title>
    <url>%2F2017%2F08%2F01%2F%E4%BD%BF%E7%94%A8js%E5%AF%B9%E6%B1%89%E5%AD%97%E5%92%8C%E5%8D%95%E8%AF%8D%E6%B7%B7%E5%90%88%E8%BF%9B%E8%A1%8C%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[使用js对汉字和单词混合进行统计规则 每个汉字标点做为一个长度。每个单词作为一个长度。（虽然这样的应用场景很少，但是用到的时候没有查询到直接可以用的代码，于是改造了网上的资料，作为比较记录下来） 代码12345678910111213141516171819202122232425262728function characterWordStatic(input)&#123; //计算规则 汉字算一个长度 单词算一个长度 if(input)&#123; var clength = 0; // 计算汉字个数 var str = input; //console.log(str.match(/[\u4E00-\u9FA5]/g)); if(str.match(/[\u4E00-\u9FA5]/g) != null)&#123; clength = str.match(/[\u4E00-\u9FA5]/g).length || 0; &#125; //替换汉字 str = str.replace(/[\u4e00-\u9fa5]+/g, " "); // 将换行符，前后空格不计算为单词数 str = str.replace(/\n|\r|^\s+|\s+$/gi,""); // 多个空格替换成一个空格 str = str.replace(/\s+/gi," "); var length = 0; var match = str.match(/\s/g); if (match) &#123; length = match.length + 1; &#125; else if (str) &#123; length = 1; &#125; return length+clength; &#125;else&#123; return 0; &#125;&#125; 我将一直迷惑和无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始看懂Java代码系列教程（Java基础篇）]]></title>
    <url>%2F2017%2F07%2F17%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9C%8B%E6%87%82Java%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我每天都在面向“对象”编程。 ———来自本文作者的冷笑话。 阅读指南 这篇文章为Java最为基础的语言基础。也就是说，你完全可以泛读一遍，让心里有个印象，仅仅接受自己可以接受的知识点就好。我希望做到的是在你心里建立一个词典，知道有这么回事儿就好。然后在下次遇到的时候回到手头的文档，或者工具书（当然我会给你一本的），来查看就好。那个时候在力尽可能的弄清楚。请记住这个学习方法。或许这个方法在考试上无效，但是在学习编程和技术上可以大显神威的。 Java语法基础基础概念 在Java中处理少数基础类型，其他的都是类和对象。 类：英文就是Class。表示对具有相同一类属性的对象的一种抽象。（注意这里也说是一种抽象了，很有可能两个人的“抽”发很不同但是都可以去解决实际问题，老司机可以写出超级优秀的抽象）往往我们说，类具有熟悉和方法。 对象：一个拥有具体属性和方法的“类”的实例。两个实例可以拥相同的属性和方法，但是却是两实例。 实例：我们常常说某个对象，是某个类的实例。 属性、方法： 描述一个类的特征，或者说对象拥有的特性。 一个列子全解决:我们从小动物讲起。我们知道动物就是一个类，应为每个动物都有一些抽象出来的相同的属性和能力（这里可以理解为方法）。就属性来说比如毛发的颜色，身高体重之类的。然后动物又有一些统一的方法，比如走、跑、吃、喝。就相当于类下面的方法。但是我们说动物是个类是抽象的。那么我可以说一只兔子就是动物的一个实例。我就也就可以叫这只兔子是对象了。那么它的属性就确定下来，比如毛发是白色，身高一米二之类的。方法也确定下来，毕竟兔子的吃法和老虎的吃法是不一样的。 聪明的你一定发现了，有的时候我们可以认为兔子也是一个类，级别要比动物低一些，然后兔子有很多种类，很好吃的家养兔和不太容易吃到的野生兔子。当然还有很多其他的分类方法。那么Java可以表示这些关系吗？当然是可以的。这就要涉及到继承和多态了。不要急我会在OOP（面向对象编程）中非常详细的介绍的。 Java的命名规范 大小写敏感。 类名 首字母大小。然后如果由多个单词组成单词的首字母大小。比如HappyGirlClass。 方法名 方法名首字母要小写，后面的的单词首字母大写。比如findByPhoneNum。 源文件名 源文件名和类名保持一致。完全的一致，然后以.java结尾就好。 Java 关键字Java的关键字，是不能用做变量名的字符串。也不是很多。下面有一张速查表方便你阅读。 关键字 描述 abstract 抽象方法，抽象类的修饰符 assert 断言条件是否满足 boolean 布尔数据类型 break 跳出循环或者label代码段 byte 8-bit 有符号数据类型 case switch 语句的一个条件 catch 和try搭配扑捉异常信息 char 16-bit Unicode字符数据类型 class 定义类 const 未使用 continue 不执行循环体剩余部分 default switch语句中的默认分支 do 循环语句，循环体至少会执行一次 double 64-bit双精度浮点数 else if 条件不成立时执行的分支 enum 枚举类型 extends 表示一个类是另一个类的子类 final 表示一个值在初始化之后就不能再改变了表示方法不能被重写，或者一个类不能有子类 finally 为了完成执行的代码而设计的，主要是为了程序的健壮性和完整性，无论有没有异常发生都执行代码。 float 32-bit单精度浮点数 for for循环语句 goto 未使用 if 条件语句 implements 表示一个类实现了接口 import 导入类 instanceof 测试一个对象是否是某个类的实例 int 32位整型数 interface 接口，一种抽象的类型，仅有方法和常量的定义 long 64位整型数 native 表示方法用非java代码实现 new 分配新的类实例 package 一系列相关类组成一个包 private 表示私有字段，或者方法等，只能从类内部访问 protected 表示字段只能通过类或者其子类访问子类或者在同一个包内的其他类 public 表示共有属性或者方法 return 方法返回值 short 16位数字 static 表示在类级别定义，所有实例共享的 strictfp 浮点数比较使用严格的规则 super 表示基类 switch 选择语句 synchronized 表示同一时间只能由一个线程访问的代码块 this 表示调用当前实例或者调用另一个构造函数 throw 抛出异常 throws 定义方法可能抛出的异常 transient 修饰不要序列化的字段 try 表示代码块要做异常处理或者和finally配合表示是否抛出异常都执行finally中的代码 void 标记方法不返回任何值 volatile 标记字段可能会被多个线程同时访问，而不做同步 while while循环 基本数据类型我说过在Java中除了基础数据类型以外都是对象。那么我们先来看一下基础的数据类型。 字节型（byte）字节型是一种 8 位有正负的二进制整数最小值是 -128(-2^7)最大值是 127(2^7-1)默认值为 0字节型数据类型主要是为了在大型数组内节省空间，主要是替代整数由于字节型比整数小 4 倍。例如：byte a = 100 , byte b = -50 短整数（short）短整数是一种 16 位有正负的二进制整数最小值是 -32768(-2^15)最大值是 32767(2^15-1)短整数类型的数据也可以像字节型一样用于节省空间。短整数比整数小两倍默认值为 0例如：short s = 10000, short r = -20000 整数型（int）整数型是一种 32 位有正负的二进制整数最小值是 - 2,147,483,648(-2^31)最大值是 2,147,483,647(2^31 -1)整数型一般默认被应用于整数值除非担心内存不够用。默认值为 0例如：int a = 100000, int b = -200000 长整型（long）长整型是一种 64 位有正负的二进制整数最小值是 -9,223,372,036,854,775,808(-2^63)最大值是 9,223,372,036,854,775,807 (2^63 -1)这种数据类型一般是在需要比整数型范围更大时应用。默认值为 0L例如：long a = 100000L, int b = -200000L 浮点型（float）浮点型数据是一种单精度的 32 位 IEEE 754 标准下的浮点数据。浮点型数据主要是为了在大型浮点数字数组中节约内存。默认值是 0.0f。浮点型数据不能用于如货币这样的精确数据。例如：float f1 = 234.5f 双精度型（double）双精度型数据是一种双精度的 64 位 IEEE 754 标准下的浮点数据。这种数据类型主要是默认被用于表示小数的值，一般是默认的选择。双精度型数据不能用于如货币这样的精确数据。默认值是 0.0d例如：double d1 = 123.4 布尔型（boolean）布尔型数据代表一个信息比特。它只有两个可能的值：真（true）和假（false）这种数据类型用于真假条件下的简单标记。默认值是假（false）例如：boolean one = true 字符型（char）字符型数据是简单的 16 位 Unicode 标准下的字符。最小值是： ‘\u0000’ (或 0)。最大值是： ‘\uffff’ (或 65,535 )。字符型数据可以用来储存任意字母。例如： char letter A（字符型的字母A） =’A’ 引用数据类型引用数据类型是由类的编辑器定义的。他们是用于访问对象的。这些变量被定义为不可更改的特定类型。例如：Employee， Puppy 等等。类对象和数组变量就是这种引用数据类型。任何引用数据类型的默认值都为空。一个引用数据类型可以被用于任何声明类型和兼容类型的对象。例如：Animal animal = new Animal(“giraffe”)； 也就是在你定义一个变量的时候必须知道他的类型，这也是为什么Java也是强类型的原因 变量去一个例子，直接来看看这些变量的使用和这些变量的修饰符。 123456789101112131415161718/*** 我们建立一个兔子类*/public class Rabbit&#123; //兔子眼睛颜色是一个可以被外部访问的public变量 public String eyeColor; //兔子有一个私有的名字只能被内部访问 private String myName; // 这里兔子都有一个共通的属性就是可以吃不 我这里设置成可以:) // 这里的值还是可以改变的只不过改变了一个 其他所有的实例都改变了 // 比如那天通过了一条法律兔子不能吃了 这个值设置成false了 private static Boolean canBeEat = true; // 那么我们现在为了品尝到人间的美味就要设置成fianl 这样就不能改变了 // 这个值就成了一个真正意义上的常量。你可以烹饪兔子吗？当然可以 // 这个意味着这个值是变化不了的 public static final String CANBECOOKED = "Yes,You can.";&#125; 流程控制这里就是每个语言都要有的流程控制了。很简单看看就好。 循环控制while 循环while循环是一个控制结构，可以重复的特定任务次数。 语法1234while(Boolean_expression)&#123; //Statements&#125; 在执行时，如果布尔表达式的结果为真，则循环中的动作将被执行。只要该表达式的结果为真，执行将继续下去。在这里，while循环的关键点是循环可能不会永远运行。当表达式进行测试，结果为假，循环体将被跳过，在while循环之后的第一个语句将被执行。 do…while 循环do … while循环类似于while循环，不同的是一个do … while循环是保证至少执行一次。 语法1234do&#123; //Statements&#125; while (Boolean_expression); 请注意，布尔表达式出现在循环的结尾，所以在循环中的语句执行前一次布尔测试。如果布尔表达式为真，控制流跳回，并且在循环中的语句再次执行。这个过程反复进行，直到布尔表达式为假。 for 循环for循环是一个循环控制结构，可以有效地编写需要执行的特定次数的循环。知道一个任务要重复多少次的时候，for循环是有好处的。 语法1234for(initialization; Boolean_expression; update)&#123; //Statements&#125; 下面是一个for循环的控制流程： 初始化步骤首先被执行，并且仅一次。这个步骤可声明和初始化任何循环控制变量。不需要把一个声明放在这里，只需要一个分号出现。 接下来，布尔表达式求值。如果是 true，则执行循环体。如果是false，则循环体不执行, 并且流程控制的跳转到经过for循环的下一个语句。 之后循环体在for循环执行时，控制流程跳转备份到更新语句。该语句允许更新任何循环控制变量。这个语句可以留空，只要一个分号出现在布尔表达式之后。 布尔表达式现在再次评估计算。如果是true，循环执行，并重复这个过程（循环体，然后更新的步骤，然后布尔表达式）。之后，布尔表达式为 false，则循环终止。 示例 12345678910public class Test &#123; public static void main(String args[]) &#123; for(int x = 10; x &lt; 20; x = x+1) &#123; System.out.print("value of x : " + x ); System.out.print("\n"); &#125; &#125;&#125; for 循环在 Java 中新特性 语法1234for(declaration : expression)&#123; //Statements&#125; 声明: 新声明块变量，这是一种与你所正在访问数组中的元素兼容的变量。该变量在for块内可被利用并且它的值作为当前的数组元素将是相同的。 表达: 这个计算结果完成需要循环数组。表达式可以是一个数组变量或返回一个数组的方法调用。 示例1234567891011121314151617public class Test &#123; public static void main(String args[])&#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers )&#123; System.out.print( x ); System.out.print(","); &#125; System.out.print("\n"); String [] names =&#123;"James", "Larry", "Tom", "Lacy"&#125;; for( String name : names ) &#123; System.out.print( name ); System.out.print(","); &#125; &#125;&#125; break 关键字关键字break是用来停止整个循环的。 break关键字必须使用于任何循环中或一个switch语句中。关键字break将停止最内层循环的执行，并开始执行在块之后的下一行代码。 语法 1break; 示例 1234567891011121314public class Test &#123; public static void main(String args[]) &#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers ) &#123; if( x == 30 ) &#123; break; &#125; System.out.print( x ); System.out.print("\n"); &#125; &#125;&#125; continue 关键字continue关键字可以在任一环的控制结构使用。它使循环立即跳转到循环的下一次迭代. 在for循环中，continue关键字会导致控制流立即跳转到更新语句。 在一个while循环或do/while循环，控制流立即跳转到布尔表达式。 语法 continue 语法是任何循环中一个单独的语句：1continue; 示例123456789101112 public static void main(String args[]) &#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers ) &#123; if( x == 30 ) &#123; continue; &#125; System.out.print( x ); System.out.print("\n"); &#125; &#125;&#125; 条件判断if语句 示例12345678910111213141516public class Test &#123; public static void main(String args[])&#123; int x = 30; if( x == 10 )&#123; System.out.print("Value of X is 10"); &#125;else if( x == 20 )&#123; System.out.print("Value of X is 20"); &#125;else if( x == 30 )&#123; System.out.print("Value of X is 30"); &#125;else&#123; System.out.print("This is else statement"); &#125; &#125;&#125; if 之后可以使用很多个else。或者使用嵌套。 switch 语句switch 语句允许一个变量来对一系列值得相等性进行测试。每个值被称为一 case，并且被启动的变量会为每一个 case 检查。 语法1234567891011switch(expression)&#123; case value : //Statements break; //optional case value : //Statements break; //optional //You can have any number of case statements. default : //Optional //Statements&#125; 以下规则适用于 switch 语句： 在 switch 语句中使用的变量只能是一个字节，short，int 或 char。 在一个 switch 语句中可以有任何数量的 case 语句。每个 case 后跟着即将被比较的值和一个冒号。 对于 case 的值必须是相同的数据类型作为开关变量，它必须是一个常量或文字。 当被启动了的变量与 case 是相等的，那 case 后的语句将执行，一直到 break 为止。 当达到一个 break 语句，switch 终止，并且控制流跳转到跟着 switch 语句的下一行。 不是每一个 case 需要包含一个 break。如果没有出现 break，控制流将贯穿到后面的 case 直到 break 为止。 switch 语句可以有一个可选默认 case ，它必须出现在 switch 的结束处。在执行一项任务时没有任何 case 是真，那默认 case 可被使用。在默认 case 中不需要 break。 后记以上就是java的基本语法了。内容很少，不必记忆。下面一节，是面向对象编程的内容，是java中最核心的基本理论。好了看完就睡吧:）]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始看懂Java代码系列教程（综述篇）]]></title>
    <url>%2F2017%2F07%2F13%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9C%8B%E6%87%82Java%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E7%BB%BC%E8%BF%B0%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 要说精通Java是一件很难的事，但是单单是看懂也不是件容易的事。主要是因为当我们谈起java时都以为它只是一门语言。其实它已经是一个完整的系统和体系，包含了语言的语法特性之外的其他东西。比如面向对象（OOP）思想等等。于是乎里面出现了数量恐怖的新的概念，有一些仅仅知道就可以看懂代码有帮助，有的必须要学习透彻才能理解为什么这么写。（而有些看懂了之后，就会发现看什么代码都很low）。 所以这是一个很大的工程。我准备分开的书写。但是我却要说，这将会是一个简单的旅程，除了篇幅可能长一点点其他的阅读起来不会存在什么难度。（如果觉得难了或者简单请及时反馈） 教程结构和一些原因根据难度教程的顺序如下: 综述篇 就是这篇文章，讲一些Java的超级基础，一些概念和主流技术。 Java语言基础篇 使用快速的方法，平铺一些Java的语法，语法糖，语言特性。阅读时，可以超级快的简单扫一遍，之后可以当做手册来查询。 OOP面向对象 只讲简单的面向对象的知识和概念，其中大部分内容会是以选读的方式存在，毕竟这个教程的目的仅仅是看懂 看懂Spring框架 这个到了教程中最难的部分，可能也要分几个部分来讲。肯定会讲一些基本meavn的包管理方案等，还有mvc的概念等，所以到后来可能是几篇文章。 hibernate超速教程 hibernate是和数据库交流的东西，是一种对象关系映射（ORM）。先不要急，这些概念在文章中都会一一说明。这个文章，可能也有几篇。 从demo看代码 这里是一个检验学习成果的地方，你可以知道自己之前的知识学的怎么样，我会讲解一个项目示例。可能会谈一下，使用搜索引擎去解决技术问题的思路和技巧。 补遗 随时根据反馈来写一下知识点的剖析文章。或者技术小品。 好吧让我们来看看看综述篇的正文。 Java 的核心技术(泛读)JVM （Java虚拟机）你可以理解为专门执行Java字节码的计算机系统。也就是说java是一种跨平台的编程语言，即源代码一次编译成字节码过后可以在任何机器上执行。关于JVM有专门的一本书来讲，这里不必在意。仅仅知道概念即可。 GC （垃圾回收机制）JVM来回收申请的存储空间，和运行时缓存（注意这里和一般意义的缓存是不一样的）。也就是说开发者如果不是特殊情况不需要考虑new出来的对象什么时候释放掉。关于这个也有很多的技术细节，这里不讲，仅仅知道概念即可。 Java主流技术介绍Spring超级的主流技术，很快的统治了java世界的神级框架。Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。其中Ioc和AOP是两个复杂的概念，这里不会影响到代码的阅读。你以后的学习中将详细介绍。 dubbo神中的神，可以使用服务容器提供服务，配合zk（zookeeper）使用，实现分布式系统。这里将要介绍使用时的代码读法，而不介绍其实现细节和配置细节。 后记这是系列教程的目录，所以轻松阅读。完全不需要在意没有读懂的地方，我会慢慢讲清楚的。:)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新诗几首]]></title>
    <url>%2F2017%2F07%2F10%2F%E6%96%B0%E8%AF%97%E5%87%A0%E9%A6%96%2F</url>
    <content type="text"><![CDATA[前言 最近都有点忙了，其实今天也很忙。只是最近发生了一些事，所以觉得忙一点到没有什么不好。都是平时突然抽风写的东西，虽然不一定好但是还是记录下来吧。 每一个不曾起舞的日子，都是对生命的浪费1234不听山歌人不疯，既听仙乐舞如龙。闲来怒视西边日，醉卧徐徐东来风。 一天上班的时候，旭日东升。心情大好，于是作此诗。 流水不停歇12345逐渐离我远去的爱人我的信应该邮到哪里可是我知道无论顺境，逆境一切皆是，随波逐流 青春有几年？12345678910111213141516171819202122232425262728293031323334353637383940 塑料花我还在问镜子里的他有没有永不枯萎的花他仅仅沉默了一下说了或许吧他说着那朵花就好像可以紧紧抱着啊就好像它熬过了风和雨水的拍打春不会让它发芽秋也变不黄它不会消退的红色啊在心里生深深驻扎我还在问镜子里的他有没有不会凋谢的花他仅仅啜泣了一下说一定会有吧他拿着那朵花就害怕它被融化就好像一不小心就会弄丢了它它不需要阳光和露也结不出果实啊每当光打向他它都有点害怕我还在问镜子了的他要什么永不枯萎的花他仅仅犹豫了一下就马上崩溃了再怎么美丽花再怎么忧伤的枯萎啊现在也没有人在乎是真是假 突然的自信？12山河四海手中杯,鲲翔浅底鹏待飞。从来英雄出我辈,苍龙白马犹可追。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器调试工具教程]]></title>
    <url>%2F2017%2F07%2F04%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[声明 注意这是一个人向教程，内部全部知识资源来自网络。大部分内容来自前端大全，希望学习前端的同学去关注公众号去获取更多内容。本人仅仅对其中常用内容进行整理增删，所以请不要捐助这篇文章。在这里再次感谢原作者。谢谢。 OverView（总览）本文将介绍chrome浏览器的简单调试模式下的一些常用操作。（火狐下面的这些功能是类似，不过是位置不同。火狐需要插件支持，我将会提供插件的下载安装的教程） 我打开chrome或者火狐后按下F12后。就可以看到下面的画面，这就是chrome开发者工具面板。这些按钮的功能如下： Elements:查找网页源代码HTML中的任一元素,手动修改任一元素的属性和样式且能实时在浏览器里面得到反馈。 Console:记录开发者开发过程中的日志信息，且可以作为与JS进行交互的命令行Shell。 Sources:断点调试JS。 Network:从发起网页页面请求Request后分析HTTP请求后得到的各个请求资源信息（包括状态、资源类型、大小、所用时间等），可以根据这个进行网络性能优化。 Timeline/Performance:记录并分析在网站的生命周期内所发生的各类事件，以此可以提高网页的运行时间的性能。 Profiles/Memory:如果你需要Timeline所能提供的更多信息时，可以尝试一下Profiles,比如记录JS CPU执行时间细节、显示JS对象和相关的DOM节点的内存消耗、记录内存的分配细节。 Application:记录网站加载的所有资源信息，包括存储数据（Local Storage、Session Storage、IndexedDB、Web SQL、Cookies）、缓存数据、字体、图片、脚本、样式表等。 Security:判断当前网页是否安全。 Audits:对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化建议。比如列出所有没有用到的CSS文件等。 在chrome的不同版本中Timeline/Performance和Profiles/Memory是两组不同的命名，其实功能和内容是一样的。 Elements实时编辑DOM节点和CSS样式 你可以这里修改DOM中html标签的熟悉并且马上生效，比如你可以需改这篇博客中作者的名字。如同所示: 小窍门： 选中作者名字，可以使用调试工具左上角的小箭头选中，或者在elements中使用Control + f进行搜索 同样的道理这里可以修改其中的css来改变当前网页的样式，他们也会马上生效。你可以向下图一样试试修改当前这篇博客的背景颜色。我把它变成很好看的蓝色，你当然也可以把它变成黄色！ 点击右侧Computed面板，可以编辑左侧选中的盒子模型参数，所有的值都是可以修改的;点击不同的位置(top、bottom、left、right) 就可以修改元素的padding、border、margin属性值。(这个过于前端了不详细介绍了) 名称解释：DOM。因为全称是：Document Object Model。文件对象模型。这里的DOM常常指的是HTML DOM。HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法（接口）。换言之，HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准。这里你可以理解就是html元素在JavaScript中的一种标准表示方式，当你和前端沟通是使用dom这个词是很专业的。它的读音类似“道姆”。 查看本地css修改历史这个如果不是前端开发很少用到了，因为你关闭刚才的网页，你调试好的样式将都不符存在了。那怎么知道你修改的历史呢？现在就可以使用这个功能。 点击Styles面板中修改过属性的文件名，会跳转到Source面板 在文件位置右击选择Local modifications,可以查看本地的所有修改记录 点击指定的时间点可以看到粉红背景的删除内容和绿色背景的添加内容 Consoleconsole是chrom的命令行工具，可以打印在客户端js的打印指令。其实在我们使用elements的时候，这个命令行面板就在下方了。常用的打印指令有: console.log 显示一般的基本日志信息，当要显示的基本日志太多时可以使用console.group将相关的日志进行分组 console.warn 显示带有黄色小图标的警告信息 console.error 显示带有红色小图标的红色的错误信息你可以试验一下，看看打印出来的内容：这里在正常的测试中很少用到，除非你排查非常依赖前端环境的项目，比如Vuejs，react或者H5的动画或者游戏。这涉及到的调试技巧很复杂，所以我建议的做法是引导前端打印必要的值方便测和联调。 Sources这个可以看到你网站的源代码，更重要的是，你可以打断点调试代码。我们透过一个例子说明一下。这个博客中的图片都是在点击后可以放大的。这就要走一段js代码，你可以先自己试试，看看能不能找到他。 如果你没有找到可以继续，看下面的教程了。首先你可以看到我们要打开这个网站所有需要加载的文件（其实就是必须下载的文件）。当然如果你特别了解前端的代码的话就可以瞬间找到，你需要调试的地方，但是这样往往是不行的。于是乎我们可以使用事件断点，那什么是事件断点呢？ 在js中为浏览器元素预定义了一些经典的事件，当发生事件的时候浏览器就会进入一种等待状态，这样一个一个断点的打就可以再知道程序走了那个分支。好了，现在先这里打上断点，然后鼠标点击博客里任意的图片。如图：这个时候你会发现，怎么跑到了一个奇怪的文件里，不但文件只有一行而且，名字也很迷。哈哈，这个时候你就不要担心了，这说明，让图片放大显示是写在很经典的公共组件里面，而这样的组件为了考虑加载的速度进行了压缩，嗯。所以程序跑到了这里，往往错误都不是出现在这里的。现在观察下面的这张图。正常的情况下你可以在正常代码里打断点，然后取消事件断句继续调试。这里左边的三角会走一步，右边的三角会走到下一个断点。 NetWork概述Network面板可以记录页面上的网络请求的详情信息，从发起网页页面请求Request后分析HTTP请求后得到的各个请求资源信息（包括状态、资源类型、大小、所用时间、Request和Response等），可以根据这个进行网络性能优化。 我把Google官方网站上介绍Network面板的图贴到这里，该面板主要包括5大块窗格(Pane)： Controls 控制Network的外观和功能。 Filters 控制Requests Table具体显示哪些内容。 Overview 显示获取到资源的时间轴信息。 Requests Table 按资源获取的前后顺序显示所有获取到的资源信息，点击资源名可以查看该资源的详细信息。 Summary 显示总的请求数、数据传输量、加载时间信息。 请求列表各字段意义 Name 资源名称，点击名称可以查看资源的详情情况，包括Headers、Preview、Response、Cookies、Timing。 Status HTTP状态码。 Type 请求的资源MIME类型。 Initiator 标记请求是由哪个对象或进程发起的（请求源）。 Parser： 请求由Chrome的HTML解析器时发起的。 Redirect：请求是由HTTP页面重定向发起的。 Script：请求是由Script脚本发起的。 Other：请求是由其他进程发起的，比如用户点击一个链接跳转到另一个页面或者在地址栏输入URL地址。 Size 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源则该列会显示(from cache) Time 请求或下载的时间，从发起Request到获取到Response所用的总时间。 Timeline 显示所有网络请求的可视化瀑布流(时间状态轴)，点击时间轴，可以查看该请求的详细信息，点击列头则可以根据指定的字段可以排序。 查看DOMContentLoaded和load事件信息DOMContentLoaded和load这两个事件会高亮显示。 DOMContentLoaded事件会在页面上DOM完全加载并解析完毕之后触发，不会等待CSS、图片、子框架加载完成。 load事件会在页面上所有DOM、CSS、JS、图片完全加载完毕之后触发。 DOMContentLoaded事件在Overview上用一条蓝色竖线标记，并且在Summary以蓝色文字显示确切的时间。 load事件同样会在Overview和Requests Table上用一条红色竖线标记，在Summary也会以红色文字显示确切的时间。 查看具体资源的详情通过点击某个资源的Name可以查看该资源的详细信息，根据选择的资源类型显示的信息也不太一样，可能包括如下Tab信息： Headers 该资源的HTTP头信息。 Preview 根据你所选择的资源类型（JSON、图片、文本）显示相应的预览。 Response 显示HTTP的Response信息。 Cookies 显示资源HTTP的Request和Response过程中的Cookies信息。 Timing 显示资源在整个请求生命周期过程中各部分花费的时间。针对上面4个Tab进行详细讲解一下各个功能： 查看资源HTTP头信息在Headers标签里面可以看到HTTP Request URL、HTTP Method、Status Code、Remote Address等基本信息和详细的Response Headers 、Request Headers以及Query String Parameters或者Form Data等信息。 关于请求头部有很多的详细的介绍，请见传送门。关于这个我可能找一个时间单独写一份文档。（可能吧！） 查看资源预览信息在Preview标签里面可根据选择的资源类型（JSON、图片、文本、JS、CSS）显示相应的预览信息。下图显示的是当选择的资源是JSON格式时的预览信息。 查看资源HTTP的Response信息在Response标签里面可根据选择的资源类型（JSON、图片、文本、JS、CSS）显示相应资源的Response响应内容。下图显示的是当选择的资源是CSS格式时的响应内容。 查看资源Cookies信息如果选择的资源在Request和Response过程中存在Cookies信息，则Cookies标签会自动显示出来，在里面可以查看所有的Cookies信息。 分析资源在请求的生命周期内各部分时间花费信息在Timing标签中可以显示资源在整个请求生命周期过程中各部分时间花费信息，可能会涉及到如下过程的时间花费情况： Queuing 排队的时间花费。可能由于该请求被渲染引擎认为是优先级比较低的资源（图片）、服务器不可用、超过浏览器的并发请求的最大连接数（Chrome的最大并发连接数为6）. Stalled 从HTTP连接建立到请求能够被发出送出去(真正传输数据)之间的时间花费。包含用于处理代理的时间，如果有已经建立好的连接，这个时间还包括等待已建立连接被复用的时间。 Proxy Negotiation 与代理服务器连接的时间花费。 DNS Lookup 执行DNS查询的时间。网页上每一个新的域名都要经过一个DNS查询。第二次访问浏览器有缓存的话，则这个时间为0。 Initial Connection / Connecting 建立连接的时间花费，包含了TCP握手及重试时间。 SSL 完成SSL握手的时间花费。 Request sent 发起请求的时间。 Waiting (Time to first byte (TTFB)) 是最初的网络请求被发起到从服务器接收到第一个字节这段时间，它包含了TCP连接时间，发送HTTP请求时间和获得响应消息第一个字节的时间。 Content Download 获取Response响应数据的时间花费。 TTFB这个部分的时间花费如果超过200ms，则应该考虑对网络进行性能优化了，可以参见网络性能优化方案及里面的相关参考文档。 Timeline/PerformanceProfiles/MemorySecurityAudits 以上的四个面板使用的机会很少，这里不做详细的介绍，如果需要可以查看后面的源连接，里面都有详细的说明。 ApplicationApplication面板简介该面板主要是记录网站加载的所有资源信息，包括存储数据（Local Storage、Session Storage、IndexedDB、Web SQL、Cookies）、缓存数据、字体、图片、脚本、样式表等。 Local Storage 如果你在开发过程中使用了local storage来存储键值对(KVPs)，那么你就可以通过Local Storage窗格来检查、新增、修改、删除这个键值对。 Application Cache 你可以使用Application Cache窗格去查看通过Application Cache API创建的资源。 Frames 将页面上的资源按frame类别进行组织显示。Frames窗格 在上图中可以查看到顶级的top是一个主文档，在top下面是主文档的Fonts、Images、Scripts、Stylesheets等资源。最后一个就是主文件自身。 在资源上右击后在弹出菜单选择Reveal in Network Panel，就会跳转到Network面板并定位到该资源的位置。 其他连接安装火狐的调试工具 传送门 源链接 Chrome开发者工具详解(1) Chrome开发者工具详解(2) Chrome开发者工具详解(3) Chrome开发者工具详解(4) Chrome开发者工具详解(5)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始的PCA（主要成分分析）教程]]></title>
    <url>%2F2017%2F07%2F01%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PCA%EF%BC%88%E4%B8%BB%E8%A6%81%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%EF%BC%89%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言（阅读指南） 我准备写一个轻松的PCA算法的教程。传说中的零基础教程，也就是不用带特别多脑子去阅读的教程。不过有很好线性代数基础的同学可能会觉得我有点啰嗦。那些超级简单的内容请跳过去就好啦。 问题出发：如何给数据降维 现在我们都知道，PCA（主要成分分析）是一种可以把高纬度的数据降低到低纬的一种降维算法。他的英文全称Principal components analysis。当然你肯定不在乎，全称。我们知道在进行学习机器学习或者流形学习中，样本数据的特征值可能多到可怕(当然有的时候纬度太少可能啥也做不了)，那么这个时候做算法的科学家们就不开心了，这么多纬的样本数据老子玩不来啊。这尼玛算法收敛要几年啊，cpu吃不消。我就一台xp的PC，宝宝心里苦啊。 于是这群傲娇的科学家，就在思考这样一个问题，可以给数据降维吗？ 从经验中思考 辛辛苦苦发掘的特征值，你说降维就给我删除了，那怎么行呢？降维要基本法的。可是这样的规律是什么呢？我们先举一个有意思的例子，我要使用纯色的小球体模拟三维空间中的实体，我给出一组采样特征值你看看那个可以不要。（不要考虑这个想法有什么应用，我随便想的） 1(颜色rgb，灰度值，半径,球体表面积，球心坐标，球体密度分布，球体质量) “你给的特征啥子鬼呦！”知道了颜色的rgb不就可以模拟出他的灰度值吗！知道了半径，不就知道了表面积吗！知道了半径和密集分布不就知道了质量了吗！…… 等下！我们刚才的过程不就是一种降维吗！这里科学家有这更加深刻的体悟（一套自己的话语体系），他们使用什么词汇来描述呢？线性相关性。如果两个特征值的线性相关性越强，那么我们就越有把握把两个特征合并成一个特征。 那么从反面来看这个问题，我们要使降维后的数据越线性不相关越好，因为这样可以保留最多的源数据的信息。 你或许会开始问一个严肃的问题：怎么取衡量降维后的数据的线性相关程度？我们有数学工具方差。也就是说我们要使降维后的数据方差最大。 还记得方差吗？请先回忆起期望。一组数据的期望可以看成他们的平均值，然后方差可以反映数据到这个平均值的波动情况。现在我们要做的就是让这个波动保持最大。 从简单开始：二维到一维 那么我们不妨把先看看数据从二维下降到一维的情况。 我们的思路是这样的，在平面内过数据的中心点画一条直线，然后让数据向这条直线上投影，可以知道每个点的投影到中心点的距离，使用者个距离作为每个数据的新的坐标。这样就从二维下降到一维了。而且我们也可以计算这里新数据的方差了。 对于m个点的数据中心值，就是各个特征的平局值\frac{1}{m}\sum_{i=1}^m x_i 可是这样的话，计算有点复杂。我们对数据进行一波预处理，把他的中心点移动到原点。（这个过程叫做特征方差归一，或者均值归0化）这样做的好处是现在过原点做任何一条直线，现在投影到这个条直线上的新数据的均值（期望）是0了。这样计算就简单了许多。 如果用图像表示就像下面这样: 推广到高纬度 聪明的你发现了，在三维中我先移动中心点，然后在选取两条过原点的直线做投影就可以啦。那么从a维度下降到b维度，就可以都这么做了。 公式推导 现在有m个样本数据，每个数据有n个特征，即源数据维度为n维。现在要将数据下降到d维度。假设现在数据已经被我们均值化了，就是中心点已经移动到了原点。现在对我们来说最重要的就是求得出使新数据方差最大的那条直线的单位方向向量。（因为肯定过原点了嘛） 于是乎我们做投影表示数这当中一天直线上投影数据的方差。如下图。 其中$ x^{(i)} $表示的是第i个元素。 现在不难得出方差:(一会就知道我为什么要使用符号 $ \lambda $) \lambda = \frac{1}{m} \sum_{i=1}^m \big( {x^{(i)}}^T u \big)^2 在这里我们可以发现： {x^{(i)}}^T u = u^T x^{(i)} 现在仅仅把平方中的一个换成另外一个整理后就可以得到下面的公式了： \lambda = u^T \bigg( \frac{1}{m}\sum_{i=1}^{m} x^{(i)}{x^{(i)}}^T \bigg) u 中间那个大括号里面的是不是很熟悉呢？那现在我这样写呢： cov(X,X) = \frac{1}{m}\sum_{i=1}^{m} (x^{(i)}-0)(x^{(i)}-0)^T 哈哈现在发现了吧，由于我们移动了中心点，E（X）=0；那么原来公式中的大括号中的就是元素数据的本征协方差矩阵。注意这个矩阵是可以求的（而且是方阵）。现在我们令这一大坨为$ \sum $ 然后我们等式两边都去左乘u,然后就会得到： u\lambda = uu^T\sum u 由于u是单位方向向量，那么$uu^T=1$于是乎： u\lambda = \sum u石破天惊 看到上面的式子，真有一种石破天惊的感觉。我差一点哎呀的叫起来。这个不就是矩阵的特征值和特征向量吗！方差就是特征值，方向矩阵就是特征向量。更加诡异的来了。由于特征值的定义，这里面的特征向量是相互正交的。也就是说： 我们得到了一组符合条件的正交基 不知道你还有没有印象了。线性代数中正交变换，可以使用过渡矩阵，仅仅做一次矩阵间乘法就可以了。现在为了保证方差最大，我们仅仅要对得到的方差进行排序。然后降到几位就取前几个作为正交基就可以了。 到了这里没有什么好讲的了，都是线性代数书上已经写的很好的东西了。 后记 注意这里面降维后的数据，保留了一定的源数据信息，但是现在不能说原来的某个特征就到了某个新的维度上，仅仅是点有一对一的关系。 PCA算法可以说是出奇的优雅，核心思想过程很简单，推导也不需要很高的数学基础，不过要是没有学习过线性代数的话，不会突然有震撼感。真不知道，算法作者到底是从正交基想到了可以去降维，还是通过想要降维，推导到了线性代数里的正交基呢。也可能是两个思路同时进行，突然有一天一切都联通了。神奇了。 当然，最大方差不是唯一的解释这个算法的思路还有其他的解释。欢迎补充交流，指正错误 我将一直迷惑和无知，我是黄油香蕉君，再见]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>PCA</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的基因]]></title>
    <url>%2F2017%2F06%2F30%2F%E6%88%91%E7%9A%84%E5%9F%BA%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[前言 我知道我的人生到了最最迷惑的地方。如今我必须整理回顾自己所面临的种种可能，虽然看似没有必要。 上大学之前：热爱文学的少年 如果你问年少时的我，我将来可能从事的职业。我会毫不犹豫的回答是人民教师。因为这个和我的信仰有关。 关于人活着的意义，我曾经是有认真思考过的。我曾经认为是传承。是将自己的思想阅历和知识，传给下一代人。因为我曾经绝望的认为很多问题是我们这一代人所解决不了的。于是在放弃的时候，选择了有希望的一种。希望我可以告诉别人什么是人生。我是一个常常把人类这个词放在嘴边的人。写文章写小说也是，不喜欢使用表明了时代文化的事物，比如使用啤酒而不会写什么青岛纯生之类的。因为我曾经自负的认为自己的文字是站在更加长远的角度上去写的。等到后人读到我的文字时，这个两个品牌早就不存在了。 我那时喜欢读书，都是认为高雅的书才去读。我不知道什么时候养成了的极其虚伪的阅读习惯。网络文学，和爽文几乎不会碰的。这并不是说我真的高雅了，但也没有说我是低俗的。这是我的一个重要的问题，我一会再说。我之所以喜欢读书，看诗是因为，我超乎常人的脑洞能力。我常常可以看出书中文学所带来的超越生活的可能性。于是不知不觉的，发现生活的平庸。当然归根结底是我自己的平庸，只不过那个时候没有发现那一点。如果谈起我人生的种种改变，可以总结为一句话就是对平庸的抗争。 于是我逃到了书里的世界中，逃到了那些看似不平庸的文字里。我开始写小说，写散文，写诗写歌。不知算不算思想奇葩，我早就发现了生活中无意义的循环。并不是身边的朋友不好，而是我难以在那种生活了获得心灵的安慰感。于是我就游走在一种人类生活常态和一种出世清高的矛盾之中。这常常使我陷入尴尬的境地。更加令我尴尬的是，这样的我本来应该是个一成熟的，或者说是早熟的人，但是自己也知道自己出奇的幼稚。不过时至今日，我反而很承认自己的这种幼稚了。 我没有认真的生活，只是把看书当成了生活。然后出现了我人生中第一大悖论。那就是爱情。从书中经验，看到的爱情的样子，于是在常年的暗恋中暗示自己，自己有喜欢的人是一件美好的事。拥有完美爱情幻想是使自己在平庸下唯一不平庸的原因。这逻辑说不通对不对，可是一提到爱情，便不需要讲逻辑。这才是我生命中爱情诡异的地方。我试图用喜欢一个人来告诉自己不平庸。这个似乎没有什么问题。但是，曾经的我，似乎重来没有想过，词汇之下，男女朋友或者相处是怎么回事。于是乎，我仍然在自我欺骗中，安详度日。 可是我不愿意否定那段时间。原因是我要自己去定义它，没有人比我更有权力去定义。所以关于爱情是什么样子也是要我自己去寻找吧。 于是乎情爱的内心波动占据了我少年时代的大部分时光，其他时候，不过随波逐流。从来没有想过自己要变的优秀，因为实际上那时没有追求过任何一个人，所以不知道优秀才能被喜欢的朴实道理。以为自己不平凡就可以被喜欢，然后觉得有这么一个人可以看到你内心的世界理解你对于生命中矛盾的挣扎。选择相信和等待，都是一种任性的行为。 不过~~哈哈哈哈。还是要挣扎，这种感觉很微妙。 大学之后，辩论使我学会的 我很少做内心最深处，对自己进行严厉的拷问。我总是不敢想的透彻。想的多了往往是悲观的答案。于是我告诉自己一个原理，如今得出的答案的原因是因为自己认知不够。没有经历过生活，于是乎得出悲观的结论。只要随着时间的推移自我感受的成长，总会得到“正确的”答案。如今所谓正确不过是自己心里好受罢了。 初中时有一次自己，考虑到了死亡。并且和同学谈起了这个焦虑。忘了他们怎么安慰我的。我思考了很久，甚至失眠。 后来慢慢发现，累了就不会考虑这个问题了。和别人待在一起，就不会问这个问题了。 很遗憾，现在要讨论大学里的事，虽然过去时间不是特别的长。大学里对我影响最大的一项活动就是辩论了。当初之所以参加是觉得很适合自己。因为自己的思想中充满了矛盾。后来渐渐的对辩论本身有了一些自己的看法。这些按下不表。直接说说我在这个过程中学到的有趣的东西。 大学还是恋爱最好。 哈哈哈。这里说的是我关注的东西的转变。原来是通过书本看的文学的东西。后来大量的接触到的是社会科学的东西。还有心理学等等。于是心理之中渐渐产生了一定变化。是觉得自己变的卑微了。变的什么都不懂了，发现了自己的无知。然后是恐惧，对这个充满了无规律世界的恐惧。然后是对自己追求精神世界的疑问。于是第一次有这样的问题。我，要什么？ 我 ，要什么？ 我要意义。对！我希望我身边的一切都是有意义的。无论过程，无论结果。这是我拒绝平庸的一种平庸的方式。 但是这个概念太模糊了，并不能指导我自己去做什么。我只知道自己要与众生太同，但是还有隐藏好自己，免得被发现是个异类。这太难了。“一个人知道自己为什么而活，就可以忍受任何一种生活”。于是我曾经觉得，让其他人脱离社会中无意义的人生，有去追求自我的能力是最崇高的事业。曾经觉得可以奉献自己的一生的时间去思考答案。 可是我后来放弃了。原因很简单，不是每个人的人生都值得我去奋斗。不是我自私了，而是觉得人群很可怕，不屑于改变他们了。于是，我开始寻找了自我实现的价值。 讲道理，寻找的过程，无异于碰运气。或者说我开始尝试去理解我不曾理解的东西。可是效果不是特别的好。我在人文和社会科学中开始看的了可怕的不确定性。于是有逃到，自然科学和深奥理论的观察之中。 然后，在各种理论中发现了神性。这个过程，几乎使我放弃了唯物主义的基本思想。 我，就是神。神，就是我 现在说这句话，不是什么年少轻狂，或者自负的表现。而是怀着，深深不可知的神秘主义感的，淡淡感慨。原来“解救之道，就在其中”。 无神论者，使用过一个逻辑上的悖论来，证明神不存在。“神可以创造出一块他自己都聚不起来的石头吗！”答案是可以的。我来给你证明。 首先是数学。你会问，这和数学有什么关系吗？当然有。我们人，都可以理解数学中的观点，可是数学中的观点超出了我们认知的世界。这样的例子有很多，虽然你会说，数学和其他学科一样，不过是用来改造世界的工具，可是并不是所有的数学都可以这么直观被理解。比如超越数。比自然数都结束之后还要往后的数。首先你要想象一个无穷的过程才行。很神奇不是吗？我们都理解无穷这个词。 然后是音乐，想想，为什么不同波长频率的简谐波，在时间上的排列可以使我们产生情感。悲伤，或者，快乐，你和我两个无法衡量的个体都可以感受到。 每每看到，这些智慧和艺术的结晶。我就会感叹，我要找什么神呢？我就神啊。意义什么的，由我来定义就好了。 于是乎。我可以通过学习，和体悟来获得一些意义。这样就不是平凡或者高雅的问题。是我生命中内心深处的基本的渴望。对未知的渴望。对美的渴望。对自己求知的喜悦，和对自己可以审美，在美上拥有感受的自负。这些骄傲，是我生命中的本质，是像我渴望做爱一样的存在，在我骨子里，随我出生的东西。 但是，我浪费了好多时间。可是我在音乐和数学上很贫庸。你明白吗？这种感觉有点神奇。想想你是很爱花的人，但是却一朵也养不活。你仅仅有的天赋就是看到别人的天赋。那么是有点点孤独的感觉。 不过还好。神是我。我可以改变。可以去追求，去实现。可以看，可以去感悟。然后热泪盈眶。可以被别人误解，然后嘲笑，那群人。 然后，回归平凡。然后选择，平庸。对~ 我要坐穿平庸。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>自我介绍</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脑子是个好东西-证明R（3，3）=6]]></title>
    <url>%2F2017%2F06%2F28%2F%E8%84%91%E5%AD%90%E6%98%AF%E4%B8%AA%E5%A5%BD%E4%B8%9C%E8%A5%BF-%E8%AF%81%E6%98%8ER%EF%BC%883%EF%BC%8C3%EF%BC%89-6%2F</url>
    <content type="text"><![CDATA[前言 人类的智慧是无限的。当我看到了下面的证明之后我相信了这一点。希望你也可以体会到我所感受到的震撼。 命题 在6个人的聚会中，一定有三个人互相都认识，或者三个人互相都不认识。 现在想想怎么证明。或许你和我一样一开始想到的是条件概率，贝叶斯公式。这样也不是证明不出来，而是证明的方法显的暴力，和不用脑子。有一种极其优雅的证明。现在验证你是不是天才的时候来了，关掉这个博客，然后思考两天。对比一下你的证明方法。 两天之后 现在我可以解开谜底了。 我们现在来转换一下命题，看看他在等价命题是什么。首先有6个人，我们可以理解为6个ABCDEF。然后每两个人之间的关系使用连线表示，我们规定如果两个人认识，我们使用红线连接，如果两个人不认识使用蓝线连接。现在我们要证明的是6个点互相连线的图像，对边进行红蓝任意的上色，其图形中必然存在一个全色三角形。 好了！现在是不是觉得豁然开朗了呢？请开始你的证明吧。再给自己两天时间如果证明不出来，再来看看下面的结果。 又两天之后 证明: 现在考虑一个点和其他剩下5个点的关系。根据抽屉原理这5个点中必然有3个的边是同样颜色的。（关于这个你可以自己动手试试，或者试着推导，还可以百度哦！）于是我们把这个四个点抽象出来。令他们为abcd。如下如所示： 现在已经知道,ab,ac,ad都是一种颜色的，不妨令它为红。现在看看三角形bcd。发现如果其中一条边是红色的，那么图形中必然有一个全红的三角形。如果全都不是红色的，bcd就是一个全蓝的三角形。证明完毕！ More 同学，我们似乎是接触到了一门很有趣的知识。拉姆齐定理。这里有维基百科的传送门。这也是为什么我的标题中使用了R(3,3)的原因。 我将一直迷惑与无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>看书</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知行合一Mean-shift实现篇]]></title>
    <url>%2F2017%2F06%2F27%2F%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80Mean-shrift%E5%AE%9E%E7%8E%B0%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言 度过了理论篇，相信这篇你读起来会轻松很多。本文尝试使用mean shift算法对图像进行降噪。如果你对这个算法还不清楚建议阅读我写的上一篇文章。 环境和依赖 mac或者linux系统（win平台没有测试） g++ 和 cmake openCV cmake：这里有一个不错的传送门更多的内容请百度.openCV 的安装和下载请看传送门更多其他平台内容请百度。 直接看代码： 主文件设置成了test.cpp。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;highgui.h&gt;#include &lt;cv.h&gt;#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;using namespace cv;using namespace std;//获取某个点的收敛距离int getNewZ(Vec3f v1);//获取两个点间的距离float getDistance(Vec3f v1,Vec3f v2);// 启点 终点 =》 终点减起点Vec3f getNewVec(Vec3f v1,Vec3f v2);//计算两个向量的和Vec3f vecAdd(Vec3f v1,Vec3f v2);//获取一个点的平局向量Vec3f getargvec(Vec3f v);//多维球体半径 实验结果这个数字越大 图像越平滑float h = 10.0;//最终 收敛条件float m = 0.1;Mat src,dist;// 这里面的参数是图片地址int main(int argc,char ** argv) &#123; src = imread(argv[1],CV_LOAD_IMAGE_GRAYSCALE);//其实这里的取灰度图不是特别有必要了这里图片已经是Vec3b的三维量了。 cvNamedWindow("Image_show",1); imshow("Image_show",src); dist = src.clone(); //现在应该使用mean shirft算法对这个图片进行降噪 //对数据结构的测试代码 cout &lt;&lt; dist.channels() &lt;&lt; endl; cout &lt;&lt; dist.rows &lt;&lt; endl &lt;&lt; dist.cols &lt;&lt; endl; //128X128 for(int i=0;i &lt; dist.rows;i++)&#123; //uchar* data = src.ptr&lt;uchar&gt;(i); for(int j=0;j &lt; dist.cols;j++)&#123; Vec3f point = Vec3f((float)i,(float)j,(float)dist.at&lt;uchar&gt;(i,j)); int z = getNewZ(point); //cout &lt;&lt; z&lt;&lt;":"&lt;&lt; (int)dist.at&lt;uchar&gt;(i,j) &lt;&lt; endl; dist.at&lt;uchar&gt;(i,j) = z; // //todo 这里使用算法对dist进行改造 &#125; &#125; // cout&lt;&lt; dist.channels()&lt;&lt;endl; //把新图片打印出来 cvNamedWindow("new_Image",1); imshow("new_Image",dist); //保证程序不关闭 waitKey(0); return 0; &#125;float getDistance(Vec3f v1,Vec3f v2)&#123; float sum = pow(v1[0]-v2[0],2)+pow(v1[1]-v2[1],2)+pow(v1[2]-v2[2],2); //cout &lt;&lt; sqrt(sum) &lt;&lt;endl; return sqrt(sum);&#125;// 启点 终点 =》 终点减起点Vec3f getNewVec(Vec3f v1,Vec3f v2)&#123; return Vec3f(v2[0]-v1[0],v2[1]-v1[1],v2[2]-v1[2]);&#125;//计算两个向量的和Vec3f vecAdd(Vec3f v1,Vec3f v2)&#123; return Vec3f(v1[0]+v2[0],v1[1]+v2[1],v1[2]+v2[2]);&#125;int getNewZ(Vec3f v1)&#123; //根据 src h 确定 出循环查询的范围 //计算范围内点的 “平局向量的值” Vec3f argV,newV; argV = getargvec(v1); //使用m判断收敛条件 newV = vecAdd(v1,argV); if(getDistance(argV,Vec3f(0,0,0)) &lt;= m)&#123; return (int)newV[2]; &#125; //产生新的 递归 return getNewZ(newV);&#125;Vec3f getargvec(Vec3f v)&#123; //通过v 判断循环范围 floor 向下取整 ceil 向上取整 int x_start,x_end,y_start,y_end; x_start = v[0]-h &gt; 0 ? ceil(v[0]-h) : 0; x_end = v[0]+h &lt; src.rows ? floor(v[0]+h) : src.rows; y_start = v[1]-h &gt; 0 ? ceil(v[1]-h) : 0; y_end = v[1]+h &lt; src.cols ? floor(v[1]+h) : src.cols; //循环时使用 src 原始数据 Vec3f tmp = v; int k = 0; v = getNewVec(v,v); for(int i=x_start;i&lt;x_end;i++)&#123; for(int j=y_start;j&lt;y_end;j++)&#123; //现在判断这个点是不是在范围内 然后累加求和 Vec3f end_point = Vec3f(float(i),float(j),(float)src.at&lt;uchar&gt;(i,j)); Vec3f tmp2 = getNewVec(tmp,end_point); if(getDistance(Vec3f(0,0,0),tmp2) &lt;= h)&#123; //todo 这里的平均向量计算有问题 k++; v = vecAdd(v,tmp2); &#125; &#125; &#125; //偏移向量进行 衰减 if(k!=0)&#123; v = Vec3f(v[0]/(float)k,v[1]/(float)k,v[2]/(float)k); &#125; return v;&#125; 为了方便我先把cmake的配置文件先送上。一会在对代码进行解释。CMakeLists.txt如下： 123456789cmake_minimum_required(VERSION 2.8)PROJECT(Test) FIND_PACKAGE( OpenCV REQUIRED )INCLUDE_DIRECTORIES( $&#123;ShowImage_SOURCE_DIR&#125; )ADD_EXECUTABLE(Test test.cpp) TARGET_LINK_LIBRARIES (Test $&#123;OpenCV_LIBS&#125; ) 代码解释 要是看过之前理论篇的同学，不难理解，我要实现的的核函数对每个点的加权是一样的，没有越近就越大越远就越小。然后也没有使用自适应的步长。 我的大体思路是使用mean shift算法计算每个素点的收敛的值作为这个点新的灰度。这里面没有什么复杂的逻辑，所以很好理解。这里圆内判断条件，我进行了一定的优化使用正方形代替了圆进行计算。减少了循环的次数。 实验结果 这是我写的源代码git的传送门。欢迎学习的目的使用。:） 我将一直迷惑和无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>mean-shift</tag>
        <tag>c/c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知行合一Mean-shift算法理论篇]]></title>
    <url>%2F2017%2F06%2F25%2F%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80Mean-shrift%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E7%AF%87%2F</url>
    <content type="text"><![CDATA[总前言 以前在自学机器学习的时候，只是简单的看了一下思路然后就是跟着进行数学推到。至于从算法到实际实现总是存在一些距离。于是就有了自己写这样一系列文章的想法。就是把自己从知识到实践的过程记录下来。思考出一条从理论到实践的路径。这一直都是我非常想研究的。一篇文章或许看不出什么，不过我相信只要坚持这种工作，一定可以得出令人欣喜的答案来的。 简介 Mean shift 中文译名又叫做，均值漂移。在机器学习领域可以实现聚类，在图像领域可以实现目标追踪，和图像平滑。是一种应用很广的算法。接下来我将尝试使用通俗的语言，在不借助数学工具的情况下使你了解这个算法都做了什么。 算法思想二维空间 首先我们先假设一个任务。我们给出平面中的一组点，然后要求你根据这些点的信息，将空间分割开来。怎么分割呢？如果给你一只铅笔，你或许可以把这些点想象成天空中的星星，有的地方很密集，有的地方和稀疏，有的像星云的一部分，有的又像银河之类的一个尾巴。你可能凭感觉画出来了。但是这样的工作可以由机器自动完成吗？ 答案是可以，我们选取平面内的任意一个点，看看他周围已经存在的数据对这个点的影响是什么。然后通过这个影响移动这个点。然后在进行迭代，就可以得出这个点收敛的数据了。(收敛的条件当然是这个影响趋近与0) 额。听起来还是很抽象？看看下面的图片你就明白了。 首先先随便选取一个点X，然后画一个半径为h的圆。之后求在这个圆中(圆形内部)的点到X所构成的向量的和。我们称之为平均向量。 之后对X在平均向量上的方向和距离上进行平移。得到新的X。然后重复这个步骤。一直到它附近的点的平均向量为0，或者长度足够小。（小于我们设定的值） 注意,这个时候，如果你是要分割平面，你要想象许多的点，把平面内的位置都覆盖了，你会发现最后所有的点也就只收敛于几种值。如果你要对已经有了的点进行聚类，那么你就只需要把要分类（实际是聚类）的点都进行一次计算就可以了。（这里有个小技巧，理论上在计算过程中所有经过的点，和包裹到的周围的点都可以认为是一个类别里的，这样在一些时候可以大大减少计算的量。） 三维空间 如果二维空间内的点的移动方法和规律你已经理解了，那么不难推广到三维的空间中。这里只要把原来用于圈住周围点的圆，变为球体就可以了。下面我给你看一张在mean shirt论文里面在三维空间进行聚类的结果图。 怎样很神奇吧，这些3维空间中的点被分为了三类。现在闭上眼睛好好想象一下，这些点不断的画球移动然后停在一个点的过程。 推广到高维 和刚才过程一致。现在把球体，改成超球体即可。什么是超球体呢？你可以理解为无论从那个维度对他进行投影都是一个圆就可以了。不用强迫自己完全想象出来。 这里的描述不够准确，应该是说投影到任意的二维空间中是一个圆。投影到任意三维空间是球体。感谢。@申波同学的帮助。 公式推导 或许你觉得低维度下，很好思考和实现，但是数学家们，或者玩算法的人希望自己的算法是万能的。于是我们要借助数学工具对算法进行推导，和重新表述。不要害怕!这个和我刚才说的，并没有多大的不同。现在你要做的就是理解，每一个步骤，然后在不懂的地方停下来思考一下就行了。 基本形式 在给定的 $ d $ 维的空间 $ R^{d} $ 中有 $ n $ 个样本点。这样不难得出在空间中任意一个点的Mean shrift向量如下： M_h = \frac{1}{K} \sum_{x_i \in S_k} (x_i - x) 简单的解释一下这个公式。$ K $是指的是$ x $有$ K $个临近点。其中超球体$ S_k $的半径为$ h $,它的公式表示如下: S_h = \{ y:(y-x_i)_T(y-x_i) < h^2 \}使用核函数进行密度估计 首先我把这个密度估计的函数给出来:(注意这里面$ K() $是核函数) f(x) = \frac{1}{nh^d}\sum_{i=1}^nK(\frac{x-x_i}{h}) 你或许会问这个是什么玩意？我为啥要密度估计？还有你为啥知道密度估计是这公式呢？ 现在我们开始以二维的数据进行思考。想象一下一个平面上面有许多的点我们可以用(x,y)来表示。现在我们要通过平面内现有的点的疏密来获取平面上每个点的密度值。于是原来的（x,y）变成了（x,y,z）。他是一个表示平面内每一个点密度的曲面。就像下面这个图一样。 看到了这个密度曲线你是不是豁然开朗了。如果你还没有感觉，不妨想象一下把左边的那个“小山脉”倒置过来，就成了一个小漏斗。现在吧一个小球放在任意一个点上，小球滚动后，必然的停止在一个“小山”的“顶峰”。这就是模拟了上面“向量漂移”的动作。（使用模仿这个词不太恰当）哦!现在对这个密度函数求偏导数，然后命令其等于0就可以知道哪里是“山峰”了，因为“山峰”是平的。(偏导数应该为0) “等等，不要蒙我！”你或许会说。这里没有解释两点，1.为什么原来的点是离散的，现在就变成连续的曲面了呢？2.这里和核函数有什么关系呢？ 好吧。在求取偏导数之前。我来尝试解释一下这个问题，不过这里只不过是我的一种理解方式。首先一个离散的一维的点的密度怎么表示呢？我们知道点在总个数为N。于是我们不妨选取一段很小的距离h，然后看看在这段范围内有多少的点。假设有k个点。于是他的密度可以近似的表示为：$ p = \frac{k}{N} $,想象一下这里面h足够的小，然后我们可以得到这样的图像。 现在再想想$ \frac{k}{N} $是点出现的概率，并不是在真正的密度，思考在二维空间中，真正的密度应该是$ \frac{k}{NV}$ 其中V可以理解为一个以h为边长的正方形。我们便可以说这里的h是窗口的大小。 可是现在表示整个密度的函数似乎太麻烦了。那怎么办呢？我们设想一个辅助函数。让他有下面三个功能： 在窗口内有值，在窗口外没有值。 这个函数表现出离x越近对密度的结果影响越大，越远越小。 函数在各个方向上的影响是一致的。（对称的） 细心的读者或许会发现条件2其实包含了条件1。没有值可以理解为对结果的影响为0。 现在我们就给自己投机取巧的函数起名为K，于是就可以轻易表示出来在二维空间中的密度函数。 f(x) = \frac{1}{nh^2}\sum_{i=1}^nK(\frac{x-x_i}{h}) 这里我关于使用$ \frac{x-x_i}{h} $中的h是这样理解的。这的距离尺度是相对于窗口大小h的距离。而不是绝对距离。这在一维的空间可以理解为距离，而在二维就是一个向量了。所以这里的解释可能存在一定的问题。希望读者，有更好的解释可以，告诉我。谢谢您 :） 怎么样？现在这个公式是不是和之前的很像了。除了这里的是2维的d=2.现在推广到d维，就可以得到我们要的公式了。但是你仍然不满足：“你怎么知道有这样的函数K，正好满足你的种种变态要求呢？”。你别说还真有，而且还很多。 那他们张什么样呢？为什么又这些神奇的功效呢？了解更多请使用传送门。我可以先截一张图，让大家感受一下，这里不做过多的介绍了。 注意 这里有关于核函数的还有:传送门这个是介绍SVM（支持向机）中的核函数。但是我对于核函数的理解还不是很深。希望哪位朋友有相关论文或者文章推荐给我。万分感谢。 开始纯数学推导吧！ 首先要确定核函数的公式。 K(x) = c_{k,d}k(\|x\|^2) 将核函数代入到原来的密度估计公式，然后求梯度得到$ \nabla f(x) $。之后令$ \nabla f(x) = 0 $这是接上面提到的大体的思路。 \nabla f(x) = \frac{2c_{k,d}}{nh^{d+2}}\sum_{i=1}^n(x_i-x)g\big( \big\|\frac{x-x_i}{h}\big\|^2\big) 其中$ g(s) = -k’(s) $。这里来简单的理解一下，注意这里我们求的是密度估计函数的梯度，于是这里反应的是梯度下降的最快方向了。那么我们仔细观察上面这个公式，是不是有点意思了！ \frac{2c_{k,d}}{nh^{d+2}} 不过是一个常数，我们先忽略他。然后看看 \sum_{i=1}^n(x_i-x) 是不是突然想哭出来？这个不就是那个各个点到x的向量和吗！ g\big( \big\|\frac{x-x_i}{h}\big\|^2\big) 一看就更加的亲切了，这个不就保证了在窗口h内有值在窗口h外对梯度下降的影响是零吗！更加神奇的是你发现里x越近的点在对$ (x_i-x) $这个向量的加权越大（特别在高斯核下,在别的核下可能加权是一样的）。 现在回忆一下前文，我是不是说过的“模仿”一词不准确？对，这里是向量的漂移模仿了，梯度函数求极值点的过程。而且正好描述的是在核函数影响下窗口大小h内点权重一致的情况。 现在我们知道了我们要在$ \nabla f(x) $下求极值点。那就可以使用最传统的方法，求出一个点的梯度，然后按照梯度的方向移动一段距离，再继续求梯度。重复这个过程，一直到求出的梯度趋近于0。现在便知道了这个方向是:在窗口h内的点到x所构成的向量的加权和。看看我们终于回到了最初的定义了！ 但是向这个方向移动多少呢？步子迈大了容易扯到蛋（移动过了，然后来回摆动永远不收敛），步子迈小了收敛速度太慢了。那么可不可以让在它在离收敛点远的地方，步子大一点，接近了极值点，步子就小一点呢？ 答案是：当然可以！ 自适应步长 我们在来回顾一下，这个公式。请始终记住他表示的是密度函数的梯度。下降最快的方向。 \nabla f(x) = \frac{2c_{k,d}}{nh^{d+2}}\sum_{i=1}^n(x_i-x)g\big( \big\|\frac{x-x_i}{h}\big\|^2\big) 现在对这个公式进行一定的整理。后得到： \nabla f(x) = \frac{2c_{k,d}}{nh_{d+2}} \bigg[ \sum_{i=1}^n g \bigg( \bigg\|\frac{x-x_i}{h}\bigg\|^2\bigg) \bigg] \bigg[ \frac{\sum_{i=1}^n x_i g\big( \big\| \frac{x-x_i}{h}\big\|^2\big)}{\sum_{i=1}^n g\big( \big\| \frac{x-x_i}{h}\big\|^2\big)}-x \bigg] 没看出来怎么推导出这部的同学请来看 ： 关于这个公式很多的同学表示很头大，但是如果你看完我的介绍，可能会吐血哭出来。这个就是简单的分数运算。首先把$ x-x_i $和后面的一大坨乘开。然后在每一项在除以那一大坨。在外面乘以那一大坨。就是这个公式了。 关键的地方来了。注意理解这个公式。现在我们令$ G(x) = c_{g,d}g(| x |^2)$,那么这时第二项，就变成了对于新核函数G(x)进行的密度估计。好！停下来思考两秒钟。 那么这个第二项就是一个大于0的数了。于是乎我们令第三项为$m_h$。仔细思考一下这个$m_h$就是我们要的自适应的步长。 m_h(x) = \frac{\sum_{i=1}^n x_i g\big( \big\| \frac{x-x_i}{h}\big\|^2\big)}{\sum_{i=1}^n g\big( \big\| \frac{x-x_i}{h}\big\|^2\big)}-x 思考一下你会发现，由于第一项和第二项是一个数不对这个梯度变为0提供贡献，所以这一项可以提供梯度下降的方向。然后我们看到 \sum_{i=1}^n g\big( \big\| \frac{x-x_i}{h}\big\|^2\big) 是核函数密度的估计，以高斯核为例，这里原来的密度估计完全一致。也就是说，这里的$m_h$和原来的密度估计成反比，这样就做到了密度大的地方，他的倒数就小。密度小的地方他的倒数就大。 于是反应到步长上就是，离模点（极值点）远的地方，步长大，近的地方步长小。 x' = x + m_h(x) 这个就是可以使用算法迭代的最终公式。顺便提一句这里$m_h$就是人们口中的mean shift向量了。 写在最后 终于完成了。不知道你理解了没有。我没有读过研究生，或有专业老师的指导，如果有什么错误，欢迎指正。感谢你的阅读。 我将一直的迷惑和无知，我黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>mean-shift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2017%2F06%2F23%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[新的开始我决定使用hexo开始新的博客整理。虽然可以开始很大的工作是整理以前的博客进行很多的迁移。 测试测试图片 测试公式e^{it} = cost + sinit测试代码1234#include &lt;stdio.h&gt;void main()&#123; print("Hello Wrold!");&#125;]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾遗录14]]></title>
    <url>%2F2017%2F05%2F29%2F%E6%8B%BE%E9%81%97%E5%BD%9514%2F</url>
    <content type="text"><![CDATA[写在前面 来看看从来没有谈过恋爱的人，写的分手诗。看来，想象力最重要了。 诗 曾经 曾经的曾经 我们似乎在一起 我微笑的脸 看你静静的睡去 伤心的时候 你哭红了鼻 为你逝去泪水 给你取暖的外衣 你美美的眼神 快乐又神秘 开心的舞蹈 欢乐的谜语 不能忘记你 梦里的奶油 都是你 不得不注意 你的喜与怒 小秘密 我们在一起 就这样没有任何说明 就这样的在一起 没有任何约定 我们在一起 共享一件大衣 分享一份甜蜜 你在我的左边 戴上我的眼镜 数天上的繁星 你说你要像月亮一样 永远美丽 我说我就成为天上的一颗星 当你手里的水晶 月光澄澈透明 记录少年的痴情 星辰散乱心情 做最好的证明 曾经的曾经 只不过是曾经 所有的真诚 在一瞬间离去 我努力去牵你苍白的手 你紧缩的手臂打碎了我的心 我留着泪问 为何离去，放弃过去 你不作答语 只是静静消失，留我一个人伤心流涕 曾经是多么美丽 现实让我无语 我曾给你的宽容，你当做撒娇的武器 你留下来的温存，是一种剧毒的药剂 这一切一定是一场游戏 我只不过是一个玩具 那么一切不过一个骗局 爱的越少，痛的越轻 爱~~~~~~ 你到底有没有真谛 爱与被爱者谁有权力 我宁愿永远只是遥远的曾经 我是颗流星 只不过望着月亮 默默的 足矣！]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>拾遗录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取知识的方法]]></title>
    <url>%2F2017%2F05%2F18%2F%E8%8E%B7%E5%8F%96%E7%9F%A5%E8%AF%86%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[OverView 在这篇文章中我将讨论获取知识的方法。注意，这里面大部分是我个人经验之谈，既有可以视为理论的东西，也有一些很实际的方法。现在这个阶段我不大乐意与将这两者在文章中分的很细。原因是我没有这个思考的力气。很无耻的理由是吧，我也是这样认为的。所以我将在以后的时候不是直接成文，而是先写一个草稿然后在整理一次的。（注意我也不知道这样做是否有效果） 什么是知识？为什么要获取他 额~关于第一个问题我觉的以我现在的知识没有办法回答你。不过如果你在认真读我的文章，我建议你一直去思考这个问题。然后对照我所说的，如果觉得不适用的，选择性阅读。为什么建议你这样的去阅读呢？因为我自己曾被那些半吊子结论的文章坑苦了。明明结论的正确性不敢用100%的把握（实际上几乎都不能）却言之凿凿。这样就相当于学习了错误的知识，是不可取的。但是不读可能又会失去其中隐含的某种有用的信息，怎么办呢？我的建议是不要太关注这个问题。不然你生活中有太多这样的问题要求解决了。 好了。现在看一眼第二个问题，为什么要去获取知识。既然已经饥不择食到了读我这篇文章，这个问题就显得有些愚蠢了。这仿佛就像在舞台上突然问另外一个演员为什么要表演一样可笑。有什么理由吗？没有。就是一个行为，没有为什么！关心的人想怎么定义都可以。可我想提醒你的是：认真想一下可能某个获取知识的过程就不需要了。这听上去有些难以理解。比如说你正在上网查询女孩子喜欢的口红的品牌，在学习相处的心理学，在思考怎么讲一个让人发笑的笑话。我可怜的朋友，你想获取的不是知识是她的心。然而要知道，没有知识可以描述的。所以我建议你打个电话而已 所以这个问题，正常情况下没有讨论的必要，一旦讨论起来，非要弄个很重大的改变不得。为了保险起见我这里提起，以便于你在获取知识的过程中，可以想一下。嗯，通常就一下下 怎么开始的？ 我先从我的历史讲起。开始我几乎和所有人一样，上学。其实正确的严谨的说从娘胎就开始了。不过我更希望从上学这件事开始说起。 上课，看书，做题，考试反馈。然后以此循环。不得不说，这是一个我能见过比较完成的获取知识的循环了。似乎很完整。不过不就知识获取的范畴而言，可能你会对这样的形式存在某种情感。这件事很有趣，我们对某种形式存在情感和情绪倾向。甚至我在写这段文字的时候都会尽力避免我的情绪对这其描述产生不公正性，可见其中情绪作用的巨大。 但是准确的说，我们那时候怎么开始获取知识的？看书？那我们为什么看书，为什么听课呢？这又是一个无法回忆起的问题。因为我没有什么可靠的印象来表明了。所以关于这部分的归因，我选择放弃。 然后是现在。我从上大学开始后的一段时间的自学开始说起。嗯，很多是与课程无关的东西。有些东西我自己都惊讶于我知道这个有什么用。所以到这里你应该明白了我想讲的是什么了。 怎么满足自己的好奇心。 问题开始，刨根问底 为什么+任何一件事。就是一次探索的开始。但是我往往是从怎样做开始的。而已常常是一个很模糊的想法。 比方说我在思考，如何把我大学的课程表读到我的手机里然后提醒我，或者读取我喜欢的人在社交平台上的信息来判断她对我的态度，在比如有些深奥的问题:我有没有自由的意识。等等~ 这些问题其实我都没有解决过。但是我却可以开始了。你或许会说，开始算什么呢，这没有什么了不起的。我亲爱的朋友都读到这里了，我想请你相信我并没有什么好炫耀的。而且我说的仅仅是开始。那么这里的开始是什么意思呢？那就这个读取课程表来说。我一想到问题就知道应该查阅那些资料来解决。而且这些涉及的领域是很清晰的。 因为课程表在学校的网站上都有，所以要学习简单的web知识，html，cookie什么的。 这里要抓取内容所以需要一点爬虫的知识。要得到准确的内容要了解正则表达式，或者XPath。 因为要在手机端所以要学习Android编程，要学习java。因为要获取html的返回值要了解java 网络请求的东西。 我上面描述的内容在我一听到这个问题的时候就可以想到了，对,这就是我说的开始。只要了解了上面那些知识点就可以完成这个作品，这个开始就在你的想法和实现中间搭了一座桥。可是事实是我们大多数人，在有一个想法后是没有这样一条路的。那么恭喜你了，你将要学习到新的知识了。 拿第二个想法举例，我没先假设自己能获取到你喜欢的女孩的社交数据，比如她和你还有别人的聊天记录什么的。那么怎么判断你和她的关系呢？ 这时你有两条路可以走。一：直接读，看看她是不是和谁说过喜欢我，或者喜欢他人。可是这样做其实可能是徒劳的。因为可能她比较含蓄，没有直接说喜不喜欢什么的。聊天中都是和你一样的平常的内容，日常还有一些笑话。这时你要借助一个已经有了的解释模式来分析，她的语言内容。听上去很怪？其实就是心理学分析了。但是使用怎样的理论分析呢？这时你发现你要学习一点心理学基础知识。 心理学基础知识怎么学？额~问自己认识的学心理学的哥们吧。于是你穿上睡衣拿着电话去天台联系你许久没有联系的老同学，在一阵寒暄过后，你直接切入正题，怎么学心理学。这时他可能惊讶于你的问题“学心理学干嘛？我和你讲很坑的，就业都…………”巴拉巴拉一堆。你自行忽略然后他就开始兴致勃勃的讲起心理学的分支和基本概念。终于讲到了比如“行为主义”，“恋爱心理学分析”等你最想听见的字眼。于是你们聊的很开心，他推荐了一本书开始学习。你买了书发现里面有许多你不懂的词汇。于是你百度，发现了在心理学下包含了“实证主义”哲学和方法论。你沉迷里一段时间回到，心理学上。并开始简单的验证你周围的世界。发现可以使用书中的知识自洽，于是你读完了朋友推荐的教程，不满足于此开始去知网上看更多的论文。 上面是第一条路。现在是第二条。你发现数据量太多了自己读完要花上个两天两夜。你读了她和朋友经常说“嗯”但是和你却常常回复“哦”。天才的你觉得这有问题，却不知道怎么办。你在思考是不是词汇出现频率反应了什么。于是你开始在百度上查询数据分析。于是发现了数据挖掘和大数据这个概念。你读了几篇吹牛的文章，发现都在讨论机器学习和人工智能。于是你开始简单的接触机器学习的概念。你惊喜的发现，这个问题可能是机器学习的一个分类问题，领域有很接近自然语言处理。于是你开始查找要学习的视频，发现了吴恩达老师的网易公开课。于是你开始拿着手机在吃饭上厕所的时间学习。机器学习有很多的数据公式，于是你翻出来高数，线性代数，概率书来。某个深夜你在为自己终于弄懂了马尔科夫链感到惊喜。你学的很努力但是效果甚微，学了很久才学到支持向量机。于是你准备一次实践。额~但是没有样本数据怎么办？我上铺的哥们就不错，要不我先介绍给她做男朋友，这样数据就有了。嗯没毛病。 这种情况下由于问题涉及一个更深的领域无法马上解决，但是却可以学习到跟多的东西。但是还有种情况如我最后一个例子:自由意识是否可能。这个似乎是一个哲学问题，就更加缥缈了。只能每天想着，偶尔有了关联在进行关联性的思考。比如了解到了拉普拉斯妖，然后发现可以证明其不存在。然后发现了量子力学的一些性质。然后就思考到意识和物质的问题。又回到了本源论，于是要思考可知论与不可知论。终于到了神性和人性上面来。这些都可以百度。但是思考在这种问题下终于程度很高~ 我想说什么 现在我想说的是，这个过程很有趣，可是很孤独。而且由于没有很好基础知识很容易走弯路。 所以我在问，学习的本质是什么？知行？]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>看书</tag>
        <tag>思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[荒原]]></title>
    <url>%2F2017%2F05%2F11%2F%E8%8D%92%E5%8E%9F%2F</url>
    <content type="text"><![CDATA[没有用的前言 去年过年回家，哈尔滨下的飞机，做大巴回的大庆。没想到那时我竟然有这么有趣的文章。 荒原 那是我在回家过年的路上。在哈尔滨到大庆的高速公路两边，有一片荒原。我叫他哈大荒原。 在视线里荒原一直蔓延，似乎没有尽头。白色的雪，黑色的霾，远处淡紫色的天上，一颗冬日之阳在下降。我坐在大巴车里，寻找荒原中活着的生物。一排排整齐的杨树，一排排从我眼前飞过。树干笔直不牵连，树枝交叉在一起，偶尔还有鸟窝。 冬阳继续下降，像是燃烧殆尽的火星，在空中缓慢下落。我能想象它沉到雪中熄灭的声音。是啊。荒原熄灭一切，不留情面。一眼望去是，是被雪掩埋的希望。荒原是静谧的，是神秘的，是绝望的。望着荒原就是望着绝望。 它无声息的带走看着他的人的希望。我数不出来，在荒原上北风吹灭了多少的热情。有没有旅人走到这里就回头了？这里是“吃人”荒原，偶尔可以看到坟头和花圈。这就是我生活在北方的荒原。我想象着走在这个荒原了的样子。我害怕我我无论要走多远，都要回到原点。因为它就是这样冷峻的，不动声色的见证着一切。他仿佛又一种神秘的力量吸引着我的注视。就好像有一天我会踏上这个荒原。然后陷在里面，在明年的开春变成一朵小黄花。之后被羊误食，变成羊粪，被土壤吸收。长出草来，再被野火烧成了灰。被雪掩埋。被人遗忘。 这就是荒原，哈大荒原。离我出生很近的地方。里我生活很远的地方。我好奇的地方，我恐惧的地方。危险的荒原，安静的荒原。 那晚我做梦了。梦见一匹火红色的马，在荒原奔驰。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis教程]]></title>
    <url>%2F2017%2F05%2F08%2FRedis%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[OverView正文。 小贴士：这里将对正文中的某些词汇进行解释。 扩展： 这里是作者建议的内容，和编程方面的延伸。可以跳过阅读。 示例：这里是帮助读者理解而写的示例。 注意 提示读者需要注意的事项。 理论篇什么是Redis？[1] REmote DIctionary Server(Redis) 是一个由SalvatoreSanfilippo写的key-value(键值对)存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。[详细见表一]它通常被称为数据结构服务器，因为值（value）可以是字符串(String), 哈希(Map), 列表(list), 集合(sets) 和有序集合(sorted sets)等类型。 小贴士：[2]Redis中的数据类型哈希（Map hashmap）：散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。列表（list）：列表是一种数据项构成的有限序列,即按照一定的线性顺序,排列而成的数据项的集合。（redis中使用双向链表实现）集合（sets）：和中学时学习的概念是相似的。特点是集合中元素不能重复是唯一的。切内部是无序的有序集合（sorted sets）：也是一种集合，但是内部数据是经过排序的。 示例： 比如使用json表示： 哈希表：{key1:value1,key2:value2, ... ,keyn:valuen} 在这里的key和value是一一对应的关系，而且是函数关系。也就是说，key1 ... keyn 都是唯一的。 列表：[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;e&#39;]。注意这里的&#39;a&#39;是可以重复的这个在列表中是允许的，而且这里的顺序是不能变的，一旦顺序变了就不是同一个列表了。 集合：{v1,v2, ... ,vn}。这里v1到vn都是唯一的。也就是说{a,a}不是一个集合。这里集合的顺序是无关的，于是{a,b}和{b,a}在概念上可以视为一个集合 有序集合:{1,2,3, ... ,n} 这里1到n当然是不能重复的。其次他中元素是按照某种规则排序的。比如大小等。一旦顺序不一致在其中也不视为同一个有序集合了。 注意 在引用列表中的[2]连接中有更加详细的说明。为了方便阅读可以跳过但是建议在适当是时候阅读它。 特点和优势特点 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 小贴士：publish/subscribe ：订阅发布模式。阅发布模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。他是设计模式中的一种。Redis支持了这种模式。阅读了解更多订阅发布模式[3]订阅发布模式介绍。或者看有关Redis下订阅发布模式的支持[4]。 实践篇安装Rediswindows[5] 下载地址 Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择。 注意 操作系统位数可以在我的电脑中的右键属性中看到。如果不知道就试试64位。Redis版本要最好和公司生产环境使用的发行版本一直，保证bug与问题可以重现。 压缩包到 C 盘，解压后，将文件夹重新命名为 redis。(当然不安装到c盘也是允许的) 打开一个 cmd 窗口 使用cd命令切换目录到 C:\redis 运行 redis-server.exe redis.windows.conf 。 123$ cd c:/redis$ redis-server.exe redis.windows.conf## 这里的 redis.windows.conf 是Redis启动的配置文件 当这里不输入时 默认使用这个配置打开Redis服务。 如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的配置。 如果运行成功了。会出现和下面大致相似的返回。 简单解释一下Port是端口。PID是进程号。 注意 服务启动后命令行不能关闭。 扩展：即使在windows下任然有比较好的终端解决方案。可以下载git使用git 的bash。或者直接使用docker。在docker中启动Redis或许是最优雅的解决方案。不过我个人建议开发的话换成macOS。 MacOS1$ brew install redis 搞定了！ 命令行注意 在类unix系统中，redis-cli是作为一个命令存在的。它的作用是启动一个与Redis的交互的命令行模式。Windows用户要双击redis-cli.exe 可执行文件进入，这里是下面命令执行的前提。 创建键（key）使用set key value的方法就可以建立一组键值对了。比如: 1set zzh goodboy 这里zzh就被设置成了goodboy了。这里在此运行set命令可以把key zzh设置成其他的值，可以自己试试。 获取key使用get key可以得到key被设置的value的值。 使用dump key可以得到序列化后的value的值。 使用 exists key可以查询key是否存在。 删除key使用del key删除key 重命名keyRENAME key newkey 将key改为newkey 的名字。如果newkey存在的话，则newkey的内容会丢失。RENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey. 设置过期时间 这里的的key-value有类似于缓存的机制可以在一定时间过后自动的消亡。所以可以设置过期时间。 EXPIRE key seconds为给定 key 设置过期时间。时间为秒。 EXPIREAT key timestampEXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。 PEXPIRE key milliseconds设置 key 的过期时间以毫秒计。 PEXPIREAT key milliseconds-timestamp设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 PERSIST key移除 key 的过期时间，key 将持久保持。 查询过期时间 PTTL key 以毫秒为单位返回 key 的剩余的过期时间。 TTL key以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。 查询key KEYS params可以用keys加上查询条件的方式。比如我要查询所有以aba开头的key。 1keys aba* 实用工具介绍接下来将要介绍使用RedisDesktopManager(以下简称RDM) 使用教程。RDM是一款开源的redis管理GUI。 下载安装。 下载地址 连接服务器 点击新建连接。让rdm新建一个到服务器的连接 填写选项。点击完成。 name: 连接的名称，自己取的不会影响连接的属性，尽量起有意义的值，比如环境，开发环境还是测试环境可以用dev和test表示。host: redis服务启动的ip地址或者域名。本机可以是localhost或者172.0.0.1。建议使用域名的方式，这样修改host的域名配置节省大量时间。port: redis 服务启动的端口号。Auth：获取权限的秘钥。可以理解登录的密码。本地服务启动时默认没有密码可不填。其他环境需要联系管理员获取。 在某个库下新建key 选中某一个库，右键，选择新建key。 在新建中可以写key的类型和key的值。 查询key 一样的选择一个库比如db0然后右键有一个筛选。(filter 英文为过滤器) 现在他会提示输入一个’regex’。也就是说他支持正则表达式查询。这里可以先理解为正常关键字查询即可。 查完完你会发现列表中key变少了。怎么办？同样选择库右键，有一个还原筛选即可调回所有的key。 扩展：regex 正则表达式。是一种通用的计算机技术。甚至可以专门拿一本书来学。它可以实现文本中的模式配置。比如以xx开头，以xx结尾。以xx开头但是不包含yy结尾。以字母开头，以数字结尾。这些你能想到的模式都可以表示出来。学习正则是一个庞大的工程。建议在使用时查询规则来尝试。先学习其最基本的语法.[7] 修改删除操作 选中一个key在其右侧就有一系列的操作方法。如下图： redis + DB 的讨论 现在一般应用已经放弃了menchace+DB的组合而投身到redis+DB的阵营中来。特别是那种缓存需求量特别大，切需要管理的应用。 首先redis具有缓存的性质。key-value存在内存中读写速度快，而且可以设置消亡时间，这都符合一个缓存的要求。 但是memchae和redis不同，一断电，一重启，所有的键值对都将消失。redis则可以优雅的继续正常工作，因为redis提供了数据持久化的解决方案。要知道在缓存服务器重启的一瞬间，请求key的IO对数据库的压力是恐怖的。那么这里为什么说到了数据库呢？这一般与redis到DB的二层结构有关。 我们模拟一个应用场景。一个webapp要调用用户的基本信息。但是由于一开始的公司发展原因，用户的基本信息不一张表里面，甚至不在一个库里面。比如要调取用户的购买的会员要走支付和crm的接口。这两个还算正常的，有的情况下一个信息接口要调用7、8个部门，而且算下来有10个sql之多。这样一个接口的速度可能慢的夸张。更要命的是，这样的接口一开始数据变化是比较大的，但是一旦用户成为长期用户这些信息将很少改变。可是使用这样接口的场景却非常的多。怎么办呢？ 一般（以java或者php举例）情况下，程序员使用缓存的办法来解决。当有人第一次请求这个接口的时候，执行sql查询数据库。现在将查出来的数据放在缓存中（比如Redis服务中）。现在有意思了，在第二次请求的时候，程序会先检查key是否存在，如果存在，直接获取value就可以了。这样非常快，因为数据在内存中。这样大大的提高的应用的速度，减少了数据库IO的压力。 那么你或许会问如果数据改变了呢？这样读出来的缓存中的value和数据库中的数据不是不一致了吗？对这就是一种bug。一般可以手动的删除key。让程序在请求的时候重新走sql获取值，生成新key就可以了。或者更彻底的方法是在开发内部形成一套缓存key的生成规范，在修改数据的时候，使用程序删除key就可以了。 扩展：上面的例子包含一个通用的知识—分布式设计。使用多级缓存的方式只不过是其中很小的一部分。不过这是架构师的研究范围。这里有一片非常简短的基础的博文的介绍.[8] 这里还设计到了两个常用的概念。颗粒度和命中率。 颗粒度指的是一个key对应value所包含内容的大小，是一个相对的概念。比如一个key缓存了一整个网页，的颗粒度要比访问只缓存了数据段的颗粒度要大。在保证命中率高的情况下，我们希望颗粒度尽量的大一些，这证明了，资源的利用效率比较高。那么命中率是什么呢？指的是单位时间内请求同一个key的次数。 考虑这样一个问题：数据a一分钟被请求10次，b被请求1000次。那么单独的为两个数据设置key就是合理的。如果使用hashmap为两数据设置联合的缓存可能就浪费了请求数据时IO的性能。 注意！然而一般情况下对性能的影响不是特别大，如果请求次数不上到一定级别的话（但是讲道理到了一定数量级了，性能瓶颈就不由程序员这样解决了）是没有多大差别的。 本文使用是叫做markdown的语法写成的。这里有其教程[9] 引用表 [1] Redis基础介绍 [2]Redis中的数据类型 [3]订阅发布模式介绍 [4]Redis下订阅发布模式的支持 [5]Window下的安装教程 [6]RedisDesktopManager官方使用手册 [7]正则表达式基本语法 [8]初认分布式知识 [9]markdown语法教程 附录：表1：Redis 支持的语言表 ActionScript C C++ C# Clojure Common Lisp Dart Erlang Go Haskell Haxe Io Java Node.js Lua Objective-C Perl PHP Pure Data Python R Ruby Scala Smalltalk Tcl 配置文件参数说明: redis.conf 配置项说明如下： 1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no 2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定(这个会和操作系统有关) pidfile /var/run/redis.pid 3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 6379 4. 绑定的主机地址 bind 127.0.0.1 5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 300 6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose 7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout 8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id databases 16 9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save &lt;seconds&gt; &lt;changes&gt; Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes 11. 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb 12. 指定本地数据库存放目录 dir ./ 13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof &lt;masterip&gt; &lt;masterport&gt; 14. 当master服务设置了密码保护时，slav服务连接master的密码 masterauth &lt;master-password&gt; 15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭 requirepass foobared 16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 128 17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory &lt;bytes&gt; 18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no 19. 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof 20. 指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec 21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no 22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap 23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 0 24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 32 25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 134217728 26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 4 27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes 28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 512 29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes 30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf 我将一直的无知与迷惑，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node黑魔法使用js打开终端并运行命令]]></title>
    <url>%2F2017%2F05%2F02%2Fnode%E9%BB%91%E9%AD%94%E6%B3%95%E4%BD%BF%E7%94%A8js%E6%89%93%E5%BC%80%E7%BB%88%E7%AB%AF%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[OverView 在编程的魔法世界中，有许多的黑魔法，其中最黑的几种肯定有js了。特别是接触到了nodejs和npm后。顿时觉得无所不能，拥有了触及全世界的力量。在这篇文章中，你将看到使用js打开一个终端并且让他运行指定的命令的方法。 预备知识node 运行终端命令 使用一个叫做shelljs的命令就可以了。送上传送门。请翻墙！ OSX 中的open命令 使用这个命令可以打开一个应用。比如打开一个叫做Abc的应用。（没有这个应用的）使用$ open -a Abc就可以了。 通过这些预备知识几乎就可完成这项任务了。你想到了吗。不看下面。自己试试 :) 思路 在js中有一些可以运行命令行的方法。但是似乎没有那种可以打开一个终端，然后让打开的终端运行一组命令的方法。我有向别人请教，如何实现。不过反馈中更多是建议我写一个假终端，这个思路也很酷。不过我不相信有js做不到的事。 使用shelljs运行生成一个shell命令行文件使用 echo &gt;&gt; run.sh \#/bin/sh code就可以。 同样使用shelljs 运行一个命令 给刚才的文件加上运行权限 使用shelljs运行open命令用终端打开这个文件。 （optional）结束时删除。 代码 比如我们现在要想写一个查询本地docker下运行容器，并用按钮打开的应用。要求是在容易列表的没一项有进入容器的按钮可以打开新命令行进入到容器里面。下面是一部分代码。 1234567891011121314var shell = require('shelljs');//这里要下载shell插件module.export = &#123; open:function(name)&#123; //生成run.sh脚本 var comd = 'echo &gt;&gt; run.sh \#/bin/sh docker start '+name+'\n docker attach '+name; shell.exrc(comd,&#123;silent:true&#125;); //给脚本增加运行权限 shell.exec('chmod +x run.sh',&#123;silent:true&#125;); //打开运行 shell.exec('open -a Terminal run.sh'); &#125;&#125;//其他代码省略 我将一直的无知与迷惑，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>js</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用spacemacs订阅新闻组]]></title>
    <url>%2F2017%2F05%2F01%2F%E4%BD%BF%E7%94%A8spacemacs%E8%AE%A2%E9%98%85%E6%96%B0%E9%97%BB%E7%BB%84%2F</url>
    <content type="text"><![CDATA[OverView 本教程针对于spacemacs用户书写。看吧，如果你和我都在emacs阵营，真的会推荐给你很多好玩的东西。接下来你将看到如果配置使用spacemacs中的一个插件来获取新闻组。 开始配置 进入spacemacs然后使用快捷键SPC-h-SPC后键入我们要使用的layer的名字，叫做elfeed。如果你英文足够好，现在可以自己完成一切了。 如果你不会不要担心。很简单只需要两部。 1.在你的配置文件的layer中写好配置像是下面这样 12345678(elfeed :variables elfeed-feeds '(("https://emacs-china.org/latest.rss" emacs) ("http://zzhcoding.coding.me/atom.xml" zhouzihao) ("https://www.zhihu.com/rss" 知乎) ("http://songshuhui.net/feed" 松鼠科学会) ("http://www.geekpark.net/rss" 极客公园) ("http://feed.cnblogs.com/blog/u/62514/rss" 个体博客) )) 2.你可以清楚的看到我都订阅了一些什么。现在重新启动emacs 然后使用快捷键SPC-a-f就可以看到一个什么都没有的界面。使用快捷键gr更新就可以开始的阅读了。 新的问题 现在的问题就是怎么才能找到好玩的，有用的rss了。这个问题相信一定难不到大家，使用百度谷歌都可以。说实话这种看新闻的方式有一定复古，但是比起广告多起的app这个真的算的上是天堂了。 (现在发现使用这个layer读取新闻的时候存在突然卡顿的现象，所以这个不是最佳的解决方案，一旦发现了我一定会在第一时间共享粗来的。) 问题解决补充 卡顿的问题可能是由于在加载图片时造成的。这里在论坛中的大神建议关闭图片加载。这会对eww加载图片有所影响。不过好在我使用的是3wm插件来浏览网页。所以问题不大。配置代码如下:1(setq shr-inhibit-images t) 我将一直的无知与迷惑，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>spacemacs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用js导出Excel文档]]></title>
    <url>%2F2017%2F05%2F01%2F%E4%BD%BF%E7%94%A8js%E5%AF%BC%E5%87%BAExcel%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[OverView 最近研究了一下js中一个导出数据到Excel的模块。发现国内竟然没有人翻译。而小学弟学妹们听见导出Excel什么的，更是闻虎色变。其实没那么难。今天香蕉君就翻译一下。原文地址传送门。注意下面都是我这个英语渣的翻译，如果发现了错误欢迎指出。 翻译之前再啰嗦几句 安装node使用npm下载依赖。（真不知道我在担心些什么） 使用 excel-export 在传入到execute 方法前设置好‘设置’对象的值。如果你想生成多个“工作表”（译者加：就是Excel下方那个可以切换的地方也有叫做sheet的）,那么建立一个对象数组即可。或者你可以直接传对象就会在一个“工作表中” 使用name属性可以给这个“工作表”命名。 使用clos是一个给纵列定义属性的数组。纵列的定义需要caption名称和type类型两个必须字段，和宽度可选字段。宽度是字符的。[1]属性中还可是定义一个叫做beforeCellWrite的回调函数。这函数有row（行），cell data（单元数据），option object（配置对象）（一会再说）三个形参。返回值就是填充这个单元的真正数据。（译者加：明显这是为了方便预处理）。支持的类型有：string（字符串），date（日期），bool（逻辑）和 number（数值）类型。 使用rows表示要被导出的数据。它是数组的数组。它的每个数组长度要和clos一致。 表格的样式是可选的。然而如果你使用表格样式，那么一个有效的样式xml文件是必须的。一个简单的方法获取这样的文件的方法是‘unzip’[2]一个包含你想要样式的Excel并把样式文件复制出来使用。使用stylesXmlFile属性赋值来使用。了解更多样式请百度。呵呵。 eOpt(配置对象)在刚才说的回调函数中包含行和列的信息。eOpt.styleIndex应该是一个从0开的的所以，表示选择传入样式文件中表示单元格样式的标签。eOpt.cellType默认情况下是和之前定义好的type是保持一致的。然而在特定的应用场景下你也可以修改他。 [1] 原文这里是 The unit for width property is character。但是看代码这里似乎是一个数字类型。 [2] ‘unzip’是什么操作？解压？这里不知道怎么翻译。也不知道怎么从其中导出样式文件。如果知道的希望告知，谢谢。 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var express = require('express');var nodeExcel = require('excel-export');var app = express();app.get('/Excel', function(req, res)&#123; var conf =&#123;&#125;; conf.stylesXmlFile = "styles.xml"; conf.name = "mysheet"; conf.cols = [&#123; caption:'string', type:'string', beforeCellWrite:function(row, cellData)&#123; return cellData.toUpperCase(); &#125;, width:28.7109375 &#125;,&#123; caption:'date', type:'date', beforeCellWrite:function()&#123; var originDate = new Date(Date.UTC(1899,11,30)); return function(row, cellData, eOpt)&#123; if (eOpt.rowNum%2)&#123; eOpt.styleIndex = 1; &#125; else&#123; eOpt.styleIndex = 2; &#125; if (cellData === null)&#123; eOpt.cellType = 'string'; return 'N/A'; &#125; else return (cellData - originDate) / (24 * 60 * 60 * 1000); &#125; &#125;() &#125;,&#123; caption:'bool', type:'bool' &#125;,&#123; caption:'number', type:'number' &#125;]; conf.rows = [ ['pi', new Date(Date.UTC(2013, 4, 1)), true, 3.14], ["e", new Date(2012, 4, 1), false, 2.7182], ["M&amp;M&lt;&gt;'", new Date(Date.UTC(2013, 6, 9)), false, 1.61803], ["null date", null, true, 1.414] ]; var result = nodeExcel.execute(conf); res.setHeader('Content-Type', 'application/vnd.openxmlformats'); res.setHeader("Content-Disposition", "attachment; filename=" + "Report.xlsx"); res.end(result, 'binary');&#125;);app.listen(3000);console.log('Listening on port 3000'); 鸣谢 最后再次感谢这个模块的作者。functionscope。谢谢你的工作，真的很棒。 finally，thanks to the author functionscope.greate work,Really Inspiring！ 我将一直的无知与迷惑，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦话]]></title>
    <url>%2F2017%2F04%2F25%2F%E6%A2%A6%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[不必要的前言 最近由于一个机缘巧合，我开始思考一些与我并不相干的问题。主要是失眠的情况下，用来打发时间的思想流。其中充满了唯心的悲观看法。于是我定义这些接近于梦话。如果我不失眠了，这种状况或许要少一些。 什么是社会 首先，社会是一个集合的概念。简单的说一个人不能叫社会，只有许多人才叫社会。不严谨的定义，是有着密切关系的人类的和称。可以毫不疑惑的说，我就在社会中。但是我从未思考过，什么才是社会，这个概念的本质是什么？ 那么这里不得不提的就是关系，这里有许多组的相互关系。在社会中人和人的关系，人和社会中物质材料的关系。还有社会中的个体和社会的关系。可以说无关系不社会。但是我不认为关系是社会的本质。不认为一定数量的人和人关系的网络就可以定义成社会。当然这个定义可以在几乎所有的情况下成立。而已只要你说出一个具有一定数量的人的群体，并且存在某种关系网络在这个群体中，就可以称之为社会。比如我们常常说什么是一个小社会，这肯定了其具有了社会应该具有的全部性质。 可是要指出这不能说明社会的成因。至少是我直管感受下社会的成因。我们甚至可以说一个蚁群是一个社会。但是这里我们可以直管的理解到不是我们的社会。也不是我这里说的社会。我说的是特指人类社会。这里讲的不是人类文明，因为我对文明这词本身存在一定的怀疑。我说讨论的是我们所处的，可以感知的社会。就是我生活的社会这一概念。这个充满了问题的社会。也是这样的一个巨大的客观的实体才有讨论的价值。 先谈存在 要解决社会是什么的问题，要先解决存在的问题。即存在和本质的先后。我是倾向于存在先与本质。那就是我们在社会中并没有什么终极使命，换句话说没有什么是我一出生就必须承担的事和责任。无论是理想还是抱负，都是后天的赋值。存在没有道理。如果你非要将因果叫做道理，那么我可以说任何一个在成“果”之后，便和这个“因”毫无关系。这里并不悲观，这样我们在有为自己赋值的空间。这样灵魂才是自由的，虽然荒诞但是是纯粹自由的。可是我们看到的结果是我们的生活往往不是这样的。我们常常为一些事情所烦恼。我称之为“身份枷锁”。 这里的身份枷锁就是，社会关系对人个体赋值的结果。你是一位喜欢探险的人，希望去远处爬山，但是你不能这么做，你还有老婆孩子要养活，于是你很快的放弃了这个念头。你的身份被赋值为“父亲”。身份枷锁并不能对一个人起实际的作用。也就是说他的身份是“父亲”“丈夫”并不能阻止，他的想法和行为。实际上因为人灵魂自由的伴随存在而来的，所以没哟有效的方法让人不去想。但是真正阻止行为的也是“想”，担心也是想的一种吧。这里是担心别人的评价。没有人希望在别人的评价体系里别看低。 那是评价吗？ 社会的本质是由评价系统建立的身份枷锁？这样说似乎给评价这个词太多的价值和作用。人是具有理性的，我们不会对单单的一个评价就选择行动或者不行动。虽然有的时候是一种评价的预期对我们在社会中的行为做指导。但是有的时候这种指导又是没有效果的。可见这样描绘的社会图景是不完全的，不本质的。在评价的背后一定还有一层更深的原因，或者逻辑本源。只是仅仅现在描绘出的社会图景就不能让人乐观。 讨论赋值的来源 这里我不禁怀疑起来，所谓的身份枷锁的赋值行为有一个更加本质的逻辑传统。要讨论着种本质就要分析我们身份枷锁的来源。 上面的例子中枷锁来自后天的社会契约，在中国这个社会中（至少在这里）是有八卦式的评论系统进行维持。但是我们知道不是所有的枷锁都来自于此。比如法律是由国家暴力机关进行维持的。但是这样就很难解释一些社会行为。比如爱国者对在国内对其他国家车辆的破坏行为。在比如大街上殴打小三而无人报警制止。（当天这件事实的成因或许更加的复杂）这些行为单单使用身份枷锁是很难解决的。因为身份枷锁是一种制约，是在社会中存在的人不去做某些决策的原因。但是不能成为其不理性行为和不利己行为的原因。于是乎我要面临的一个首要问题是：在社会中，人在追求评价升级的情况下，为什么会做出损人不利己的行为？我觉得这个问题比起，在利己的社会下，做出利他行为更加的有意义。当然后面这个问题有人研究过。不过大致的结论还是利己的，是某种“利己”。或许是这种利他可以提升他的评价，或者给与其心灵上的安慰，是唯心上的一种自我加强。这里不过多的讨论了。 这里我们先把身份枷锁进行一定的抽象。他可以约束人的行为，但是是被动的，不大可能是产生某种积极（这里是主动）行为的诱因。也就是我是一名警察不太可能是我欺负一个素不相识的流浪汉的原因。但是这件事确实是发生过的。虽然不是中国的社会。那么是什么使我们轻易的中伤他人呢？ 是分类行为。 这是我认为社会之所以具有今天这个形态的全部逻辑来源。有点类似的叫做贴标签。不同的是标签是某些特定的属性，而分类着可能默认包含了一组属性。这种分类带来的后果是可怕的。比如在学校中分班后，所谓好班和坏班。在比如学校中存在的好学校坏学校。这种分类的行为其实是我们在做任何一个决策时必然发生的社会心理过程。又是是显示的，想想他和我是不是一个利益集团。有的时候又是隐式的，比如爱国行为。 这个解释了一切，我们在倾向性的分类，在某种语境下，把自己和某些具体共同利益和性质或历史记忆的人分为一类，然后无成本的迫害剥削不属于自己一类的人。 绝望的结论 这里我深深对这种人类的分类行为提出批判。这使我不禁想到了中国传统的大同的概念与齐物论。发现在中国传统观念中有对于这种社会形态倾向的批判。不过我仍然对这些思想持保留态度。因为我们有研究过这些古老思想，在当时的社会出发点和我今天描述的问题是否一样。这使我怀疑我在思考过程中是不是在刻意的异化社会这个概念。先看看现在社会的定义。 社会是自然人在数量一定多的集合中，使用分类排他的决策方式派生出关系网络而形成的动态平衡。所谓法律与道德，是平衡下的妥协产物。是一种终极评价系统，这套系统要不由由社会独立出来的团体强制或者社会中每个来自觉维护。 如果这样可以看出所谓的是舆论，不过是这个评价体系中的一部分，而不是什么公权力。道德的本质使人怀疑和警惕。一个公共事件发生，由于当今信息社会的特点，人们更加倾向于对非自己分类的个体给与低评价，而给与自己类别高评价。由于网络的虚拟性，这个评价不在需要成本，或许网民中有些个体根本不把任何其他网名当做同类。于是乎社会出现了种种问题。没有了理性，没有了实用角度，原因很简单，那样的成本过高，并且被别人分为异类的概率太高了。 比如一个人觉得不能怎么怎么样要做一个正义的人，那么久有人告诉他不要这样做。为什么呢？一个看似正确的言论变成不正常的了？这里我要强调我不对任何这种争论发表真实看法。我本质觉得这种情况是没有讨论的必要的。为什么这么觉得我有时间在讨论。单单说这里，原来看似不正确的言论会有人支持。其实道理很简单，我觉得可以借用沉默的螺旋的思路来解释，结合我说的分类原理。原来这种看似分类人数少的类别在信息自由化的今天，大家发现原来与我同类别的人这么多，于是敢于说话了，于是乎慢慢的抢占了主流。 我这说的绝望是什么意思呢？难道我觉得现在因为坏人越来越多了，那按照这样社会会按照坏人的分类体系发展。如果你这么以为就太小看我的害怕了。对于所谓好坏我是不去这样判断的。我说过存在先与本质，于是分类的选择是一种正常的行为，一种理性的行为，于是乎不在好与坏，而在于特定语境的争夺。这里关键的是语境，语境是分类的要素，而好与坏是对应语境下的。对于利益相关方，有必要烦恼于此。我是不会在意的。我在意的是： 分类行为是怎么的？ 我尝试进行价值判断，是正常的还是异化的。然后我仔细的想了想，把正常这两个字写的老大了，在我那块小黑板上。每天早上起床晚上睡觉前都看一眼想一想。然后不得不承认是正常的。是再正常不过了。甚至“分类”代表着理性。分类是我们认识世界的根本方法。 理性带来的非理性 这仿佛是一个悖论。一直萦绕在我脑海里，我不断思考为什么会这样？其实我没在认识世界的时候有一个行为就是概念区分，举一个简单的例子来说，我们知道是非知道黑白一样。是概念的区分，其实也是对客观事物的分类行为。一旦我们在认识事物的时候完成了概念的区分，事物自然的完成了分类过程。如果你不是什么事都模棱两可的话，当你认识事物的时候，当你自认为清晰概念的时候，其实是在曲解了概念。 可是不区分概念，那么我们怎么认知呢？高级的认知更是向概念细化的程度发展，可是这种人类自以为神性的，先验的理性，结果是一定的非理性，不~更加直白的表述是必然的非理性。我陷入了迷思，要么批评理性本身？可是要知道这种批判本身就带有所谓理性的分析方式和逻辑出发点。如果批判成立，即可马上对批判的理性过程进行否定，即批判不成立。那么肯定这种非理性，即分类的思考方式是可以肯定的，是正常的，是合法的，是一般性的。于是由此派生出来的种种问题，是随机的结果。是不确定什么时间发送的必然？没有办法从根本上解决社会中分类行为，和所带来的问题？ 如果是这样一切竟然可以自洽。分类是我认识事物的继承性结果，是正常的概念记忆方式，与逻辑习惯。于是分类决定一个人的评价体系和评价逻辑。由于利益平衡人们自觉维护这套体系。在社会运动和历史继承中，评价标准处于暂时平衡出现法律和道德，于是乎，基于当前集体中个体的职能分工，人被身份枷锁赋值。 这里任何一个环节如果主观意志与这套逻辑链中的既定历史结果出现了冲突，就会出现矛盾。从心理学角度看可能叫做心理不健康，甚至是变态。从法律角度看可能是某种犯罪。利益共享者可能觉得他疯了。利益冲突者可能觉得他道德败坏。无关者更倾向于负面评价或者娱乐化。 但是这一切的一切都是正常的。社会这个概念天然排除主观的独立判断结果。或者说，它不影响，不过是一个尺度，用来给这主观的个人行为下定义，作为给出的概念区分的判断标准。分类是一个人由出生到社会中生成的内因和联系。评价则是维持这种联系的行为。 我本来对这套东西的批判，但是却不得不得出这个是社会之所以是社会的必然条件。这不得不让我有些沮丧，问题根源出现在哪里？ 再次回到不可知 我害怕回到相信不可知论，和命运论的思考中。因为在哪里有一个有神论的结局在向我招手，或者说一个精神病人在想你们招手。这的思考没有答案而且很容易循环自证。不然我有的想有关意义本是是什么的问题想几天睡不着觉。可是这不是找寻答案的态度。于是我不得不重新审视不可知的世界。 我姑且认为世界是可知的吧。我们知道了很大的星星，和很小的夸克。但是我是怎么知道的呢？有些是看有些是靠计算。有些只存在我们脑海中，但是我们可以行动去验证去演绎。可是我们怎么表述我们知道了呢？说出来？写下来。用什么工具？语言？文字？符号？我写下来了，于是我记录了我的观察，可是这个概念清晰了？他就描述了我的想法？只可意会不能言传，那你还说出来！ 所以我们能正常的交流，真是一个奇迹。 或者说这件事，重来没有发生过。一千个读者有一千个哈莫雷特。一万个人类，就有一万个“人类”。我说要你拿杯水的时候，你拿了水给我，不过是水的巧合的映射到那个物体上了。或者说，我在说的时候都不知道我具体是要什么！一想到这里我浑身都起鸡皮疙瘩。灵魂交流一开始解释一个不存在的概念。是个概念的概念。 由此意义成了被定义。（完了~又到了意义）因为我不知道，所以当我说出来的时候它才存在。可是存在不是先与本质吗？不然唯物的世界就说不清了。 我与社会的关系 由此我没有了结论。这次的思考混乱不堪。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾遗录13早期的非主流风格]]></title>
    <url>%2F2017%2F04%2F23%2F%E6%8B%BE%E9%81%97%E5%BD%9513%E6%97%A9%E6%9C%9F%E7%9A%84%E9%9D%9E%E4%B8%BB%E6%B5%81%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[写在前面 唯一是我自己迷惑的我最早期的诗是下面这种有点非主流风格。而为啥要这样用词？额………… 我不记得了。 诗123456789101112131415161718192021222324无题雨后屋檐琉璃夏的心田绯色莲荷花盛开在池塘之前连心草，思念滑动，难以团圆彻底忘记不如不去怀念两幅画只待一个人，失望出线怎么是当初写下的诺言彩虹岸边风吹动，令人浮想联翩水中波纹散闲月，无法安详入眠十字结，记录 心中动情语言回首间繁华似梦 又是三年 解 当然有点形散神不散的意思。可是诗中主题依旧晦涩难懂。诗中描述画面色彩太过油腻，颜色用的太甜了。额最后一段简直是各种毕业晚会的百搭词。而且每段单独拿出来叫诗都有人信。可能本人梦游写的吧，哈哈。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>拾遗录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾遗录12]]></title>
    <url>%2F2017%2F04%2F23%2F%E6%8B%BE%E9%81%97%E5%BD%9512%2F</url>
    <content type="text"><![CDATA[写在前面 不好意思好久都没有更新了，实在是因为上班太忙了最近。不过这个系列看的人应该是不多。是我个人向的作品集。最近工作不是特别的好，常常不在状态。也没有时间学习新的技术，所以以至于技术分享也没有更新，这个实在遗憾。 今天熬夜于是可以继续填这个坑，而且我正在构思拾遗录中的小说部分怎么写比较好。这是个很难的问题，肯定不能一句句的分析，要是大概讲一下情节也没啥情节，要是重新整理一章章的重写，估计我这每晚都不用睡觉了。想想无论如何都很麻烦，但是要做。不过还有一些诗没有整理，一切看心情吧。一些很莫名奇妙的作品（比如歌词什么的），我准备专门都写在一起啥解说也没有那种。算是用这种方法都拾了。 花语的胡言乱语 诗 花语 风笛好像百灵鸟 沙漏不停的颠倒 幸福像一株水藻 轻轻的，慢慢摇 枫树染红一片天 流水代替了时间 送你一袋薰衣草 香香的，清清散掉 花卉丛中你欢笑 花圃上空彩云飘 写首诗，邮给你 这种告白好不好 你的衣裙字花间奔跑 花瓣沾到了我的长袍 我浅浅的吻你的嘴角 就这样相恋好不好 你害羞的挪动着双脚 说你喜欢紫罗兰的俊俏 我温柔的捋顺你的发梢 聆听你百合般的心跳 丁香花如此奇妙 以至于我们都没有准备好 跪在栀子花面前祈祷 时间停止好不好 但你离开的好早好早 玫瑰花还没有开好 杜鹃花已经逃跑 待你一朵回来--华妙！ 解 意义不明。最后一个词是我造的。意思自己猜吧。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>拾遗录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾遗录11]]></title>
    <url>%2F2017%2F04%2F15%2F%E6%8B%BE%E9%81%97%E5%BD%9511%2F</url>
    <content type="text"><![CDATA[曾经我最难熬的日子 没有人可以预见未来和自己的命运。 所以无论发生了什么，无论他多么的荒诞多么的不讲道理。我所能做的，不过是默默承受。 曾经我不知道生命的意义，现在我也一样的迷惑。 那是三月的一个早晨。没有可以看见的雨。是层层水汽。刚上了一节最早的课，实在是待不下去了，于是乎逃了出来。场景十分戏剧我往宿舍走，其他人向三教走去。 雾气很快的弄湿了我的头发，模糊了我的眼镜。“一切都很糟糕”那时我想。父亲突然去世了。自己在学校的一切都不是很在意了。有些人知道这个消息，然后和我一样伪装出日常，只是很小心。我害怕被人知道我伤心，于是要时不时的开心一点。不过与我来说都是有点难度的事。 我从三教逆着人潮，走过体育馆，走到女生宿舍的那面墙前。墙由上而下垂下了的绿瀑上开着小黄花，冷风出来，依然开放。我记得那天是3月2号。山城已是开花的季节但是仍旧寒冷。小黄花伴着花季之名，于白雾的清晨，成群开放。 于是哽咽 12已是三月花季，风中仍留寒意。秋风藏在花里，开出一阵叹息。 有些痛苦隐藏在欢笑中。那时候我应该哭出来就会好些吧。但是却偏偏倔强着，自尊着没有。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>拾遗录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾遗录10好久]]></title>
    <url>%2F2017%2F04%2F05%2F%E6%8B%BE%E9%81%97%E5%BD%9510%E5%A5%BD%E4%B9%85%2F</url>
    <content type="text"><![CDATA[写在前面 额，回顾我的现代诗集，大部分是初中时代的作品。内容多是言情（好吧我全部的作品都言情。）情绪都是伤心（好吧我全部的作品都伤心）。这首是最最伤心的。 诗1234567891011121314151617181920212223242526好久，好久一个人傻站在街头望着路灯，好久，好久站到洁白从天而降发现自己等了，好久，好久无意间发觉花瓶没有水了才知道花死了，好久，好久打开手机的记录之后知道自己孤单了，好久，好久莫名的感觉或许来了，好久，好久自己竟然偷看她的微笑不知不觉，好久，好久当安于现状突然发现幸福离开了，好久，好久我看不到她的双鬓随风轻摆了，好久，好久当一年之后，我们如同路人但感动停留过，好久，好久不过，当本不该来的又本不该离开时我偷偷哭了，好久，好久]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>拾遗录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾遗录9]]></title>
    <url>%2F2017%2F04%2F04%2F%E6%8B%BE%E9%81%97%E5%BD%959%2F</url>
    <content type="text"><![CDATA[写在前面 大家好。由于清明节有事情，所以没有按时更新。但是我也知道没有什么人看这个系列。哈哈哈。没事儿。反正也没有人看，我这几句就瞎写了。哈哈哈。这次回大庆终于把我的现代诗的小册子带到重庆了。可以开始现代诗了。这次不用解说了哈哈哈。 诗123456789101112131415161718192021222324252627282930313233343536373839404142434445日访吸血鬼残喘了一千年的灵魂终于有了一丝体温沾满鲜血的嘴唇也由泪水去滋润是谁给他施下封印阵逼他去读赎罪文欺骗自己不能结婚无法去爱那个人吸血鬼就是这样阳光下留着温存蓝色的人类眼神去捕获猎物的唇被上帝抛弃的人却找到新的女神亲吻着她的长发放弃嗜血的单纯残喘了一千年的灵魂只等待着她的吻放纵黑夜的污与混熟悉了十字架上的咒文吸血鬼还是这样月光下逃避猎人渐渐失去理智只为饱餐一顿被青春遗忘的人回忆中带着悔恨那双喋血之手再度推开地狱之门残喘了一千年的灵魂因为爱去伤害爱人他那唯一的邪恶吸血后无辜的眼神是谁推动了命运的齿轮使他相信世上的神欺骗自己也是人贪痴与她一起生存虚假的恋人…… 本诗创作与初中。是听过五月天的《夜访吸血鬼》后所做。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>拾遗录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中阶黑魔法教程-使用PlantUML画关系图]]></title>
    <url>%2F2017%2F03%2F31%2F%E4%B8%AD%E9%98%B6%E9%BB%91%E9%AD%94%E6%B3%95%E6%95%99%E7%A8%8B-%E4%BD%BF%E7%94%A8PlantUML%E7%94%BB%E5%85%B3%E7%B3%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[OverView 当我们使用linux的时间越来越长，就会发现使用鼠标和gui是多么的不安全。作为一名程序员，我们把所有的过程都演进成了编程。比如使用latex对文学进行编程，那么关系图呢？是否也可以使用编程个代码的方式使用呢？我不断的寻找，终于找到了答案，使用PlantMUL。 本文将介绍在emacs下安装使用plantuml的教程。并实现一个plantuml的hello-world程序。之后介绍有关使用plantuml写类间关系图的简单教程。 预备知识什么是 plantUML？ 请百度大兄弟。先送上官方网站。所谓的plantuml是一种画图的脚本语言。这个官方网站是中文的，足以保证你自学了。有许多编辑器可以使用plantuml插件的。但是本文将要介绍eamcs下的插件安装和使用。其他平台请自行百度谷歌吧。 在使用这个教程之前你需要做的是: 安装emacs 使用spacemacs的配置。几乎我所有的教程都是依据这个配置进行的。在我之前的博客中有这个教程。 安装JDK。这个真心也是不难的。（windows用户可能要考虑配置环境变量） 安装 spacemacs中的plantuml layer 使用emacs中spacemacs配置的 plantUML layer。这个在之前博客中有类似的介绍。使用快捷键SPC-h-SPC打开帮助。键入plantuml就可以看到安装教程了。就是在在.spacemace的配置文件中加上plantuml然后重启就可以了。哈哈，现在是不行的。因为plantuml要依赖一个的jar包。这个就是要配置jdk的原因。 下载plantuml.jar后。如果是mac的用户放到~目录下就可以了，这里的路径是默认的。其他平台的用户请自行百度。（QVQ 对不起） 第一个holle-world 程序 现在让我们来感受一下这个plantuml的强大吧。首先我们要记住plantuml文件的扩展名是.pum。好的先建立一个叫做test.pum的文件。写入一下内容。12345@startumlA -&gt; B : lovingB -&gt; C : kind of lovingC --&gt; A : no one knows@enduml 这里有两个快捷键。使用SPC-m-c-o可以设置生成图片的输出格式。现在先设置成png格式。然后使用C-c C-c就可以生成图片了。如下图所示。 现在使用另存为就可是保存使用这张图片了。 使用PlantUML画类关系图 非常遗憾我发现官方网站上的文档已经很全面了。所以我就实在是不想做这个无用功了。虽然他们的排版不一定比我写的漂亮。但是就知识的本质而言我再写一遍是没有意义的。谢谢你的理解。 我将一直的无知与迷惑，我是黄油香蕉君，再见。 (更新如果遇到错误怎么办？)如果你是mac用户在画一些图的时候会遇到一些错误。比如dot没有找到之类的。这个官网上有说明的传送门运行几条指令就好1234brew install libtoolbrew link libtoolbrew install graphvizbrew link --overwrite graphviz]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>spacemacs</tag>
        <tag>plantUML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾遗录8]]></title>
    <url>%2F2017%2F03%2F24%2F%E6%8B%BE%E9%81%97%E5%BD%958%2F</url>
    <content type="text"><![CDATA[写在前面 我知道我们都要乐观，开开心心的过每一天。可以伤心，但是别陷在里面。我希望读到这里的你，可以开心点。哈哈哈哈。不然你也不会读到我写的东西了。 节奏欢快的情诗诗123456789101112131415161718192021 淡淡的幽殇是谁触动了我————淡淡的幽殇是谁抹开了我，灰蒙的印象像是谁许下的期望又像是谁感叹 那无常 而又悠长的月光是谁触到了我————淡淡的幽殇是谁写下过的，“永远不忘”像是雨后的蝶，落向海棠又好似那一圈一圈的年轮 述说着的流浪是谁触及了我————淡淡的幽殇是谁倾慕着，可爱的女郎在某个地方 亦或某个方向也找不出来 同样优雅 而又快活的新娘是谁触摸着我————淡淡的幽殇是谁领着无期的思念 等待着成长是曾经 不该的 【1】还是别的什么？我不曾发现 爱的星光 解 这是一首有旋律感的诗，创作与高中时代。没有什么特别的创作原因，这首诗我自己很喜欢。虽然诗的名字是“淡淡的幽殇”，但是整个诗读下来不会觉得低沉，反而是充满了一种生命力。在上大学的时候才听过一首钢琴曲叫做《快乐还是悲伤》英文名叫做《the soul》灵魂，估计译者是听到了曲中旋律中的矛盾，在快乐的上扬旋律中暗带着悲伤，于是这样命名。我的诗是正好相反的，悲伤中暗带着快乐。喜欢一个人是痛苦的，但是却也是快乐的。我们在恋爱中品尝着种种悲伤，以为那就是爱情的模样，却常常忘了它快乐的一面。 我至今坚信一切的一切都是真的。所以下一次谈到过去读者和我都笑出来吧QvQ [1] 这里是没有写完的部分。在第一次写完的情况下空出来的。补过很多的词。童年 年少 等待 勇气 自尊 等等。这些词我都尝试过，最后都觉得不好，于是就空了下了。读者可以自己填一个词，那一定是一首属于你自己的诗了。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>拾遗录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Common-Lisp调用C语言函数]]></title>
    <url>%2F2017%2F03%2F24%2F%E4%BD%BF%E7%94%A8Common-Lisp%E8%B0%83%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言 我们知道在emacs实现中使用的lisp和c语言。这个设计使得emacs成了一件不折不扣的艺术品。这样的好处是将两种语言的长处发挥到了极致。当然其中还有一些设计哲学要去学习。不过我们先看看在common lisp中调用到c语言的函数。 我的环境 MacOS SLIME （emacs + spacemacs 配置） mac自带的gcc quicklisp 以上这些的教程都可以在我之前的博客中找到，我就不写传送门了。 准备过程（其中可能有方法论） 接触这个问题的过程是从我希望使用common lisp写出GUI来开始的。那么我有什么路可以走呢？自己写一个图像化接口几乎是不可能的。其实如果哪天我疯了或许会开始这样的一个项目:P 那么现在有一条路可以走，就是调用已经有的跨平台图像化接口。第一个想到的竟然是openGL，额。尴尬的是OpenGL来做这个活并不是很开心。而且在我面前还有一个重要的问题，那就是怎么用CL调用到C语言实现的文件。（动态和静态链接库） 于是我百度谷歌使用CL调用C语言函数，结果有一个人问：用cffi和ffi那个好？额。这个是什么呢？结果一查我发现这个是Common Foreign Function Interface的缩写。外部函数接口。这个不就是我想要的吗？简单的看一下英文这个不就有C的支持吗~于是欣喜若狂，的打开了文档。这里有传送门 所以让我们写一个小的demo来调用，自己使用c写的一个测试方法吧。 完成c文件 新建一个项目。建立一个叫做testlib.c的文件。现在我们就定义一个简单的函数吧。如下:12345678#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MIX 100int test_fn(int x)&#123; return MIX;&#125; 要记住我们是没有办法直接使用c语言的源码的。我们需要先编译了才可以了。运行下面的命令就可以生成必要的文件了。 123$ gcc -c testlib.c# 这将生成 .o 文件 然后我们要的是 .so 文件$ gcc -shared -fPIC -o testlib.so testlib.o 使用common lisp 来调用这个文件 现在在同级的目录下建立一个叫做test.lisp的文件。文件里的内容如下: 1234567891011;; test cffi(ql:quickload "cffi")(cffi:define-foreign-library testlib (:unix "testlib.so") (t (:default "testlib")))(cffi:use-foreign-library testlib)(cffi:defctype back-max :int)(cffi:defcfun "test_fn" back-max (x :int)) 简单的介绍一下这些代码在做什么。define-foreign-library是在定义一个C语言的库。这个方法用来指定库的位置和在不同环境中的位置。然后use-foreign-library加载这个库。现在直接调用时调用不到的。我们需要定义这个c中的函数到lisp中，同样要定义好入参和出参的值。 现在SPC-m-&#39;打开一个REPL，然后逐条的对上面的语句使用C-c C-c。如果没有错的话现在就可以调用这个函数了。 我们在REPL中输入(test_fn 1)就可以看到返回了我们在c中定义好的100了。 Learn More 现在就可以写我们自己的c语言的函数，然后使用lisp优雅的调用他们。但是单单是我上面的介绍肯定远远不够。我们还需要在必要的时候阅读上面传送门中的文档才行的 写在最后 我本来是想在这个过程中使用lisp调用有名的gtk。虽然我现在还是不了解那是个啥。安装也没有成功。但是并不影响我在成功调用到c语言时的激动。相信我可以使用CL的这个功能在以后带来更加精彩的应用。谢谢读者们。 我将一直的迷惑与无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>lisp</tag>
        <tag>cffi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾遗录7]]></title>
    <url>%2F2017%2F03%2F18%2F%E6%8B%BE%E9%81%97%E5%BD%957%2F</url>
    <content type="text"><![CDATA[题于同学录诗1234百花殆尽方很晚，归雁南山故人心。 社过桃李香不在，醉卧席听门扉音。 邻家姊弟笑正临，青竹相伴秋千去。 仰首空间白鸟孤，低头不忆垂髫时。 解 想解这首诗，就要提一下这首诗的创作背景。高三正是到了毕业季的时候，大家开始互相发同学录。（不知道当初什么原因。我是没有的，现在有一些后悔）一个女同学给我了同学录，(不是我喜欢的那个)正值年少轻狂的我，于是在寄语中写了这首诗，以卖弄自己的“才华”。一样的并没有什么才华好去卖弄，写同学录的时候重要的是真诚，好在我给大家写的都很认真，我本人也很珍重。只不过那时诗句就在脑子里，于是就写下来了。 “百花殆尽方很晚”这句老实说写的并不是很好。我本意就是写一个铺垫，铺垫一种分离的气氛，但是写出了一种要分离却悔恨的苦楚，实在是在渲染手法上乱了分寸。同样是分离,觉得“恨晚”的自责和同学间分离的不舍是有区别的。只能说功力不够，花鸟来凑。不过细细想来也还可以，人不都是在分离的时候在觉得自责吗？分离就分离吧，没事的，就像每年归来南山的鸿雁，心还是一样的。这里……现在想想真是有点耐人寻味的感觉。我后来去重庆上学住的就是南山。但是我当时怎么会知道呢？我连我能考到什么学校都不知道。如今看来有些命运离奇之感。 “社”这里是使用的一个隐喻，古代的时候“社”是一种祭祀活动，要杀猪杀羊喝酒祭天。此处暗指的就是吃的那顿散伙饭。正是那样的春季，聚会过后“桃李”就都不在，就都离开校园，大家酒过三巡，欢愉不在，也安静下来。醉卧席间。仿佛若有所失，仿佛若有所得。安静异常，听到门咯吱的声响。 忽然有人回忆起了更加小时候的事来。“那个时候我和邻居家的小妹妹玩的很好，我还和她手拉着手一去去荡秋千呢…………”众人目光变向远方，仿佛真的看到那时的情景。是啊，曾经我们不也是一无所知的小孩子，可是时光一晃就到了到了现在了。抬头看天，一只白鸟飞过。不禁低下头低语:“不说儿时的事了”。 这里，白鸟是时间的隐喻。不知道为什么我就是觉得白鸟是代表光阴的意象。其实那是青春未过却又有青春很快的意味。这最后一句是情感的收束。是我写诗的毛病和问题。总是使用一个情绪低的结尾。这首诗在情感表达上是克制的，但不是美好的。在艺术手法上使用了简单的“举头望明月，低头思故乡”的模式。可意境始终是低沉了些，只是到了今日我有了一个，比较积极的新解释。 看见白鸟，即知道时光继续流逝，既是匆匆逝去，又是滚滚未来。和从前儿时的玩伴虽然忘记了，但是我们不是又交到了新的朋友吗！青春如此来来去去，这次努力不忘记就好。“别说你小时候的那些事了”，我们快讨论讨论想去哪所大学，有什么理想，有的没的都可以说……………… 不行我编不下去了。你们自己想吧~ 读我自己的诗真是郁闷啊。我下次一定要找一首欢快的诗来写。一定。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>拾遗录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Common-Lisp写一个png文本转换器]]></title>
    <url>%2F2017%2F03%2F17%2F%E4%BD%BF%E7%94%A8Common-Lisp%E5%86%99%E4%B8%80%E4%B8%AApng%E6%96%87%E6%9C%AC%E8%BD%AC%E6%8D%A2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[注意 本文为非干货版本。其中有我从开始到最后的几乎全部开发时的思想，和走的一些弯路。如果你和我一样不愿意看这些，请直接看源码。 前言 要提到最初的想法，很疯狂。这要从我使用w3m在命令行里看网页开始。那时我十分喜爱没有css样式的网页。（ps：前端听到会气死的）渐渐我喜欢上了命令行的简单编辑方式。于是我使用emacs。也使用emacs上的eww进行网页浏览。那是本着使用emacs做一切的精神，于是思考：可以用emacs看视频吗？这个估计是肯定可以的。但是我不喜欢那种直接使用外部播放器的形式。我想要的是即使使用命令行也可以观看视频的网络服务。 哈哈。估计只有疯子想在如今这个时代做这样的事吧。现在网速也可以了，没有必要把图片压缩成这样的格式，在进行传输。但是仅仅是一个想法，仅仅是好玩。那是我使用的工具是java和c，这两语言当时对我来说一个有太多的细节要去讨论（java）另外一个太底层要做太多的工作。更恐怖的是，我当时对多媒体编码一窍不通，这里不是说我现在就通了，而是我知道了他的可怕，那时纯是出身牛犊不怕虎。 现在我学习Common lisp想着正好做点什么练练手。视频太复杂了。试试把一张图片转化成文本格式吧。 我的环境和工具 MacBook Pro emacs 使用的是spacemacs的配置 添加了common lisp的layer 使用SBLC作为lisp解释器的实现 使用quicklisp 作为system构建工具 关于quicklisp使用的介绍我就不写了 别人写的很好的 传送门 献上。这个很有用，如果你学习这个教程一定要看。 开始顶层设计 首先我们知道一张图片是一个数字的概念，至少在计算机里。有许多的点(像素)，每个点上有一个颜色，合起来就是一张图片。那么我操作这些点的值或者根据这些值进行一定的计算就可以得出我们想要的图了。 一些细节 哈哈。听上去很容易。但是有很多的细节要解决。首先图片有很多的格式，比如png,gif等。我怎么从这些文件中获得到对应的点阵(这里我叫他bitmap)呢？这个是其一。其二我怎么解决使用的文件的格式问题，这么多文件格式我只提供一个入口？ 第二个问题好解决。文件格式很多我肯定不能一次性写完，虽然他们从bitmap到文本的算法是相同的。于是我觉得先写一个png的转换器在一步一步的做。然后又时间了把其他类型补上。这个问题解决的了。现在变成了怎么从png导出到bitmap的形式。 于是我去看了png格式的文档。这尼玛，官网文档是英文的啃下来我这肯定是要疯的。于是找了一些博客，发现上面写png格式的数据段格式不是按照顺序存的，而且还使用了我没有听说过的压缩算法。这不是要坑我吗~而且使用了CRC校验，这我是大学的时候学过，但是最讨厌了。怎么办？ 这个有关于png压缩算法的 传送门 。有兴趣的朋友还是应该看看，特别是学编码的同学。 探索过程 有一句话说的好。你能想到的轮子别人都做过了。虽然这句话有毒，要是这么想就什么也不用写了。但是也有一定的道理。lisp风行怎么多年，不可能连一个解析png的小模块都没有。但是怎么找呢？百度？谷歌？答案是都不太好。肯定是我的搜索词有问题。(关于搜索我将单独写一个文章)百度就不说了没啥人查lisp的东西，文章也少。谷歌，相关度或许要高一些。但是呢~ 英文实在不好啃。于是我使用了github自带的搜索。于是一下子出来了好几个。有zpng,png-read。有的写了不错的文档，虽然是因为的但是还是要啃的。文档不好怎么办，读源码吧。于是在png-read中发现了他可以读取一个PNG文件返回一个CRC校验结果，并且返回一个png-state的对象。再打开这个文件看到这个对象中有一个槽(lisp中的对象属性)名字叫image-data。这个或许就是了。我靠，突然发现命名是如此的重要。 现在又有一个问题了，我怎么使用这个包里面的函数呢？我怎么构建自己的项目呢？毕竟我是连那个包管理都弄得很蒙圈的人。而且要处理依赖什么的。想想在php中人们使用composer在java中使用meavn，那么common lisp就没有什么吗？于是我找到了quicklisp。上面的传送门里有介绍哦。(如果你想读懂我下面的内容就要看) 开始编程吧 现在我们需要的东西都有了,可以开始了吧。先写一个最简单的，读取一个png文件到一个全局变量里面。1234 (defparameter *png-object* nil)(defun set-png-object (file) (setf *png-object* (png-read:read-png-file file))) 这个函数再简单不过了。现在我想这样先获取一个图片的宽和高以便于在后面可以方便的建立一个对应的bitmap进行接下来的运算。 还有我写的其他很多函数都要判断这个*png-boject*这个值存不存在以免出现不安全的调用。 12345678(defun check-object-and-do-funcation (fn)(if (eql nil *png-object*) (format t "we never hava png-object.please use funcation (set-png-object *file*) to set frist") (funcall fn)))(defun get-size ()(let ((fn #'(lambda () (list (png-read:width *png-object*) (png-read:height *png-object*))))) (check-object-and-do-funcation fn))) 好了。回到一个重要的问题上面。我们怎么转换的算法问题了。 一点算法的讨论 说道这个算法，我就想到了我在大学的时候学的一门叫做《数字图像处理》的课程。想当初我因为经常逃课不去，还被取消了考试资格，无奈来年重修了。 说道这个算法我首先想到了就是简化。首先说道我们使用的颜色表示系统。RGB颜色。这个很简单用过PS的都知道，比如我们熟悉的66CCFF是洛天依的颜色。表示的就是这个系统—红绿蓝。值都是从0到255。也就是说这里每个点存的是一个向量。现在由于我使用文字符号作为颜色的表示于是就不可以考虑图片的颜色差别，只能估计到颜色的深浅（其实可以，一会有空我在讨论），于是乎我就要把原来的3维的向量映射到一个灰度表上。这里将有许多种思路。其中先说本程序使用的，也是最简单的方法。 RGB到灰度的算法算数平局值法 这个方法估计一下子就可以想到了。就是算三个颜色的平局值然后在根据这个平均值进行映射。想一下原来时0-255每个，取完值还是255个。这个方法真的不算是最好，不过是最简明的。但是是我思考了其他方法最后选择的。因为这个方法的缺点很明显，比如两完全不同的颜色（0 255 0）和（255 0 0）。在这种算法下本来是一个正常的边界，现在灰度会变成一样，就糊到一起了。这个当然不是我希望看到的。 注意 下面的内容和专业知识有关，但是写的又很不专业，如果你不感兴趣我不建议你看，也许会对你造成迷惑。（我将用“选”字标记） 向量距离法（名字自取 不知道有没有这种算法）选 这个算法没有结果测试，完全是我自己脑补的。首先一般的像素点周围有8个向量。正好是9宫格中，中心点周围的8个。那么他与每个向量有一个距离。（即向量间距离，这个高中就有学计算起来不是很难）这个距离可能是正的（+）也可能是负的（-）。这里的正和负正好反应了他和另外一个像素比是“更深了”还是“更浅了”。而数值的大小表示的就是灰度的差别。那么我们可以制作一个这样的一个九宫格的模板。中间正好是四周向量间距离的和。让这个模板在整个图片中走一遍就可以得到一个新的图像了。这里还可以进行一些小改进比如在模板中加入权值的方法。这个方法的好处是图片的边缘的部分被锐化了。（在强调一次，我没有试验过，我是理论上这样认为，如果有时间我将试验一次） 从灰度图映射到字符 这里我们得到了一个bitmap了，就是我说的灰度图。（这里是思想试验得到的，不是真的。从我读取数据到我得到灰度图，还是需要一些时间的）那么我们要做的就是写一个方法，将灰度对应到一个字符表上。这里有一个很大的问题，怎么定义一个字符表呢？这个问题我没有很好的答案。至少应该是根据字符位图中占的黑块数目的多少来确定的。那么这个怎么确定呢？对不起这里我没有很好的找到代码的实现，也没有自己的实现。我甚至都不知道在搜索引擎中使用那个关键字进行搜索，在qq问别人也很难描述。这个问题太奇葩了。当然这个还不是最奇葩的。可以看看下面写的“更加有趣的想法”。于是我根据自己经验定义了一个灰度0到19也就是二十个字符的对照表。这个对照表写的很有问题你可以修改或扩充它，或者使用其他算法生成它。代码如下： 1234567891011121314151617181920212223(defun get-string (i)(case i (19 ".") (18 ",") (17 "_") (16 "-") (15 "~") (14 ":") (13 "!") (12 "+") (11 "=") (10 "a") (9 "0") (8 "b") (7 "%") (6 "V") (5 "H") (4 "E") (3 "&amp;") (2 "#") (1 "M") (0 "@") (otherwise "@"))) 好了我们现在要讨论的成了从算出来的0-255的灰度值到这20个符号的映射问题了。 简单分割法 你可能会想这个有什么好分的，不是就是255除以一个数得19余个几然后分个20个区吗！然后每个区对应一个字符。ok~我就是这样的方法。没有任何问题。这个方法简明好理解。或者如果出现最后一个区太大，可以取巧一点各个区匀一点。下面是实现的代码。123456(defun get-string-bitmap (bitmap)(let ((string-bitmap (make-array (get-size) :initial-element "."))) (dotimes (i (png-read:width *png-object*)) (dotimes (j (png-read:height *png-object*)) (setf (aref string-bitmap i j) (get-string (aref bitmap i j))))) string-bitmap)) 但是这个并不是很好的方法。为什么呢？想一下如果一个图得出的灰度集中在某一个范围内，怎么办呢？比如都出现在20-99之间。结果这里就只有对应3个符号，本来有起伏的一张图片就变的一摸黑了。这个当然不是我们希望的。 直方图法 选 实际上这个也思想并不复杂。我就是想让图片中所有的像素的灰度分布的广义点。比如说原来有一个图片只有3个字符对应的（使用简单分割），现在会出这个图片灰度分布的直方图，然后重新定义灰度到符号的映射关系。让密的地方多分几个符号，让稀疏的地方少分几个符号。这个是可行的。这样将会时原来的图像层次丰富起来。这个思路完全是照搬《数字图像处理》这本书中的思想，如果有这本书的同学不妨可以拿来看看。这里实现过程和算法细节我就不说了。 更加有趣的想法 选 现在让我们忘了使用“深浅”定义灰度到字符的映射关系。忘掉之前所有说过的算法。先想一个问题：一个像素点对应一个字符合理吗？想想一个符号占的大小，绝对比一个像素点还要大吧。那么比如一个符号的宽和高占的大小是10个像素。当然具体多少我也不知道。那么一张原来是200X200的小图片就变成了2000X200的大图片，这个更不用说是1080X1920的大图了。在电脑屏幕下根本显示不过来。于是最优的方法是，根据一个字符占的空间的大小来匹配图片中对应大小的空间。这里就有一个相似度的问题。这样在我看来是最优的解，根本不需要定义什么映射表就可以达到。但是我对于字符所占像素大小和获取上面的像素点信息的方法没有头绪。而且使用预定义列表表示字符的方法很反感。这个有趣的想法只能日后来解决了。 实验结果 我从网络上找到了一张“面码的图片”一下是处理生成的文件: 不足 由于开始把宽和高搞错了导致图片是旋转了90度的(已经修复) 由于对图片像素的读取顺序的未知，图片是镜子中的。(已经修复) 图片总是很大不方便看 git源码传送门 传送门 写在最后 使用lisp开发时一段开心的旅程。但是一些有用的lisp特性并没有使用成，可能是我使用的不熟，有可以是没有使用的必要。不过这个在3天的时间完成了，这个速度是我自己都没有想到的。我总结了一下是我对于搜索工具的使用上更加的高效，也归功于CL这门语言的独特魅力。这次写完其实很激动想总结一下方法论的东西但是写到这里也就罢了。 我将一直的迷惑与无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Common-Lisp教程（2）]]></title>
    <url>%2F2017%2F03%2F13%2FCommon-Lisp%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 在lisp中有这许多迷人的特性，要弄清他们还真的不是很容易。我都不确定自己到最后可不可以真正的弄清楚。所以暂时将最简单和浅显的内容整理出来。 函数函数的定义 (defun [函数名] ()[形参表] “函数说明”()[函数体]) 这有几点要说明。首先这里面对形参表是指它前面一个括号里面的列表(list)，当然也可以为空形参有多种形式一会介绍。函数说明可以不写，但是出于规范，我还是建议你写上函数的说明文档，函数说明可以通过某种方法得到。函数体可以使是一个合法的S-表达式。当函数被调用的时候。lisp将对这表达式求值并返回。 实例:1234(defun add-two (x) "add two to x" (+ x 2));; (add-two 1) =&gt; 3 函数的形参&amp;key关键字形参 关键字形参使用&amp;key作为关键字。默认的在&amp;key后都视为关键字实参。与正常参数的不同关键字形参在赋实参时，需要像字典一样进行赋值。 1234(defun say-love (&amp;key he her (say nil say-p)) "a funcation to make he say love to her" '(he (if say-p (if say 'is 'not) 'not) say love to her));; (say-love :he banana :her hyacinth :say t) 我们可以看到在这里可以对关键字形参设置一个默认值，如果没有传值的情况下，该变量就会是这个值。而也可以使用一个x-p来接受是否传了这个值。正如上面的代码一样如果传了值say-p就是t，没有传的情况下就是nil。 在lisp中 t 表示逻辑真。 nil 表示逻辑假。 &amp;optional 可选形参 可选形参表示参数是可选性的，如果不传值lisp并不会向你报错。当然你可以给他们附一个缺省值，默认情况下会是nil。 &amp;rest 可变长参数 在编程的过程中，我们可能有不确定参数个数的情况。关于这个关键字。官方有这样的解释: 如果我们在函数的形参列表里的最后一个变量前，插入 &amp;rest 符号，那么当这个函数被调用时，这个变量会被设成一个带有剩余参数的列表 以下是一个实现了funcall的例子。 12(defun our-funcall (fn &amp;rest args)(apply fn args)) 定义匿名函数 相信使用过其他语言的匿名函数对非常熟悉了，他在闭包中有很大的作用。这里匿名函数使用关键字lambda。这里的形式和函数的定义相似，就是把defun改成lambda不加函数说明就好了。其他是一样的。匿名函数没有那么多的参数列表类型。这正好与匿名函数的应用场景有关。 那么如何得到匿名函数呢？有一个语法糖。使用#&#39;即可。如下: 1(remove-if-not #'(lambda (x) (= (mod x 2)))) 写在最后 我快疯了。我看了两个教程。发现两个教程的风格,完全不一样。一个是《实用Common Lisp编程》这个注重实践。不像一般教课书，一板一眼。一开始在我还没有了解语言的全部基本语法的情况下，带我写了一个简单的数据库。实用很多实用的函数还要宏的概念。让你你开始就看到了lisp的实力。 但是这本书不适合喜欢节奏的没有时间的宝宝们。如果你有热情，你还有时间可以一周内学完这本书的实例的话。我建议你使用这本书。 但是如果你没有时间，喜欢有章节的学习。忘了的时候还可以查询的话。我推荐你官方教程的翻译。传送门这个可能翻墙小伙伴们，学习科学上网吧。 看完这个教程你可能踌躇满志，想用lisp写点什么，突然不知道它可以写点什么。这时《使用Common Lisp编程》就成了最佳的选择。书中有进行垃圾处理的程序和一个音乐管理器。这都是不错很酷的尝试。 我教程的更新速度将更加慢了。因为我已经为你找到了，更好的学习路线。如果有机会我将，在以后的文章中写自己用Common Lisp做的有趣的事。 那个时候来到了。一定很快乐吧:) 我将一直的迷惑与无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾遗录6那些花儿]]></title>
    <url>%2F2017%2F03%2F12%2F%E6%8B%BE%E9%81%97%E5%BD%956%E9%82%A3%E4%BA%9B%E8%8A%B1%E5%84%BF%2F</url>
    <content type="text"><![CDATA[玉兰三首诗123456789 玉兰 素素白玉兰，幽幽香倾园。 飒飒凉风起，美娥停房前。 笑笑昔时情，泪泪今不理。 碌碌相思苦，恨君不成语。 淋淋一夜雨，纷纷花离枝。 容颜何易老，春风伴雨时。 解 在重庆玉兰是一种很常见的植物。在我母校重邮的校园中就有许多。她们大致在春季一开学的时候便会开花。都是长在树上的，不过有一种长在很高的树上。就在二教。想要碰到，只有去二楼，在打开窗子伸手出去。不过我是没有真的去二楼打开窗子伸手。倒不是觉得危险什么的，是没有这样的兴致。 我是很喜欢花花草草什么的，但是自己养不活，也懒的打理。从大庆一来到重庆，最使我感叹的就是这座城市的植物。那些花式我在北方不曾见过的。春天有白玉林，广玉兰，到了4月又有樱花，秋冬之时还有桂花的花香。而这首玉兰是我在大学时的练习诗。即是写物诗并无什么意义。 可以看出我在诗中使用叠词，希望制造出一些不一样的语言节奏。第一首可以看出来在努力写花，我也写的很认真，还使用了拟人的手法。但是第二首就突然开始写花以外的事了。无非又是毫无新意的痴男怨女。不读也罢~而其中诗句也有前人词汇之影子。“碌碌相思苦，恨君不成语”不知道有多少人写过。真心苦于自己文思闭塞，关键的时候写不出好诗句来。到了第三首又开始写花写人。以花之命运来写人的命运。问什么“容易何易老”现在想想真是一个无聊的问题。我不是回答过了吗~我觉得回答这个问题是我全诗的关键所在。 容颜易老。花颜易老。那是以花喻人，还是以人喻花？我想了很久这里的写法，觉得都不是。易老的不是人和花，是万物。“易老”是自然的规律。即便你是婷婷盛开清风徐来，还是香气宜人婀娜婉转，结局都是“易老”。此问如此观之便是无意义的。我们常常把易老的锅甩给一个确定的事物。是别人，是误会，是分离，是欲望，是时间。其实都可以不是。我们或许努力着，憧憬着。然后不经意间就发现了。哈哈~言过，什么“易老”之因或许一开始就不是我这样一个20多岁人应该考虑的话题。真惊叹于自己曾经格调有些低了。 这里最后一句曾经修改过几次。我本子上记得是“容颜何易老，相恋负心时”。后来觉得格调太低。前一句其实就是答案，于是私下改为了“容颜何易老，一夜雨淋淋”。想想又觉得重复了。于是改为了上文中的内容。 残语几句诗123 残语几句 一年一年又一年，分离相视已无言。 春风春雨春花尽，春思春愁春不眠。 解 本诗成于大四期间。具体时日不记得了。反正你可以看出来我写的就一个“春”。说白了就是残语几句，太直白了。这就是我后来的风格变化写诗越来越直白。越来越不喜欢使用典故与一些谐音表达自己的情感。往往是爆发似的吼叫，诗中宁静不在。但是还是有写悲伤气氛。至于原因嘛。我也不知道。或许是我自己的问题吧~ 写在最后 本来没啥好说的。我以为自己的拾遗过程会很有趣。想想自己当初的想法，会不自觉的发笑。这样也是寻见了一件趣事。可惜不是这样的。为什么我写的诗都是不开心的诗。我以前就这个多愁善感吗？这和我的外貌可是极度的不符啊。这样只会别人笑我，我自己是笑不出来吧。以至于我发现有些诗，我连读不不想重读。回忆起写的时候的感觉，很不是滋味。于是有的诗没有整理到拾遗录中。我也知道这些东西也不会有谁愿意来看的。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>拾遗录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾遗录5秋风中的少女]]></title>
    <url>%2F2017%2F03%2F04%2F%E6%8B%BE%E9%81%97%E5%BD%955%E7%A7%8B%E9%A3%8E%E4%B8%AD%E7%9A%84%E5%B0%91%E5%A5%B3%2F</url>
    <content type="text"><![CDATA[秋风中的少女词123 相见欢 秋洛神 诵古书窗小院，杨柳纷，黑衫颦顰摘叶黄，枕坠旁。 停适处，洛神伤，暗自凉，浑然远眺秋波寄篱墙 解 首先这个是一个有题目的词。这样的有题目的词我写很少，是因为我实在懒得起题目。就连本词也不过是在下阙中取三个字。这是一首写记事词，诗中之场景是真实发生过的。我与一位朋友一起见证过。不过诗中的少女不是什么我暗恋的人，也不是我笔下的什么洛神美女。是一个很普通的人，她相貌平平，凭心而论算不上漂亮。而且性格也不像我诗中所写有古典之风格，甚至有点疯癫的时刻。我跟她也不熟。说这些，不过是要给各位读者打一个预防针，词是靠不住的东西。在写词人（我不算了）心里，可能就是和吃饭唱歌一样是一件平常的事。 “诵古书窗小院”是用古典的场景来写现在的校园，这个校园是我高中的校园。当时在高中第二节课下课进入大课间，大家都回去食堂的服务部去买点吃的东西，我和友人走在去往食堂的路上。两个男生定时聊一下有的没的无聊话题。时至深秋，万物枯黄。校园中的杨柳早就身披金甲，秋风无情，任意拨弄。于是杨柳纷纷，风声瑟瑟。我和友人远远望去，一个少女在一棵矮树下，盯着那棵树。白色的树干，淡黄的树叶，黑色的发，黑色的大衣。她细细端详的神态，安静秋风中显得孤独而美丽。我和友人不禁看待了。 我们放慢了脚步，都不说话。只见她“颦顰”两步，贴近树枝，慢慢的挑选，摘下一朵黄叶。秋风不识趣，一波一波的袭来，少女的发被缭乱。她卷起秀发，顺达耳后，手中那枚黄叶轻拍这着她的脸颊…… 上阙中内容很好理解，下阙怎么就突然“停适处，洛神伤，暗自凉”了呢？这个场景美丽，不是姑娘美丽（当然姑娘也美但是不是这首词的审美所在）。是意境神伤，不是我神伤。所以暗自凉的是秋意与秋风。“停适”更像是时间的暂停，我与友人若有所思。高中生活很快，节奏快时间也快。见到此景便有了少有的宁静。这可能就是妹子的力量吧。这也是我对美的理解。每当她们自由自在无所顾虑之时，便有天真可爱之美丽。那是在人灵魂底端的真实，我天生的审美的细胞自然告诉我，使我自然的开心。我常常被这样的美所治愈。也常常发现这样的美。总结就是两个字，自然。其实不太准确。不过懂我的读者一定懂我的意思。哈哈哈。 回过神来，想再看看时，人已经离开。只见远处白墙。美不是结果，是过程。不是抽象的，是藏在实际的事物中。庸俗的将是发现美丽的眼的问题。我却要说是孤独程度的问题。或许无人懂秋风中她为何要摘黄叶，也无人懂我为何若有所思，一切思虑在风中发生，在风中被遗忘。 有点可惜我想不起来，当时在想什么了。 矛盾的人啊词123 长相思 无题 系也乱，拆也乱，中国结断妄自散，不忍挥刀尺。 合也怨，弃也怨，破镜难圆半照面，倩影忽若现。 解 我觉得这首词我是我写的最通俗的一首了。估计不需要太多解释就可以看懂。所以简单的解释一下几个意象： 刀尺： 这里只制作衣服的工具。 倩影： 这里有点鬼影的意思。是有一个有关的典故的（已经忘了出处）。 所以上阙是写女下阙是写男。女才挥刀尺，有一到两断的联想。男才见倩影，魂牵梦绕疑神疑鬼。 人就是如此，总是在内心中充满的矛盾的心理。如此纠结反反复复，难以脱离苦海。没有人可以解脱，这世间的男男女女都是一样，所以当你陷入矛盾之中莫要过的烦恼，人皆如此。但是怎么办呢？我词中没有答案。或许都对，或许都不对。谁知道呢~~ 那么谢谢读者们。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>拾遗录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在emacs中进行文件管理]]></title>
    <url>%2F2017%2F03%2F02%2F%E5%9C%A8emacs%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 放弃命令行。和我使用emacs吧。打开emacs让我们体验一波。 再次强烈建议读者使用emacs+spacemacs的组合。 进入Dired模式 使用快捷键 C-x D 刷新当前目录 在Dired中 g 就可以了。 选择文件 在dired模式下，如果你要一次性操作多个文件和目录，那么你要先标记 mark 那些问价和目录。 然后再使用快捷键 对这些文件进行操作。 常见mark命令 m 标记当前光标所在的目录。 u 取消当前光标所在文件目录的标记 U 取消所有的标记 d 对要删除的文件和目录进行特殊标记，打上flag t 反选所有的标记 常见文件操作 + 创建一个目录 C (大写)拷贝文件 R 重命名文件，或者说移动文件 D 删除文件 x 删除那些打了flag的文件 Z 使用gzip压缩解压缩文件 使用书签 C-x r m 添加书签 C-x r l 查看标签列表 想直接编辑文件的名称啥的怎么办？ C-x C-q 然后可以编辑了 编辑完再来 C-c C-c 就完成了。 我的天 非常方便 C-c C-k 可以取消这次编辑 跨文件夹操作 在文件夹中按 i 就可以了 $ 可以实现折叠和打开 写在后面 今天施工把以前的博客移植过来了一些。有些是自己没有写完的坑。看来要慢慢的填了。我写文章有一个特点就是如果已经有别人很好的教程我是懒得抄的。于是你可以看到许多的传送门。哈哈你可以叫我传送门法师了。:p 我将一直的迷惑与无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>emacs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《高数》书里的鬼故事]]></title>
    <url>%2F2017%2F03%2F02%2F%E3%80%8A%E9%AB%98%E6%95%B0%E3%80%8B%E4%B9%A6%E9%87%8C%E7%9A%84%E9%AC%BC%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[前言 高等数学书里有的时候给了证明过程，但是却没有给原因。就好像解题方法自己飞出来一样。如鬼故事一般。 数列收敛唯一性的证明 我们都记得在学习高等数学的时候有关于数列极限唯一性的证明。即一个数列只能收敛与一个数。在证明过程中使用反证法： 假设一个数列同时收敛于a和b然后构造了一个ε=(b-a)/2. 然后你会发现你可以轻松的证明出了定理.但是为什么呢?我也是百思不得其解.为什么要这样构造ε呢? 让们我重头解决问题 首先回顾一下数列的极限(收敛)定理是什么样的: 设 {Xn} 为一个数列,如果存在常数 a ,对于任意的的正数 ε (无论他多么的小),总存在正数 N ,使得当 n&gt;N 时,不等式 |Xn-a|&lt;ε 都成立. 那么我们不妨先假设其收敛与M和N看看最直观的会发生什么.由于a和b肯定不一样不妨令a&gt;b; 12n&gt;N1时,|Xn-a|&lt;ε1 总成立. n&gt;N2时,|Xn-b|&lt;ε2 总成立. 这是你能要分类讨论了!当Xn-a&gt;0的情况或Xn-a&lt;0的情况.会得出一下两个式子. 12Xn-a &lt; ε1; a-Xn &lt; ε1; 这是在收敛与a的时候就是两种收敛于b的时候又是两种,排列组合就是4种情况要去讨论,简直就是噩梦. 难道就没有办法了吗? 要是这两个式子都成立就好了.等等! [1] 这时 我们要注意了!!!在定义中ε是一个正数也就是说这两个式子总是成立: 123Xn-a&gt;0时: Xn-a &lt; ε1;成立;由原不等式直接得到. a-Xn &lt; ε1;也成立,因为a-Xn&lt;0一定小于一个正数ε. 那么反过来呢?我们来看看: 123Xn-a&lt;0时:a-Xn &lt; ε1;成立由原来的不等式直接得到Xn-a &lt; ε2;成立.小于零的数一定比大于零的数小 那么我也不用分什么情况了.每个式子都变成两个式子就行了.于是我们得到: 12345678910Xn-a &lt; ε1;a-Xn &lt; ε1;Xn-b &lt; ε2;b-Xn &lt; ε2;整理一下=&gt;Xn &lt; ε1+a;(1)xn &gt; a-ε1;(2)Xn &lt; ε2+b;(3)Xn &gt; b-ε2;(4) 我们始终记得我们要用反证法.那么我们就需要找到矛盾.看看(1),(4)是不是一下就有了灵感. 123ε1+a = b-ε2=&gt;ε1+ε2 = b-a; 看看!看看!这里就明白了书中的策略.他令ε1=ε2=ε于是计算出ε=(b-a)/2的! 其实这里只需要满足这个式子就可以了不一定要什么ε1=ε2我觉得书中的写法反而不利于我们理解. 其实细心的你一定也发现了这个式子不具备普世性.试试这个式子! 1ε1+a &gt;= b-ε2 这才是最终的解题关键!读者不妨试试令ε = (b-a)/16一样可以证明得出.这就交给你们自己去完成吧. 思考 在最初复习高数的时候我在看这段证明时怎么也想不出来!于是卡在这里。我先是奇特于为什么ε要那样的赋值。于是认真的跟着步骤计算了一遍怎么也得不到其中的结果。我思考如果我证明的话我会怎么办.于是才有了这篇文章。 细心的读者可能注意到了[1]处我其实最想的是构造一个Xn&gt; 什么的式子。这样我可以轻易的生产出矛盾。发现当Xn-a&lt;0时可以做到后,开始思考其他情况下怎么证明,于是才有了后面的简化情况讨论。 我将一直的迷惑与无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>看书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim操作小结]]></title>
    <url>%2F2017%2F03%2F02%2FVim%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言 如果你以为我是一个喜欢vim的编辑器的vim支持者你就错了。我是一个emacs的支持者。但是我曾经自大的以为在这个世界上只有emacs的快捷键才是最优秀的。 直到我接触了vim的编辑文本时的快捷键，我才发现vim的编辑模式是如此的高效率，当然使用亲爱的emacs的快捷键效率也是很高的。 但是vim的优点是：它不会使我的手部因为长期使用快捷键而畸形（真）。 所以在看这个教程前我推荐大家使用spacemacs来作为你的主力编辑器。然后使用vim的按键模式。这样两全其美。就像红楼梦中的贾宝玉。娶了黛玉和宝钗一样的爽。 VIM模式 正常模式 （按ESC） 插入模式 （在正常模式下按i等） -INSERT- 可视模式 （* 在正常模式下按v 这条是在spacemacs中的 vim里的不知道） 插入的命令 i 在当前光标之前插入 I 在当前行首的第一字符之前插入（mac 上的spacemacs 其他没试的这么细） a 在当前光标之后插入 A 在当前行未插入 o 在当前行之后插入一行 O 在当前行之前插入一行 查找命令 注意 在spacemacs你完全可以使用emacs的传统 C-s 来完成。但是我还是要写一下vim的方式。 在正常模式下按 / 然后使用 n 查找下一个 使用 N 查找上一个。 注意 特殊的字符在查找时要进行转义! 不过我喜欢下一种方式是在spacemacs中独有的，其实是有插件实现的 如果你在emacs中安装也可以的。 所以来看vim的朋友请跳过这个段直接看下一段吧； spacemacs的朋友们，这个很好用 不过有局限性。就是 SPC v 此时在文本中会自动的选择一个词。接下来就可以再下面的状态栏里有搜索的选项了。你懂得。 这些在spacemacs中方便的指令你也可以在快捷键 SPC s g 中找到哦。 移动命令 这个是我最喜欢vim的地方之一 h= 左移一个字符 l 右移一个字符，这个命令很少用，一般用 =w= 代替。 =w= 是向右移动一个单词。 k 上移一个字符 j 下移一个字符 除了这些还有一些其他常用的命令 0 移动到一行的开头 gg 移动到文件的开头 G 移动到文件的结尾 C-e 向上滚动一行 C-y 向下滚动一行 撤销和重做命令 u 撤销操作 C-r 重做命令 删除命令 x 删除当前字符 dh 删除前一个字符 dd 删除当前行（ps：这个我觉得很有用的） J 删除两行间的空格 拷贝粘贴 y 拷贝当前光标选中的字段 yy 拷贝当前行 p 在当前光标之后粘贴 写在最后 vim中的有些思想真的很优美，有些操作真的比emacs好。学过来就是不要纠结。有信仰，但是信仰应该是方便和美学不是某个编辑器，我们爱的是emacs背后的东西，绝对不能成为器物的奴隶。 我将一直的迷惑与无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>emacs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spacemacs下的magit指南]]></title>
    <url>%2F2017%2F03%2F02%2Fspacemacs%E4%B8%8B%E7%9A%84magit%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[看这个教程之前你要: 成功安装了emacs和使用了spacemacs的配置。 已经了解使用了git 为什么要使用magit？ 首先，对于一个用户来说在命令行中使用git时不方便的。我其实没有心情记录那么多的指令。（其实也不多）但是gui又少了一些逼格。那么怎么办呢？又想高效又想直观，又要逼格。于是我们有了magit在这之间的完美权衡。 在spacemacs中配置。 首先magit已经集成在了spacemacs的一个layer中。这个layer就叫做git。layer是什么呢？这里你可以理解为一个spacemacs的一个可扩展模块。只要我们安装了它就可以使用新的功能。相信layer的安装你早就已经会了。就是在.spacemacs配置文件中的dotspacemacs-configuration-layers中的列表中加上git在重启就可以了。 magit的使用 注意 这时你可以使用 SPC h SPC 然后git回车就可以看到全部的文档介绍了。根本不用看我下面的教程了。你可以把下面的内容理解成简单中文笔记就可以了。或者你是一个新手要一步步的实验，那么let‘s Go！。 基本内容 要学习测试这些功能的话，要先在github或者是coding的远程仓库中建立一个项目。然后克隆下来。这里使用哪种方法都可以，也可输入最最原始的clone命令克隆，也可以使用sourceTree的GUI克隆,也可以使用SPC SPC后键入magit-clone来克隆。这些都差不多。现在使用文件管理模式进入到克隆下来的文件夹。 好现在使用快捷键SPC g s进入到magit-mode。你可以在修改一些文件后进来。那么你现在可以在这个模式下有许多的操作。来看常用快捷键: q 退出 s 将添加光标处文件的修改 S 添加全部的文件修改 u 不添加（取消）修改 x 放弃文件的修改 c c 提交这次的修改 相当于commit，此时会出现diff界面还有输入message的buffer 输入commit的信息够C-c C-c提交成功 P u 提交到远程仓库 P m 提交本地分支到远程仓库。（新建本地分支时使用) b b 检出某一个分支 b c 创建某一个分支 一些高级功能使用tag 在magit-mode中。t c创造一个tag。然后使用P T上传到远程仓库。 合并分支 在magit-mode中。m m然后格局提示操作即可。 写在后面 现在你可以很开心的使用git了，而不再需要使用命令行。这也导致了我一些命令和顺序都忘的差不多了。以至于在别人电脑上操作经常的出丑。其实这也没有什么，电脑作为工具本来就是使人更加的方便。所以使用gui也可以。但是程序员，在选择时也是有自己的审美和哲学的。技术和美是分不开的。相信你也体会的到。:) 祝你天天开心，微笑常在。 我将一直的迷惑与无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>git</tag>
        <tag>spacemacs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Common-Lisp教程（1）]]></title>
    <url>%2F2017%2F02%2F28%2FCommon-Lisp%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面（可以不读） 在写这个系列教程之前我仔细考虑了一下，我要不要写。因为这个common lisp语言我也不会。但是我却觉得自己还是要写这个教程。原因很简单，小的时候你或许也有没有看完的电影，想去却一直没有机会去过的地方，一直很喜欢一个玩具，好不容易存到钱买的时候却被别人买走了。那是一种遗憾，我们未完成的，我们不曾得到的事物，我们内心中总是觉得是美好的。于是感叹要是当时如何如何就好了。当时我要是学common lisp就好了？哈哈。这当然没有，只不过我觉的学好这门语言是我必须做的事。不能每一件事当我们回首的时候都是遗憾吧。 我开始写博客了，并不是要怎样。我是想让我博客的读者明白什么。因为我知道了有人可能读我的文字，于是我知道我有特殊的责任。这个教程非做不可。 安装commom lisp的开发环境 本教程介绍的是在mac下的Slime开发环境。在spacemacs中使用的common lisp 的layer。即emacs+sbcl的组合。还有一些默认的配置。sbcl使用homebrew安装即可。 这个过程并不是很难，使用Spc-h-Spc,输入common-lisp就可以查看文档。虽然是英文的但是说明的很详细。 spacemacs中的一些超级常用快捷键 在lisp文件中SPC m s i 打开一个REPL。REPL是什么一会还有解释。 在lisp文件中使用C-c C-c可以将一个表达式加载到REPL中。 SPC m c C 编译文件并且加载到REPL中。 写第一个holle world程序打开一个REPL 一旦你成功的安装了common lisp的开发环境，你就可以按我说的一步一步的做。首先在你的工作目录新建一个扩展名为lisp的文件，如test.lisp。进入文件。然后使用快捷键SPC m s i打开一个REPL。你可能看到如下的画面。 现在解释一下什么是REPL。他是（read-eval-print loop）读-求值-打印 循环的缩写。也就是说这个REPL会像我们熟悉的python或者matlab的命令行一样，我们输入然后在获取计算输入的值的一个循环。这在lisp中是个很重要的概念。这样我们就可以实现交互式的编程。我们可以一边写功能一边讲funcation编译测试函数的行为是否正确。不像有些语言只有写好后才能知道写的对错。 实际上任何语言几乎只要你想都可以这样开发。但是lisp这样的成本很低，甚至这也是它的核心思想。即交互式开发。至于这样有什么好处我现在还不得而知。 好了现在我们要来体验REPL了。输入(+ 1 1)我们会看到返回了2。相信聪明的读者已经看懂这段代码了。括号里东西组成了一个lisp列表。其中lisp对列表求值时会将第一个元素视为函数的名字。+便是这个函数的名字。注意这里+真的是函数名，不是什么保留字，在lisp中没有什么是保留字。后面两元素便是这个函数的的实参了。 现在我们要写holle world了。先将buffer切换到test.lisp文件中写下下面的函数。 12(defun hello-world () (format t "holle world!")) 这里简单的解释一下defun是一个定义函数的写法，现在我们可以定义一个叫做hello-world的函数了。而format是一个打印的函数。一般情况下函数有一个输入一个输出还有一个副作用。比如我们以删除文件的函数为例。文档的地址为他的输入（有点也可以没有输入），t或者nil（lisp中的真和假）是他的输出。删除文件是他的副作用。也就是说无论如何lisp表达式是会返回值的。format这个函数中打印内容是他的副作用并不是他的返回值，他的放回值一遍为nil。 那么我们现在如何运行这个函数呢？将光标移到函数体内部。使用快捷键C-c C-c现在你将会看到REPL中打印了一些东西。;compiling (DEFUN HELLO-WORLD ...)证明这里函数编译完毕了。现在试试调用这个函数。 hello-world 结果进入了debug模式，还提醒这个值没有绑定（unbond)。这是怎么回事呢？如图： 原来在REPL中调用函数必须使用列表调用，虽然名字是一样的，但是直接键入hello-worldlisp解释器会默认寻找一个叫做hello-world的变量而不是调用这个函数。于是我们应该这样调用。 (hello-world) 于是乎我们看到了正常的输出。这就是lisp的hello world程序了。 写在后面 不好意思，这个不像是教学，更像是我的学习笔记。很多地方没有解释清楚。比如函数定义和变量什么的。但是作为第一个holle-wrold程序足够了。我接下来回整理接下来的章节安排。这个系列可能跟新的很慢，希望可以有好的进度安排。 jekyll中似乎对lisp的语法高亮支持不好。我将在以后解决这个问题。 我将一直的迷惑与无知，我是黄油香蕉君，再见。 友情链接]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中阶黑魔法emacs教程]]></title>
    <url>%2F2017%2F02%2F28%2F%E4%B8%AD%E9%98%B6%E9%BB%91%E9%AD%94%E6%B3%95emacs%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这个世界上有太多的分歧，人们很难达成共识。比如吃饺子应该蘸酱油还是蘸醋，豆腐脑吃甜还是吃咸等等。但是这些问题在我眼里一点意义都没有。真正重要的是编辑器之争。什么才是世界上最好的编辑器。我会回答你当然是emacs了。为什么？因为我就是emacs党哈哈。 你可能是小白,还没有选择你信仰，少年！我将世界上最好的编辑器，传福音给你。记住我们的敌人是vim，而不是使用vim的人。少年啊！爱我们的敌人吧。他们有许多的有点可以学习。而使用vim的往往也是有品味的人。至少他没有说sublime，IDE什么的是最好的编辑器，从这个角度讲我们是一样的。vim的使用者往往也是终端指令的高手，他们的组合技往往是：OH—MY—ZSH + vim + 插件。他们关闭打开，关闭打开。并对欣赏这速度乐此不疲。在文本中，他们的上下左右移动只需要一个键，许多快捷操作方便到哭。这就是和我们另外一个阵营的朋友们，他们一样很优雅。 可是我的朋友。请记住在这个世界上没有什么是emacs不能的。教内有人声称emacs不是编辑器是一个操作系统。还差一点，我们离登基那一部还差一点。传送门我们和老朋友vim打了许多年传送门现在可以握手言和了，因为我选择了emacs + spacemacs(vim-mode) +插件。 Come on！和我一起进入今天的黑魔法课程。 准备安装emacs 这个过程一开始可能很轻松也可能很痛苦。这要取决于你使用的是什么平台的电脑。这里有英文的传送门各位小伙伴可以视情况而定，因为我下面还会写一些 Windows 平台 这个我是不太建议在windows下直接使用emacs的，知道用个ubuntu虚拟机或者docker。但是我还是会献上传送门。不是说windows下不能使用，而是说windows下的一切都不好玩。这个我也没有安装过，对不起。但是欢迎你马上投入到linux和mac的阵营中。 linux 平台 这个要简单许多了。以Ubuntu为例，来个传送门。我最开始就是在ubuntu的虚拟机上使用的 Mac 平台 因为这是我现在使用的平台我会详细介绍一下。 首先安装homebrew。安装过的可以跳过。 之后安装emacs-for-mac。用brew安装emacs-plus哈哈！恭喜你遇坑了！我就是这样安装的。结果出现了下方状态栏出现色差的问题。在一位群内好友的帮助下我成功的解决了这个问题;完美的解决方案在这里传送门这个版本的emacs在mac上比较稳定速度也很快。 开始自学吧 对你没有看错。现在你可以自学了。emacs有许多神奇的地方，为了坚持下去你可以选择一项技能先自学起来。比如使用Org模式，这是一个神奇的东西。可以很优雅的管理你的日程。而且我也问过很多哥们都是从这里才开始接触emacs的。当然还有一部分是通过latex接触emacs的。无论是那种都有的折腾一番了。 学完之后 可能你会觉得很缥缈，读到现在了还不知道emacs可以做什么，弄完之后是什么样子。额。好吧，我来简单的介绍一下。 首先这个是炫酷的界面。快乐的分屏和一些操作 这么多 怎么学 使用spacemacs的配置一部搞定。安装传送门 用的时候看说明文档 建议多去看文档，如果我的教程就是把它们抄过来一遍也没有啥意义。 我们的朋友在哪里 在国内有许多的emacs的大法师，比如子龙山人。在优酷中有他全套的教学视频，最重要的是中文的，而且讲解的很详细。子龙山人主页,他有一个《21天学会emacs》的视频很适合去学习。不光如此他还建立了elpa的镜像，（当然这里还有其他人的努力）让不能翻墙的小伙伴获得了福音。 这里不得不说到emacs的国内论坛。emacs-bbs很多大神就活跃在上面，你的提问几乎都有人来回答。相信有了这些信息你将会开始一段快乐的emacs之旅。:) 我将一直的迷惑与无知，我是黄油香蕉君，再见。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>spacemacs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《暗时间》一本没有读应该马上读的书]]></title>
    <url>%2F2017%2F02%2F27%2F%E3%80%8A%E6%9A%97%E6%97%B6%E9%97%B4%E3%80%8B%E4%B8%80%E6%9C%AC%E6%B2%A1%E6%9C%89%E8%AF%BB%E5%BA%94%E8%AF%A5%E9%A9%AC%E4%B8%8A%E8%AF%BB%E7%9A%84%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[前言 记得我在上大一的时候我们的班学姐向我推荐过这个本书。但是当时我没有看，后来要毕业的时候在同学的书架上发现了，并假借过来。从此发现人类历史中还有这么优秀的思想。如今每次重这本书的内容都会更正我近来的一些误区。接下来我将简单的介绍一下，·我·在书中得到的一些知识。 如果你已经工作了，相信这本书可以让你工作之余的生活更加的有意思。如果你已经结婚有孩子，每天承受着我不曾想象到的生活的压力，我相信你依然可以会爱上这本书的内容，丰富的阅历会使你看到的比我更多。如果你刚刚高中毕业，还没有踏入或者刚刚踏入大学的校园，那么太好了！这本书仿佛就是给你们准备的。你现在完全可以关了我的博客马上去买一本，或者向你的学长借一本。如果你学过编程或者你将要学编程，这个本书对你来说更加的适合。 我甚至觉得所有的理工科的院校都应该把这本书最为大学的一门课程来学。 我更新的知识投入的真正计算方法： 我曾经以为时间就是我的投入。当别人问我学了多久的画画？学了多久编程时。我们往往回答一个时间长度，比如我学了三年编程了，学了五年画画，唱了十年的歌了。其实这样的回答是没有实际意义的,别人在正真在问你你对某件事物的投入。（当然大部分人这样问其实是在寒暄）可是你自己不能当真。我学了三年编程，也写不出一个网上交易系统。但是我上铺的哥们怎么一个月就搞定了呢？有了这样的心里落差是因为我们搞错了一个东西。那就是投入的计算过程。 原来错误的公式是这样的:投入 = 时间于是我们就有了，我“投入”三年，上铺的哥们“投入”一个月。于是得出我的投入比他多的结论。但是我的效果比他差很多，于是又得出了我不适合编程或者我很笨的结论，不然就是得出了我上铺的哥们是个天才的结论，这样安慰自己。 现在我们修正一下公式。 投入 = 时间 X 效率 现在谜底揭开了，我学习编程的时间好像是三年，但是三年中我并没有在真正的每天都在学。好吧就算现在我和他都是用一个月的时间，可能我还是没有他学的好。很简单，我学的时候并没有投入全部的注意力，于是在一些概念上模棱两可。不光是编程，在大学中所有的课程都是如此，可能我去听了一学期的《信号系统》课，也没有上铺的哥们玩了一学期，最后复习一周加上答疑的效果好。 我不是告诉大家要逃课，而是说如果你不知道自己上课在做什么。没有集中注意力去学习，效率为零甚至听着就可以睡着，还不如专门找一个时间自学呢。我是知识本位主义者，一切形式都是纸老虎。 注意 ：答疑真的很重要。交流你不知道的知识点，哪怕是有一点似懂非懂的部分。老师人都很好，当你表现出强大的求知欲，他们不会因为你不上他课就不给你答疑。这样考试也变成了检验你学习成果的有意义的过程，不再是没什么意思的程序了。成绩下来了，不要傻傻的问别人的分数，参考意义不大，没考好就要反思这段时间学习的投入，看看问题是什么。时间太少？还是效率太低？无论哪种都有解决的原因。 学习好英语很重要（外语） 我在大学的时候打过辩论赛：是否要取消义务教育中的英语。其中有一个观点是：以后从事的职业中用不到英语，所以浪费了很多时间。呜呼，哀哉。现在很多人也这样以为的吗？不是这样的。 首先这种看似实用主义的想法在社会上大行其道，其实在逻辑上是经不起推敲的。我最TMD讨厌的就是某些学长学姐，告诉新来的学弟学妹们，什么上大学学不到什么东西，就是来学生组织给进入社会做一个缓冲什么的。虽然我也在同届的人面前互相自嘲过，但是从来没有毒害过孩子们！大学生，一旦上了大学就应该以学者自居，这个自居不是要天天说出来，而是不动声色的做出来。理论上进了大学，什么都要学的，无论文理。也别听他们说“大不了自学”，如果你经历了四年的自学，当然可以拿这句来自嘲，但是别还什么都没有学就把这个句挂在嘴边，甚是可笑。 闲话少序，回到正题。所谓知识有两个特性。 看似无关的知识，存在内在联系。 知识分两类：领域知识，和元知识。 有关这个内容书中解释的更好，更加的详细。我不过是二道贩子，强烈建议去看书。 我们现在一个一个看。第一个大家都有感触。比如我们现在使用的很广泛的CDMA编码技术的发明就是这样。首先赞叹一下这个位被称为CDMA之母的杰出女性,海蒂·拉玛。你一定以为她会像居里夫人一样是个科学家出身，或者是一信息学编码学的天才。都不是！她是一个有名的好莱坞艳星。而且以出演烂片出名。（这个太过了，细心的读者可以自己验证）一次在和他丈夫弹钢琴中她发现了这个算法。（当然有一个懂通信的丈夫也很重要lol。）CDMA的核心思想很简单，你不需要读通信专业也不需要啃《信号系统》我在这里就可以说明白。 比如我不懂钢琴，也对音乐一窍不通。我上铺的哥们和他的女朋友都受过良好的古典音乐教育。一天我们三个在琴房聊天。女的问我上铺的哥们，他生日想要什么礼物。他二话不说，弹了一首李斯特的《钟》。他女友就知道了，他想要一块闹钟或者表之类的。于是又问他（她）们下次去哪里约会。我上铺的哥们又一言不发的弹了一曲奥立维尔.图森的《海边的星空》。于是他女朋友笑了，知道下次要去海边。我哥们很自然的问起了她女友的生日。她让我上铺的哥们挪挪位置，弹奏了一曲肖邦的《冬日》……在一旁不懂音乐的我是懵逼的。他（她）们在干啥呢？这就是CMDA的原理，加长原来的编码。这里可能有点夸张，比如“钟”一个字被变成了一首曲子这么长。这样有两个好处。一是安全，不懂音乐的我就什么也听不懂，只觉得这是美妙的音乐，完全不知道里面的信息。还有一个好处是如果弹错也知道这个是什么曲子。而且旋律越长这种效果越好。 这里的解释方法的创意不是我本人，这种解释方法的原作者已经不记得了。本人盗用创意，进行编造。致谢、致歉。 看吧知识存在的形式，不只是知识的表面。谁知道英语中蕴含怎样的知识呢，所以学习其他看似无用的知识也是一样。不光如此，我们来第二点。就是领域知识和元知识。这个概念我其实没有理的很清晰。（即没有特定的公式判断是A还是B）举个不太恰当的例子。我们知道神话中（圣经还是希腊神话？请知道的同学告诉我一下），人类在诞生之后使用的是一种语言。于是人类想要超越神，大家聚集起来想建立通天的“巴别塔”。神知道了，使用瘟疫与天灾都没有效果。人类的塔继续向天上建来。后来神扰乱了人类的语言。人类不使用一样的语言，不再团结，“巴别塔”也建设不起来了。 这里语言就是元知识，而比如建筑学，工程学之类的就成了领域知识。元知识看似没有直接的作用，但是可以帮助我们更好的获得领域知识。比如心理学，脑科学，记忆学等。所以这里我有点分不清数学属于什么类别。我更愿意定义为工具知识。但是这个又是另外一种分类方法了。 这里有一个很实际的问题，所有知识看似都有用,如何选择呢？人的时间是有限的。我们不光要学习，也要享受生活。必要的情况下还要挣钱，恋爱，考虑未来和家人。那么这个时候你就要好好思考，你是真的在你说的这些事情上投入了吗？还是这些事你也没有做好，你只不过给自己找个借口呢？ 但是如果你真真遇到了类似选择上的烦恼，我这次真的什么也帮不到你，很遗憾我没有这方面的知识。 文理双修 很大一部分原因我在上文中已经介绍了。这里不再赘述。 教是最好的学 你会在书中看到这句的原话的。而且很好理解。而且我已经有了切身体会，高中那会要不是我暗恋的女生经常来找我问题，我估计我连大学都考不上:P 但是自己口才不好，也没有人问我题啊。怎么办呢？到了大学后寝室的哥们大多都在打游戏，平时讨论的也是游戏，只有上铺的哥们在看书，但是我说什么他都懂。难道我要找打游戏的哥们自讨没趣吗？首先我要说打游戏真的很爽，千万不要在他们玩的时候找他们，相信考试之前他们自然会来找你。（或你上铺）如果你是一个女同学，完全可以在约会的时候给你男朋友讲一讲你最近学的内容，或者解题的过程心得什么的。其实最好的方法是写blog，或者做教程视频。如果你坚持下来会发现是一段很神奇的经历。（我没有做过视频，可能是我以后的计划之一） 写在后面 总之，《暗时间》这是一本没看，就应该马上来看的书。这本书可以说是拯救了人类。至少拯救过我。我上面写的内容大都在书中有了介绍，但是本质还是我读书的心得。是二手的。书中内容比这些要精辟的多。怎么样,是不是已经有了阅读的欲望呢？ 这本书有点美中不足的地方，其中很多使用了程序的比喻，程序员或者理工科学生很容易懂，但是文科同学不一定有兴趣阅读。很遗憾。这本书的知识范畴超越的文理，但是阅读的兴趣也是在阅读中很重要的因素。说了这么多，如果屏幕前的你都没有尝试一下。我会很遗憾的:(]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>看书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拾遗录1234合集]]></title>
    <url>%2F2017%2F02%2F26%2F%E6%8B%BE%E9%81%97%E5%BD%951234%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[（写在前面）如果你不是很无聊现在走还来的及。如果你没有什么事做，正好想读点什么。那么我建议你看看名著之类的。比如豆瓣上有许多有用的书单。你就这么无聊吗？还要继续读下去？…………那们好吧。来看看我要写些什么。我准备整理我以前的时候写过的文字。于是我起名为“拾遗录”。或许你认识我。那么你讲很容易理解我接下来的描述。如果你陌生的朋友，那么我就好好和你说一下了。我喜欢写写诗歌，文章什么的。特别是在上初中高中大学那一会。我那天翻了翻之前自己写的文字，自己都吓了一跳。我怎么是这么矫情的一个人。注意！我在初中时是这样一个形象，不爱洗头，还有一脸青春痘。平日还有点猥琐。（别人是这么说的）但是我写的文字却异常的没有这种气息。气质不是由内而外的吗？现在想想真觉得是一件有趣的事。于是我决定将我以前的文字整理一下。简单的介绍一下当时的写作背景和一些心情。还有如今我对里面一些事物的看法。这个拾遗的过程一定很有趣。一定是充满了尴尬而又温馨的过程。于是我大致的理了一下我的文字都有什么。一个精美的本子用来写古体诗的（还有点日记）。一个竖开的笔记本写现代诗的。一个小本写散文杂记的（不幸已经遗失了）。还有一部小说，和一些小说的片段。于是乎。这成了一个巨大的工程。如果你很好奇的想看，虽然可能性很小，我会稳定的输出。比如一周一到两篇之类的。…………所以还是很无聊对吧。现在走还来得及。如果你发现我写的是你有关的事，或者你知道是什么事。请千万淡定。别说出来。还有欢迎评论。：) 拾遗录（一）1234 相见欢 无题 本是兰芳幽月，会娇眸。可怜独酌空杯，万事休。 拾朝花，落眉愁，西风破，吹散多少佳人鬓凤头。 本来是“兰芳幽月”的画好月圆之时，可能会和倾心的女孩有见面的机会。后来可能什么原因没有见到，于是独酌空杯，觉得什么都没有意思。我还深深的记得我写着首词的时候，还是初中。根本还没有喝过酒。时间大概就是初二初三的样子。当时暗恋一个女生。但是真的记不清是发生什么事了。 可能就是一开始就傻傻的以为在学校之外有了可以见面的机会。结果竹篮打水一场空。我不知道，读者有没有这样的时候。一次见不到面什么的，就觉得“万事休”。可能是青春期情绪波动比较大吧。于是作业也不写了，电视也不看了，这也觉的无聊，那也觉得无趣。现在来看看我当时写的诗都是有点无事强说愁的感觉。实际情况是：我当时喜欢的人，初中四年和我说过不超过十句话。可能是那个时间段自己看的书啊，文章啊，都是这种伤秋悲春的。于是有了下面的“拾朝花”，与眉头紧锁。 结果少年还是无法排遣内心的苦闷，不觉已经西风大作，却还想到她头发被吹起来的样子。这里“西风破”肯定不是什么西风了，就是瞎写的随便一个什么风，反正我是分不清东西南北的。而且我当时还嘴硬，竟然问多少，好像有多少我担心似得。还不就是一个人。记得当时的她坐在我前面，我每天上课的时候就看到她的马尾辫。偶尔侧过头，被风吹起来，一缕鬓角随风轻动。 我生造出“鬓凤头”就是想描述这个情景。但是总的来说，诗里的“本来”可能就是自己的想象。但是我为啥用“词”这种形式来写呢？真的不记得了。说是词，但是根本没有关心平仄转韵的规律。可能“词”不过我抒情的载体。诗中没有那句直接写我喜欢别人，这比较像我曾经的风格。不过这个风格在后来的诗中越来越不明显了。可能是成长中，少了矜持的品质吧。不过现在想想，当时这首诗不过是折磨自己的低吟吧。 呵呵（苦笑） 123 虞美人 无题 梅花点水芙蓉开，伊上镜妆台，胭脂柳眉雪凝面，难道哀烨何处惨相见。 高山流水知音断，彩蝶良梦散，调琴也得泪两案，匆匆无缘却把玉折半。 要说上一首，还是有故事的诗，这首就是真的是瞎写了。其实也是我的想象。有点像闺怨词。上阙前三句什么的，大致写女子自己一个开开心心的打扮好自己姣好的容颜。什么“梅花”、“芙蓉”、“胭脂”这些意象都是写女子美丽容貌和品格的。额。好吧。这样分析有点像我们做了好久的语文的诗词鉴赏题，哈哈哈。其实就是美丽的女子化完妆，打扮了一下。之后第四句我又生造了一个词“哀烨”。读者估计猜的出来，这是一个拟声词。说女子内心难受想哭却哭不出，哽咽又叹气的声音。哈哈。当时我真是有意思啊。这是一种什么声音啊？估计我没听过是纯想象的。 后面的就很好理解了。就像高山流水的知音不在了，梁祝的彩蝶也不能双飞。自己一个人拨弄琴弦，想想昨日种种，今日只有自己一个人。“守着窗儿，独自怎生的黑”。在案边不禁暗自流泪。只能感慨上天定下的人和人之间的缘分是有限的，只是我和你相处的时日太短，一切都太快了，来不及闪躲，只能安慰自己“匆匆无缘”了。可见她是绝望的，但是却又是有希望的。一块玉，变成两半，你一半我一半。 真想象不出，初中生写这样的诗句做什么。可能是那个年纪，发觉爱情悲剧的必然性，和在对悲剧中挣扎女性的思考。可能向往那样的情感，也可能暗示自己求不得的心态。甚至可能就是哪次我和倾心的女生什么东西正好被分了两部分，正好有我一份有她一份，然后我意淫写出来的精神胜利诗。 这首诗一样没有说什么喜欢啊之类的。不过我当时把那个人的名字藏在了诗里。也算我比较大胆吧！ to：读者，元宵快乐 拾遗录(二)在最后的时间献给情人节123 苏幕遮 无题 龙香烬,烧粉语,青鸟快书,醉恨相思雨.庭外咋然故里曲,枉然幽怅,苦忆鸳鸯侣. 子规栖,丁香月,熏衣正浓,冥冥若相许.香兰谢娘桥边落,红字帖得,各自心中喜. 似乎从这首词开始,我便尝试使用各种意象和典故.所以解释起来可能有点麻烦。因为其中使用的典故出处我自己都已经忘记了，不过我会努力还原我词中的思想. 这仍然是我的想象诗,似乎在那个年纪我总是充满了各种各样的幻想,也许这就是所谓的中二吧。上阙描写的是一对情侣分开后在家中为对方写情书的情境。这里可能大家不太理解,既然是情侣,是互相喜欢的人，为什么还要写情书呢?平日里你侬我侬的已经够了,写情书做什么呢?这里请读者原谅我,原因是当时我以为情侣之间才会写哪种风花雪月的话，情人之间如何交流都是靠我凭空的想象。所以不免诗词中闹了笑话。便写出了这么一对肉麻的情侣。今天正好是情人节，我们不妨来看看。 烧了一晚上的香,都快烧完了,不知道烧了多少张我写的”粉语”,我觉得对你有千言万语,可是落到纸上却不知道怎么去下笔。写这个也觉得不对,写那个也觉得不好,哎呀！有没有一只可以通天的神鸟帮我问问,写什么才能让她开心。 “青鸟”古时认为的神鸟,可以和天通信,又是古时皇帝祈雨的神兽,这里我显然是认为它也可以帮我问问别人的心意。不知道你有没有这样的时候，想写点什么但是就是不知道怎么下笔。从而有了希望知道读你文字的人怎么想的心理。此处即是我笔下情侣的矫情又是我当时的真实感受。有的时候苦苦想了一个晚上,结果一看,还不是那么几句.“我想你”云云。就在这时下起了雨来。”醉恨相思雨”也可做”最恨相似语”。明明觉得有许多话诉说,结果到头来还是那么几句。愁自己真是没用。 夜尽天明,外面人们开始了一天的活动,响起了故里的音乐。顿时积攒了一夜的疲惫涌上手来，笔也握不住了,索性瘫在椅子上,独自哀声叹气,开始想想我们在一起开心的时候了。 上阙痛苦但是痛苦中却带着甜蜜,下阙两个人各自带着写好的信在相约的地点见面了。 鸟儿都睡了,一切安静恬谧。月光伴着花香。我们彼此都确定了这份缘天生注定，于是感叹这是”冥冥若相许”。但是见面的时间并不长,怎么见得呢?继续往下看。这里我用了一个电影式的描写手法。镜头一转，香兰花的花瓣从树上落下,缓缓飘过谢娘桥。(此处有典,已经忘了)此时两个人短暂的相聚已经结束了。结果如何呢？收到了情书,在各种心中都很开心。 这里我写的肯定不是现代的爱情。因为这对情侣,明明已经互相喜欢确定心意,却还小心翼翼。而且似乎是地下恋情还偷偷摸摸的,还在晚上幽会。幽会就幽会吧，结果匆匆相间又匆匆离别,只留下书信就分开了。可能是年龄小,也可能是父母家里不同意。现在在来看”红字帖”可不可能是暗示求婚呢?”喜”字似乎也表明我曾经想这样写过。这是我写这类情情爱爱的诗词的时候,少有的快乐的结尾。说不定诗中世界那对情侣有一个好的结局。 哈哈看来这样的诗,真适合在情人节“拾遗”呢。那祝今日的有情男女”红字帖得,各自心中喜”。 拾遗录(三)仙剑诗两首 我在高中的时候玩过一款电子游戏,仙剑奇侠传。相信不少人都玩过。当时每周周一到周四上学玩不上电脑,周天又得明天早起。于是都是周五和周六的晚上偷偷的在楼上玩。好几次看剧情打boss结果一回过神就早上3点了。所以第二天也就下午1点起床了。这是我的一个毛病，我曾经看某材料说明人一天最佳睡眠是8个小时(现在想想睡那么久干嘛~~)于是就会放心的睡了。 游戏剧情很好,可惜是悲剧。我记得我玩到中途的时候电脑坏了,无奈重新安装系统,游戏的存档都没有了。后来我又重新玩了一遍,一直打到结局。结果后悔我玩到结局了。 诗写的很烂,一个词,一个长诗,不想解说了.看看得了(玩过的小伙伴可以说说这是仙剑几的故事)。123 蝶恋花 无题 青眉秀目多情郎,若羁若癫,懵懂尘世间,那知生死天注定,相守碑旁忆当年. 玲珑娇柔多舛女,心生问道,寥寥命已牵,亡前与君痴言语,只羡鸳鸯不羡仙. 123456789101112131415161718 剑仙启梦录 青鸾峰上痴情郎, 悲目白雪守碑旁, 多少风尘叹事中, 只原一遇溪洞中, 玩伴好似旧相识, 茫茫凄凄求仙路, 太平村中引人厌, 无奈漂泊野外中, 无意誓言终生定, 好若相许冥冥间, 柳家有女深闺中, 心事浮沉心无主, 本为恩人报情意, 随着命动昆仑颠, 昆仑仙山琼露多, 一拜师叔紫英落, 平日放荡无人懂, 侠义人世正与恶, 月剑同鸣日剑出, 玄妙逍遥识故人, 义结金兰破俗定, 从此为兄劳奔波, 终得三宝故人出, 阴差阳错苦自责, 梦柳离花羞涩语, 语过之后人辞去, 从此不见花颜开, 只因人妖两不和, 为得红颜登天梯, 斩龙入境取影枝, 先入天楼取天弓, 后如幻冥明月中, 相逢时日不相依, 可怜浮华自恨生, 人妖何必残相对, 今世做人明为妖, 然后匆匆惨相别, 自梦幻合柳梦璃, 多少情仇剑影中, 不如重归山上时, 回梦仙游少年行, 多少情仇多少痛, 可怜相逢时日短, 无奈离人以做古, 生时憾然相许愿, 此生尽欢死无憾, 此生与汝永相伴, 青鸾峰上又来风, 相聚已是千年迟, 曾经欢笑不剩在, 只当人生幻梦间。 祝读者,晚安好梦. 拾遗录(四)模仿的练习诗 (下面两段可以不读) 首先这个是高中写的不是我现在写的。其次我在整理的时候发现我的诗竟然大部分写情爱这类的，这使我很苦恼。我都都惊讶于当初都写的些什么玩意儿,好在不是所有的诗和文章写的都是写男女之情的。其实就算是有,也不是特定发了什么事为了谁才写的。虽然因为遇见了什么事才写的诗占我写古体诗的比例还不小。 我本意也不是先整理古体诗然后再整理现代诗小说什么的。而是我现在身在重庆上班,现代诗的小册子和小说都放在了家中。无奈只能整理写过的古体诗。其实古体诗不是我偏爱的题材，受我个人能力所限制,诗中的形象往往重复而不贴近生活。不贴近生活就很难有打动人心的诗句。所以大部分诗是古体的抒情诗,而且往往又是以女性的视角写的闺怨题材。这就有点无事强说愁的嫌疑。（我又不是女的又没有闺怨）而后期由于我对诗词的喜爱，还时不时的写了一些练习的诗词,刻意的使用一些手法和修辞,或者模仿一种意境和语言风格。 当时高中的一个假期在家看红楼梦电视剧,对林黛玉这个角色很有感。记得那是87版的第30几集(这个真的想不起来了).宝玉在外险些遇险,被救回来后开心的去潇湘馆找林妹妹,可是这个时候林妹妹已经不在了。看到林妹妹走的时候并没有哭。宝玉兴高采烈的喊这林妹妹的名字,突然发现她不在了,于是宝玉眼神都呆了,他环顾四周一切陈设安好如初只是人不在了……他又说了一遍“林~妹~妹~” 画面停止了,响起了片尾曲.突然泪就不争气的落下来,怎么也控制不住了……. 后来又连续的哭了三集。 说这些是和这首诗有点关系,黛玉有葬花,于是我写了一首弄花.如今读起发现狗屁不通！名字都没有取好，花岂是能把玩的。意境很弱,词语堆砌的有很多。画面跳脱,我的语文老师要是看到了还不得笑脱了(就是嘲笑到要晕过去,这个也是我自己造的词). 123456789101112 弄花吟 春来醒水百花显, 英飞纷纷斗香艳. 一朵开似胜一朵, 当年花魁已不见. 为何风过馨已无, 为何椮椮无人读. 只见年年水向前, 忘却蒙蒙向少年, 独采花苞藏花瓣, 自伤别离一两面, 无端春雨绵绵飞, 静坐花亭往事追, 追忆不成两行泪, 才下花语诗已醉, 轻拦一筐去梦乡, 风化雪月在边疆, 多少今丝妄楼兰, 倚柱桃落断黄粱, 百芳易赏不宜葬, 葬伊销得故人神, 回眸忘川春雨细, 梦醒时分念一人. 椮椮(sen)这里的用法是错的。我忘了是谁在那里用过,不过意思似乎不对,不用查字典了！这里我错了。你可一理解成”惨惨”二字。 古人用意相:香草美人, 是政治诗。是写怀才不遇。我写香草美人就是为了写美人。哈哈哈哈……. 肤浅至此不敢多言. 博客转到这里 没有人可以评论了。我估计也没多少人看了吧。哈哈哈~~如此甚好。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>拾遗录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F02%2F26%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这一次 终于是 施工完毕了一些东西 我决定写博客，使用这种老土的方法来记录我的生活和思想。可能有人已经认识了我。可能有人还不认识我。没关系，我会自我介绍的。 关于我： 姓名: 黄油香蕉君(butter Banana bacterial) 性别: male 出生日期: 1993.9 职业: 魔法师:p（wizard） 我出生于黑龙江省大庆市的一个很普通的家庭，有一位双胞胎的哥哥。高中就读于当地最好的实验中学，那时的我害羞腼腆，还有一脸的青春痘。后来考入了重庆邮电大学。就读信息工程专业。在上大学的假期开始自学C语言编程，于是迷上了编程。在大学期间参加了辩论队。后来又自学了很多的语言，比如java，c#，php，python，matlab等等。现在已经工作了。主要使用的语言是php和java。最想学会的语言是js和lisp。这样我就可以成为一名合格的魔法师了，哈哈哈哈。我最近在看有关机器学习有关的知识。虽然工作了但是不想停止学习有趣的东西。所以你觉得我是一个标准的理科宅男？这个博客中都是技术分享？不你错了。我喜欢文学和艺术。在高考前我完成了人生中第二部小说（第一部没有完成，而且是初中写的，好幼稚啊QAQ！）我喜欢音乐喜欢唱歌，但是无奈唱的很难听。我喜欢美术很喜欢画画，现在偶尔也会画一画，不过这和我工作无关。我喜欢运动喜欢打篮球，但是大学中缺少锻炼体力已经不行了。我喜欢围棋，那是中国献给人类和机器最有意思的游戏。我喜欢玩我的世界，喜欢破坏和创作的简单真理。所以我博客的内容有： 博客的内容：技术分享 就是我平时遇到的一些问题。和解决方案 要不就是我为了装X学的技术然后怕忘记了就记了下来 我的一些有趣的，或者你觉得很无趣的技术上的设想 我重读《高数》《大物》等书的读书笔记等 读书笔记 我看书的心得或笔记 图书推荐 和 推荐他们的原因 随笔文章 闲来无事写的文章或者诗句 对时事新闻的看法 电影或者电视剧的推荐或者看法 我对b站up主的推荐和看法 我喜欢的歌的推荐 我为外语歌写的中文歌词 游戏那些事 我玩mc的一些心得和记录 我的信仰 没有什么语言是 世界上最好的语言 emacs 是世界上最好的编辑器 而spacemacs是个不错的配置 如果你要和我提vim。很好！我用vim的编辑模式 不要骂国足！我相信他们行~ 如果人心是善良通透的，那么沟通可以解决一切的问题。如果不是，别放弃。]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>自我介绍</tag>
      </tags>
  </entry>
</search>